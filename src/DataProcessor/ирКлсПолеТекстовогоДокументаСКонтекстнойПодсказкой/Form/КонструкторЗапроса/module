// Устанавливаются снаружи
Перем мКонфигурация Экспорт;

Перем мСтараяСтраницаПанелиЧасти Экспорт;
Перем мСтараяСтраницаПанелиОсновная Экспорт;
Перем мТекущаяСтрокаСвязи;
Перем мТекущаяСтрокаУсловияСвязи;
Перем мТекущаяСтрокаВыбранногоПоля;
Перем мТекущаяСтрокаУсловия;
Перем мТекущаяСтрокаПараметраТаблицы;
Перем мТекущаяСтрокаЧастиОбъединения;
Перем мТекущаяСтрокаЗапросыПакета;
Перем мТекущаяСтрокаВыбранныеТаблицы;
Перем мТекущаяСтрокаГруппируемогоПоля;
Перем мТекущееИмяТаблицы;
Перем мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей;
Перем мЧислоСтатическихКолонокТППоляПсевдонимовПолей;
Перем мРежимРедактированияТекста Экспорт;
Перем мТерминалыЯзыкаЗапросов Экспорт;
Перем ПараметрыДиалектаSQL;

// +++.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой
Перем ПолеТекстовогоДокументаСКонтекстнойПодсказкой;
// ---.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой

// @@@.КЛАСС.ПолеТекстоввогоДокументаСКонтекстнойПодсказкой
// Транслятор обработки событий нажатия на кнопки командной панели в компоненту.
//
// Параметры:
//  Кнопка       – КнопкаКоманднойПанели.
//
Процедура КлсПолеТекстовогоДокументаСКонтекстнойПодсказкойНажатие(Кнопка)
	
	// Специальная обработка команд компоненты ДО
	ЭкземплярКомпоненты = ПолучитьТекущуюКомпонентуКонтекстнойПодсказки(Кнопка);
	Если ЭкземплярКомпоненты <> Неопределено Тогда
		Результат = ЭкземплярКомпоненты.Нажатие(Кнопка);
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьТекущуюКомпонентуКонтекстнойПодсказки(Кнопка = Неопределено)

	Если ПолеТекстовогоДокументаСКонтекстнойПодсказкой.Свойство(ТекущийЭлемент.Имя) Тогда
		ЭкземплярКомпоненты = ПолеТекстовогоДокументаСКонтекстнойПодсказкой[ТекущийЭлемент.Имя];
	КонецЕсли;
	Возврат ЭкземплярКомпоненты;

КонецФункции

////////////////////////////

Процедура УстановитьДанные(НачальныйТокен = Неопределено) Экспорт
	
	Если ирНеглобальный.СтрокиРавныЛкс(мДиалектSQL, "WQL") Тогда
		ЗаполнитьДоступныеТаблицыWQL();
	ИначеЕсли ирНеглобальный.СтрокиРавныЛкс(мДиалектSQL, "1С") Тогда
		ЗаполнитьДоступныеТаблицы1С();
	Иначе
		ЗаполнитьДоступныеТаблицыADO();
		КопияТаблицы = ДоступныеТаблицы.Выгрузить(, "Тип");
		КопияТаблицы.Свернуть("Тип");
		ЭлементыФормы.ДоступныеТаблицы.Колонки.Тип.Видимость = КопияТаблицы.Количество() > 1;
	КонецЕсли; 
	Состояние("Анализ дерева запроса...");
	ОчиститьДанные();
	Если НачальныйТокен = Неопределено Тогда
		ЗапросПакета = ДобавитьЗапросПакета();
		ДобавитьЧастьОбъединения(ЗапросПакета);
	Иначе
		ЗаполнитьПоТокену(НачальныйТокен);
	КонецЕсли;
	ДоступныеТаблицы.Сортировать("Имя, Схема, Тип");
	ОбработатьПакетПослеУстановкиДанных();
	ЭтаФорма.ЛиПакетныйЗапрос = ЗапросыПакета.Количество() > 1;
	ЛксИзменитьСвернутость(ЛиПакетныйЗапрос, ЭлементыФормы.ПанельПакета, ЭлементыФормы.вРазделительПанельПакета, Панель, "лево");
	Состояние();
	
КонецПроцедуры

Функция ОбработатьПакетПослеУстановкиДанных(Пакет = Неопределено)

	Если Пакет = Неопределено Тогда
		Пакет = ЗапросыПакета;
	КонецЕсли; 
	Для Каждого ЗапросПакета Из Пакет Цикл
		ОбновитьНаименованиеЗапроса(ЗапросПакета);
		Если Ложь
			Или ЗапросПакета.ТипЗапроса = 0
			Или ЗапросПакета.ТипЗапроса = 1
		Тогда
			ПерваяЧасть = ЗапросПакета.ЧастиОбъединения[0];
			Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
				ОбновитьНаименованиеЧасти(ЧастьОбъединения);
				Для Каждого СтрокаВыбраннойТаблицы Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
					Если СтрокаВыбраннойТаблицы.ВложенныйПакет <> Неопределено Тогда
						ОбработатьПакетПослеУстановкиДанных(СтрокаВыбраннойТаблицы.ВложенныйПакет);
					КонецЕсли; 
					//ПолучитьИмяВыбраннойТаблицы(СтрокаВыбраннойТаблицы);
					НайтиДобавитьДоступнуюВременнуюТаблицу(СтрокаВыбраннойТаблицы.ПолноеИмя);
				КонецЦикла;
				ЧастьОбъединения.Автогруппировки = Истина;
				ЕстьАгрегаты = ЧастьОбъединения.ВыбранныеПоля.Найти(Истина, "ЕстьАгрегаты") <> Неопределено;
				Индекс = 0;
				Пока Индекс < ЧастьОбъединения.ВыбранныеПоля.Количество() Цикл
					ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля[Индекс];
					Если ПерваяЧасть = ЧастьОбъединения Тогда
						ИмяТаблицы = ЛксПолучитьПервыйФрагмент(ВыбранноеПоле.Определение);
						ИмяПоля = ЛксПолучитьПоследнийФрагмент(ВыбранноеПоле.Определение);
						Если ИмяПоля = "*" Тогда
							ЧастьОбъединения.ВыбранныеПоля.Удалить(Индекс);
							Индекс = Индекс - 1;
							Если ИмяТаблицы = ИмяПоля Тогда
								//ИмяТаблицы = ЧастьОбъединения.ВыбранныеТаблицы[0].Имя;
								МассивВыбранныхТаблиц = ЧастьОбъединения.ВыбранныеТаблицы;
							Иначе
								МассивВыбранныхТаблиц = Новый Массив();
								СтрокаВыбраннойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(ИмяТаблицы), "НИмя");
								МассивВыбранныхТаблиц.Добавить(СтрокаВыбраннойТаблицы);
							КонецЕсли; 
							Для Каждого ВыбраннаяТаблица Из МассивВыбранныхТаблиц Цикл
								ВыбраннаяТаблица.ВсеПоля = Истина;
								ДобавитьВсеПоляТаблицыВВыбранныеПоля(ВыбраннаяТаблица.Имя, ЗапросПакета, ЧастьОбъединения,
									-(ЧастьОбъединения.ВыбранныеПоля.Количество() - Индекс - 1));
							КонецЦикла;
						Иначе
							Если Не ЗначениеЗаполнено(ВыбранноеПоле.Имя) Тогда
								ВыбранноеПоле.Имя = ПолучитьАвтоПсевдонимПоля(ВыбранноеПоле, ЧастьОбъединения);
							КонецЕсли; 
						КонецЕсли; 
					Иначе
						ВыбранноеПоле.Имя = ПерваяЧасть.ВыбранныеПоля[Индекс].Имя;
					КонецЕсли;
					Если Истина
						И ЕстьАгрегаты
						И ЧастьОбъединения.Автогруппировки 
					Тогда
						Группировка = ЧастьОбъединения.Группировки.Найти(ВыбранноеПоле.Определение, "Определение"); // Регистр!
						Если Ложь
							Или (Истина
								И ВыбранноеПоле.ЕстьАгрегаты 
								И Группировка <> Неопределено)
							Или (Истина
								И Не ВыбранноеПоле.ЕстьАгрегаты 
								И Группировка = Неопределено)
						Тогда
							ЧастьОбъединения.Автогруппировки = Ложь;
						КонецЕсли; 
					КонецЕсли; 
					Индекс = Индекс + 1;
				КонецЦикла;
			КонецЦикла;
			ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
			ОбновитьНаименованиеЗапроса(ЗапросПакета);
		КонецЕсли; 
	КонецЦикла;
	Возврат Неопределено;

КонецФункции

Функция ДобавитьВсеПоляТаблицыВВыбранныеПоля(ИмяТаблицы, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, СдвигИндексаПослеДобавления = 0,
	КонтролироватьУникальность = Ложь)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Если ПараметрыДиалектаSQL.МногоТаблиц Тогда
		ДоступноеПолеКомпоновщика = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.Элементы.Найти(ИмяТаблицы);
	Иначе
		ДоступноеПолеКомпоновщика = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора;
	КонецЕсли; 
	Если ДоступноеПолеКомпоновщика <> Неопределено Тогда
		ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(ДоступноеПолеКомпоновщика, Истина, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления,
			КонтролироватьУникальность);
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

Функция ПолучитьКомментарийИзТокенов(Токен1, Токен2 = Неопределено)
	
	Массив = Новый Массив();
	Если Токен1 <> Неопределено Тогда
		Массив.Добавить(Токен1);
	КонецЕсли; 
	Если Токен2 <> Неопределено Тогда
		Массив.Добавить(Токен2);
	КонецЕсли; 
	ТекстКомментария = "";
	МаркерКомментария = "//";
	Для Каждого Токен Из Массив Цикл
		ТекстТокена = ПолучитьТекстИзТокена(Токен);
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.УстановитьТекст(ТекстТокена);
		Для Счетчик = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
			СтрокаТекста = ТекстовыйДокумент.ПолучитьСтроку(Счетчик);
			Если ПустаяСтрока(СтрокаТекста) Тогда
				Продолжить;
			КонецЕсли; 
			СтрокаТекста = Сред(СтрокаТекста, Найти(СтрокаТекста, МаркерКомментария) + СтрДлина(МаркерКомментария));
			Если ТекстКомментария <> "" Тогда
				ТекстКомментария = ТекстКомментария + Символы.ПС;
			КонецЕсли; 
			ТекстКомментария = ТекстКомментария + СтрокаТекста;
		КонецЦикла;
	КонецЦикла;
	Возврат ТекстКомментария;
	
КонецФункции

//
// Индикатор - Неопределено - автоиндикатор, можно передать Null для блокировки автосоздания индикатора
Функция ЗаполнитьПоТокену(Знач Токен, Стек = Неопределено, Знач ЗапросПакета = Неопределено, Знач ЧастьОбъединения = Неопределено, Индикатор = Неопределено) Экспорт
	
	Данные = Токен.Data;
	Если Данные = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Стек = Неопределено Тогда
		Стек = Новый Массив();
	КонецЕсли;
	Если Индикатор = Неопределено Тогда
		ИндикаторБылСоздан = Истина;
		Индикатор = ЛксПолучитьИндикаторПроцесса(, "Структура запроса");
	КонецЕсли;
	Если Индикатор <> Null Тогда
		ЛксОбработатьИндикатор(Индикатор);
	КонецЕсли; 
	Результат = Неопределено;
	ИмяПравила = Данные.ParentRule.RuleNonterminal.Text;
	Стек.Вставить(0, ИмяПравила);
	КоличествоДочерних = Данные.TokenCount;
	Если ИмяПравила = "<EmbededQuery>" Тогда
		ЗапросыВложенногоПакета = ЗапросыПакета.СкопироватьКолонки();
		ВложенныйЗапрос = ДобавитьЗапросПакета(ЗапросыВложенногоПакета);
		ТекущийУзел = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
		//Если ТекущийУзел.Параметры <> Неопределено Тогда
		//	ВызватьИсключение "Неверный тип выбранной таблицы для вложенного запроса";
		//КонецЕсли; 
		ТекущийУзел.ВложенныйПакет = ЗапросыВложенногоПакета;
		ЗаполнитьПоТокену(Токен.Data.Tokens(1),,ВложенныйЗапрос,, Индикатор);
	ИначеЕсли ИмяПравила = "<Join>" Тогда
		ТекущийУзел = ЧастьОбъединения.СвязиТаблиц.Вставить(0);
		ТипСоединения = Данные.Tokens(1).Data; //"<JoinType>"
		Если ТипСоединения.TokenCount > 0 Тогда
			ТипСоединения = ТипСоединения.Tokens(0).Name;
		Иначе
			ТипСоединения = Неопределено;
		КонецЕсли; 
		Если Ложь
			Или ТипСоединения = "LEFT"
			Или ТипСоединения = "LEFT OUTER"
		Тогда
			ТекущийУзел.ВсеСтрокиЛевой = Истина;
		ИначеЕсли Ложь
			Или ТипСоединения = "RIGHT"
			Или ТипСоединения = "RIGHT OUTER"
		Тогда
			ТекущийУзел.ВсеСтрокиПравой = Истина;
		ИначеЕсли Ложь
			Или ТипСоединения = "OUTER"
			Или ТипСоединения = "FULL"
		Тогда
			ТекущийУзел.ВсеСтрокиЛевой = Истина;
			ТекущийУзел.ВсеСтрокиПравой = Истина;
		КонецЕсли;
		НастройкиКомпоновки = Новый НастройкиКомпоновкиДанных;
		ТокенУсловия = Данные.Tokens(5);
		ПостроитьДеревоЛогическогоВыражения(НастройкиКомпоновки.Отбор, ТокенУсловия, ЗапросПакета, ЧастьОбъединения);
		ТекущийУзел.Условие = НастройкиКомпоновки;
		ТекущийУзел.ЛеваяТаблица = ЗаполнитьПоТокену(Данные.Tokens(0).Data.Tokens(0), Стек, ЗапросПакета, ЧастьОбъединения, Индикатор); //<TableOrJoing>.<TableWithName>
		ТекущийУзел.ПраваяТаблица = ЗаполнитьПоТокену(Данные.Tokens(3).Data.Tokens(0), Стек, ЗапросПакета, ЧастьОбъединения, Индикатор); //<TableOrJoing>.<TableWithName>
		//ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущийУзел, "ЛеваяТаблица");
		//ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущийУзел, "ПраваяТаблица");
		Результат = ТекущийУзел.ПраваяТаблица;
	ИначеЕсли ИмяПравила = "<Param>" Тогда
		ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
		ТекущийУзел = ВыбраннаяТаблица.Параметры.Добавить();
		ТекущийУзел.Номер = ВыбраннаяТаблица.Параметры.Количество();
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(Токен,, ЗапросПакета, ЧастьОбъединения);
		ТекущийУзел.Токен = Токен;
	ИначеЕсли ИмяПравила = "<Allowed>" Тогда
		ЗапросПакета.ОпцияРазрешенные = Истина;
	ИначеЕсли ИмяПравила = "<AutoOrder>" Тогда
		Если ПолучитьТекстИзТокена(Токен) <> "" Тогда
			ЗапросПакета.ОпцияАвтоупорядочивание = Истина;
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<Distinct>" Тогда
		ЧастьОбъединения.ОпцияРазличные = Истина;
	ИначеЕсли ИмяПравила = "<Top>" Тогда
		ЗапросПакета.ОпцияПервые = Истина;
		ЗапросПакета.ПервыеКоличество = Число(Данные.Tokens(1).Data);
	ИначеЕсли ИмяПравила = "<MultiField>" Тогда
		ТекущийУзел = ЧастьОбъединения.ВыбранныеПоля[ЧастьОбъединения.ВыбранныеПоля.Количество() - 1];
		ТекущийУзел.Определение = ПолучитьТекстИзТокена(Токен);
		// Теперь уже можно сразу заполнить всеми нужными полями, а не в ОбработатьПакетПослеУстановкиДанных
	ИначеЕсли ИмяПравила = "<Where>" Тогда
		ПостроитьДеревоЛогическогоВыражения(ЧастьОбъединения.Условие.Отбор, Данные.Tokens(2), ЗапросПакета, ЧастьОбъединения);
		ЧастьОбъединения.КомментарийОтбора = ЧастьОбъединения.КомментарийОтбора + ПолучитьКомментарийИзТокенов(Данные.Tokens(1), Данные.Tokens(Данные.TokenCount - 1));
	ИначеЕсли ИмяПравила = "<Having>" Тогда
		ПостроитьДеревоЛогическогоВыражения(ЧастьОбъединения.Условие.Отбор, Данные.Tokens(2), ЗапросПакета, ЧастьОбъединения);
		ЧастьОбъединения.КомментарийОтбора = ЧастьОбъединения.КомментарийОтбора + ПолучитьКомментарийИзТокенов(Данные.Tokens(1), Данные.Tokens(Данные.TokenCount - 1));
	ИначеЕсли ИмяПравила = "<SelectExpr>" Тогда
		ТекущийУзел = ЧастьОбъединения.ВыбранныеПоля.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(1);
		ТекущийУзел.ИД = Новый УникальныйИдентификатор();
		ЕстьАгрегаты = Ложь;
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,, ЕстьАгрегаты);
		ТекущийУзел.ЕстьАгрегаты = ЕстьАгрегаты;
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		ТекущийУзел.АгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(ТекущийУзел.Токен);
		ТекущийУзел.ТипЗначения = ПолучитьТипЗначенияВыражения(ТекущийУзел.Токен, ЧастьОбъединения);
		Если КоличествоДочерних = 4 Тогда
			ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, Данные.Tokens(2));
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<GroupExpr>" Тогда
		ТекущийУзел = ЧастьОбъединения.Группировки.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(1);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения);
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
	ИначеЕсли ИмяПравила = "<TotalsExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ГруппирующиеПоляИтогов.Добавить();
		ДанныеHierExpr = Данные.Tokens(1).Data;
		ТекущийУзел.Токен = ДанныеHierExpr.Tokens(0);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ,,,, Ложь);
		ДанныеHierMode = ДанныеHierExpr.Tokens(1).Data;
		Если ДанныеHierMode.TokenCount = 0 Тогда
			ТипИтогов = "Элементы";
		Иначе
			ПервыйТокен = ДанныеHierMode.Tokens(0);
			Если Истина
				И ПервыйТокен.Kind = 0 
			Тогда 
				ТипИтогов = "ЭлементыИИерархия";
			ИначеЕсли Истина
				И ПервыйТокен.Kind = 1 
				И ПервыйТокен.Name = "ONLY"
			Тогда 
				ТипИтогов = "Иерархия";
			//ИначеЕсли Истина
			//	И ПервыйТокен.Kind = 1 
			//	И ПервыйТокен.Name = "PERIODS"
			//Тогда 
			//	ТипИтогов = "Периодами";
			КонецЕсли; 
		КонецЕсли; 
		ТекущийУзел.ТипИтогов = ТипИтогов;
		Если КоличествоДочерних = 2 Тогда
			ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, Данные.Tokens(1));
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<OrderExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ПоляПорядка.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(1).Data.Tokens(0);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		Если Данные.TokenCount = 4 Тогда
			ИмяНаправления = Данные.Tokens(Данные.TokenCount - 2).Name;
			Если ИмяНаправления = "ASC" Тогда
				ТекущийУзел.Направление = НаправлениеСортировки.Возр;
			Иначе
				ТекущийУзел.Направление = НаправлениеСортировки.Убыв;
			КонецЕсли; 
		КонецЕсли; 
		// Здесь еще учет иерархии не сделан <HierarchyOn>
	ИначеЕсли ИмяПравила = "<NamedExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ГруппируемыеПоляИтогов.Добавить();
		ТекущийУзел.Токен = Данные.Tokens(1);
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(ТекущийУзел.Токен,, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		Если КоличествоДочерних = 4 Тогда
			ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, Данные.Tokens(2));
		КонецЕсли; 
	ИначеЕсли ИмяПравила = "<IndexExpr>" Тогда
		ТекущийУзел = ЗапросПакета.ПоляИндекса.Добавить();
		ТекущийУзел.Определение = СобратьВыражениеЗапроса(Данные.Tokens(1),, ЗапросПакета, ЧастьОбъединения,,,, Ложь);
		ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		//ТекущийУзел.Токен = Токен;
	ИначеЕсли Истина
		И ИмяПравила = "<TablePseudoname>" 
		И (Ложь
			Или Стек[1] = "<TableWithName>"
			Или Стек[1] = "<FromUnion>")
	Тогда
		ТокенПсевдонима = Данные.Tokens(Данные.TokenCount - 1);
		Если ТокенПсевдонима = Неопределено Тогда
			ТекстОпределения = "";
		Иначе
			ТекстОпределения = СобратьВыражениеЗапроса(ТокенПсевдонима,, ЗапросПакета, ЧастьОбъединения);
		КонецЕсли; 
		ТекущийУзел = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
		ТекущийУзел.Имя = ТекстОпределения;
		ТекущийУзел.Имя = ПолучитьИмяБезКвадратныхСкобок(ТекущийУзел.Имя);
		ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущийУзел);
		Результат = ТекущийУзел.Имя;
	ИначеЕсли Ложь
		Или ИмяПравила = "<CreateQuery>"
		Или ИмяПравила = "<SelectQuery>"
		Или ИмяПравила = "<Query>"
	Тогда
		ЧастьОбъединения.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0));
		Если ИмяПравила = "<CreateQuery>" Тогда  // FromTables
			ИндексТокенаВыбранныхТаблиц = 5;
		Иначе
			ИндексТокенаВыбранныхТаблиц = 4;
		КонецЕсли; 
		ЗаполнитьПоТокену(Данные.Tokens(ИндексТокенаВыбранныхТаблиц), Стек, ЗапросПакета, ЧастьОбъединения, Индикатор);
		ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединения);
		Для ИндексТокена = 1 По КоличествоДочерних - 1 Цикл
			Если ИндексТокена = ИндексТокенаВыбранныхТаблиц Тогда
				Продолжить;
			КонецЕсли; 
			ТокенВниз = Данные.Tokens(ИндексТокена);
			Если ТокенВниз.Kind = 0 Тогда
				ЗаполнитьПоТокену(ТокенВниз, Стек, ЗапросПакета, ЧастьОбъединения, Индикатор);
			КонецЕсли;
		КонецЦикла;
	Иначе
		Если Ложь
			Или ИмяПравила = "<SelectRoot>"
			Или ИмяПравила = "<CreateRoot>"
			Или ИмяПравила = "<SimpleRoot>"
			Или ИмяПравила = "<DropRoot>"
		Тогда
			ОбновитьДоступныеВременныеТаблицы();
			ЗапросПакета = ДобавитьЗапросПакета();
			Если ИмяПравила = "<DropRoot>" Тогда
				ЗапросПакета.ТипЗапроса = 2;
				ЗапросПакета.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0));
				ЗапросПакета.ИмяВременнойТаблицы = ПолучитьТекстИзТокена(Данные.Tokens(3));
			ИначеЕсли ИмяПравила = "<CreateRoot>" Тогда
				ЗапросПакета.ТипЗапроса = 1;
			КонецЕсли; 
		ИначеЕсли Истина
			И ИмяПравила = "<TableWithName>"
			И КоличествоДочерних > 1
		Тогда
			ТекущийУзел = ДобавитьВыбраннуюТаблицу(ЧастьОбъединения);
			ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		ИначеЕсли Истина
			И ИмяПравила = "<TableWithName>" 
			И КоличествоДочерних > 1
		Тогда
			ТекущийУзел = ДобавитьВыбраннуюТаблицу(ЧастьОбъединения);
			ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		ИначеЕсли Истина
			И ИмяПравила = "<FromUnion>" 
			//И КоличествоДочерних > 1
		Тогда
			ТекущийУзел = ДобавитьВыбраннуюТаблицу(ЧастьОбъединения);
			ТекущийУзел.Комментарий = ПолучитьКомментарийИзТокенов(Данные.Tokens(0), Данные.Tokens(Данные.TokenCount - 1));
		ИначеЕсли Ложь
			Или ИмяПравила = "<SelectUnion>"
			Или ИмяПравила = "<CreateUnion>"
			Или ИмяПравила = "<SimpleUnion>"
		Тогда
			ЧастьОбъединения = ДобавитьЧастьОбъединения(ЗапросПакета);
		ИначеЕсли Ложь
			Или ИмяПравила = "<UnionPart>"
		Тогда
			ЧастьОбъединения = ДобавитьЧастьОбъединения(ЗапросПакета);
			ЧастьОбъединения.БезДублей = Данные.Tokens(1).Data.TokenCount = 0;
		ИначеЕсли Истина
			И ИмяПравила = "<Table>" 
			И Стек[1] = "<TableWithName>"
		Тогда
			ТекстОпределенияТаблицы = СобратьВыражениеЗапроса(Данные.Tokens(0),, ЗапросПакета, ЧастьОбъединения);
			ТекущийУзел = ЧастьОбъединения.ВыбранныеТаблицы[ЧастьОбъединения.ВыбранныеТаблицы.Количество() - 1];
			Фрагменты = ЛксПолучитьМассивИзСтрокиСРазделителем(ТекстОпределенияТаблицы);
			ПолноеИмя = "";
			Для Каждого Фрагмент Из Фрагменты Цикл
				Если ПолноеИмя <> "" Тогда
					ПолноеИмя = ПолноеИмя + ".";
				КонецЕсли; 
				ПолноеИмя = ПолноеИмя + ПолучитьИмяБезКвадратныхСкобок(Фрагмент);
			КонецЦикла;
			ТекущийУзел.ПолноеИмя = ЛксПолучитьПервыйФрагмент(ПолноеИмя, "(");
			//Перейти ~Выход; // Еще параметры виртуальной таблицы надо разбирать
		ИначеЕсли ИмяПравила = "<Into>" Тогда
			//ЗапросПакета.ТипЗапроса = 1;
			ЗапросПакета.ИмяВременнойТаблицы = ПолучитьТекстИзТокена(Данные.Tokens(2));
			ОбновитьНаименованиеЗапроса(ЗапросПакета);
		КонецЕсли;
		Для ИндексТокена = 0 По КоличествоДочерних - 1 Цикл
			ТокенВниз = Данные.Tokens(ИндексТокена);
			Если ТокенВниз.Kind = 0 Тогда
				// Не терминальный токен
				ПсевдонимСнизу = ЗаполнитьПоТокену(ТокенВниз, Стек, ЗапросПакета, ЧастьОбъединения, Индикатор);
				Если ПсевдонимСнизу <> Неопределено Тогда 
					Если Ложь
						Или ИмяПравила = "<FromUnion>" 
						Или ИмяПравила = "<JoinSide>" 
						Или ИмяПравила = "<TableWithName>" 
						Или ИмяПравила = "<TablePseudoname>" 
					Тогда 
						Результат = ПсевдонимСнизу;
					КонецЕсли; 
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли; 
	Стек.Удалить(0);
	Если ИндикаторБылСоздан = Истина Тогда
		ЛксОсвободитьИндикаторПроцесса(Индикатор);
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура ЗаполнитьПсевдонимПоляИзТокена(ТекущийУзел, Токен)

	Данные = Токен.Data;
	ТекстИмени = ПолучитьТекстИзТокена(Данные.Tokens(Данные.TokenCount - 1));
	ТекущийУзел.Имя = ТекстИмени;
	ТекущийУзел.Имя = ПолучитьИмяБезКвадратныхСкобок(ТекущийУзел.Имя);
	ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущийУзел);

КонецПроцедуры

Функция ПроверитьДобавитьПараметр(выхИмяПараметра, ТипЗначения = Неопределено)

	ТекущийУзел = Параметры.Найти(НРег(выхИмяПараметра), "НИмя");
	Если ТекущийУзел = Неопределено Тогда
		ТекущийУзел = Параметры.Добавить();
		Если Не ЗначениеЗаполнено(выхИмяПараметра) Тогда
			выхИмяПараметра = ПолучитьСловоЯзыкаЗапросов("Parameter") + XMLСтрока(Параметры.Количество());
		КонецЕсли; 
		ТекущийУзел.Имя = выхИмяПараметра;
		ТекущийУзел.ТипЗначения = ТипЗначения;
		ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущийУзел);
	КонецЕсли; 
	ТекущийУзел.ЧислоОбращений = ТекущийУзел.ЧислоОбращений + 1;
	Возврат Неопределено;

КонецФункции

// Попытка оптимизации пересборки большого числа выражений
Функция ЛиВыражениеЯвляетсяПолем(ВыражениеЗапроса) Экспорт
	
	ВычислительРегулярныхВыражений = мПлатформа.RegExp;
	ФрагментШаблона = "[" + мПлатформа.шБуква + "][" + мПлатформа.шБуква + "\d]*|\[[^\]]+\]";
	ВычислительРегулярныхВыражений.Pattern = "^(?:" + ФрагментШаблона + "(?:\." + ФрагментШаблона + ")*)$";
	Результат = ВычислительРегулярныхВыражений.Test(ВыражениеЗапроса);
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПредставлениеЗначенияНаЯзыке(Знач Значение) Экспорт
	
	Если ТипЗнч(Значение) = Тип("ПолеКомпоновкиДанных") Тогда
		Результат = "" + Значение;
		ПолеПараметра = Результат;
		МассивСинонимов = Новый Массив();
		МассивСинонимов.Добавить("DataParameters");
		МассивСинонимов.Добавить("ПараметрыДанных");
		Для Каждого Синоним Из МассивСинонимов Цикл
			Если Найти(НРег(ПолеПараметра), НРег(Синоним + ".")) = 1 Тогда
				Результат = ПараметрыДиалектаSQL.ПрефиксПараметра;
				Если ПараметрыДиалектаSQL.ИменованныеПараметры Тогда
					Результат = Результат + Сред(ПолеПараметра, СтрДлина(Синоним + ".") + 1);
				КонецЕсли; 
				Прервать;
			КонецЕсли; 
		КонецЦикла;
		Если Не ЗначениеЗаполнено(Результат) Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("UNDEFINED");
		КонецЕсли; 
	ИначеЕсли ТипЗнч(Значение) = Тип("Неопределено") Тогда
		Результат = ПолучитьСловоЯзыкаЗапросов("UNDEFINED");
	ИначеЕсли ТипЗнч(Значение) = Тип("ВидСравненияКомпоновкиДанных") Тогда
		Если Значение = ВидСравненияКомпоновкиДанных.Содержит Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("LIKE");
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеСодержит Тогда
			Результат1 = ПолучитьСловоЯзыкаЗапросов("NOT");
			Результат2 = ПолучитьСловоЯзыкаЗапросов("LIKE");
			Результат = Результат1 + " " + Результат2;
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеЗаполнено Тогда
			Результат1 = ПолучитьСловоЯзыкаЗапросов("IS");
			Результат2 = ПолучитьСловоЯзыкаЗапросов("NULL");
			Результат = Результат1 + " " + Результат2;
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.Заполнено Тогда
			Результат1 = ПолучитьСловоЯзыкаЗапросов("IS");
			Результат2 = ПолучитьСловоЯзыкаЗапросов("NOT");
			Результат3 = ПолучитьСловоЯзыкаЗапросов("NULL");
			Результат = Результат1 + " " + Результат2 + " " + Результат3;
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.Равно Тогда
			Результат = "=";
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеРавно Тогда
			Результат = "<>";
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.Больше Тогда
			Результат = ">";
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.БольшеИлиРавно Тогда
			Результат = ">=";
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.Меньше Тогда
			Результат = "<";
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно Тогда
			Результат = "<=";
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.ВИерархии Тогда
			Результат1 = ПолучитьСловоЯзыкаЗапросов("IN");
			Результат2 = ПолучитьСловоЯзыкаЗапросов("HIERARCHY");
			Результат = Результат1 + " " + Результат2;
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеВИерархии Тогда
			Результат1 = ПолучитьСловоЯзыкаЗапросов("NOT");
			Результат2 = ПолучитьСловоЯзыкаЗапросов("IN");
			Результат3 = ПолучитьСловоЯзыкаЗапросов("HIERARCHY");
			Результат = Результат1 + " " + Результат2 + " " + Результат3;
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.ВСписке Тогда
			Результат = ПолучитьСловоЯзыкаЗапросов("IN");
		ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеВСписке Тогда
			Результат1 = ПолучитьСловоЯзыкаЗапросов("NOT");
			Результат2 = ПолучитьСловоЯзыкаЗапросов("IN");
			Результат = Результат1 + " " + Результат2;
		Иначе
			ВызватьИсключение "Вид сравнения " + Значение + " компоновки не поддерживается";
		КонецЕсли; 
	Иначе
		Если ТипЗнч(Значение) = Тип("СтандартнаяДатаНачала") Тогда
			Значение = Значение.Дата;
		КонецЕсли; 
		Если ТипЗнч(Значение) = Тип("Дата") Тогда
			Если ирНеглобальный.СтрокиРавныЛкс(ДиалектSQL, "1С") Тогда
				Результат = "ДатаВремя(" + Формат(Значение, "ДФ='yyyy,MM,dd,  HH,mm,ss'; ДП=") + ")";
			ИначеЕсли ирНеглобальный.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
				Значение = Значение - СмещениеСтандартногоВремени();
				Результат = "'" + Формат(Значение, "ДФ='yyyyMMdd HH:mm:ss'; ДП=") + "'";
			Иначе// Если ирНеглобальный.СтрокиРавныЛкс(КодЯзыка, "WQL") Тогда
				Результат = "'" + Формат(Значение, "ДФ='yyyyMMdd HH:mm:ss'; ДП=") + "'";
			КонецЕсли; 
		ИначеЕсли ТипЗнч(Значение) = Тип("Число") Тогда
			Результат = XMLСтрока(Значение);
		ИначеЕсли ТипЗнч(Значение) = Тип("Булево") Тогда
			Если Значение Тогда
				Результат = ПолучитьСловоЯзыкаЗапросов("TRUE");
			Иначе
				Результат = ПолучитьСловоЯзыкаЗапросов("FALSE");
			КонецЕсли; 
		ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда
			Если ирНеглобальный.СтрокиРавныЛкс(ДиалектSQL, "1С") Тогда
				Результат = """" + СтрЗаменить(Значение, """", """""") + """";
			Иначе
				Результат = "'" + Значение + "'";
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ПолучитьПолноеИмяПоляВВыражении(ИмяПоля, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, СтароеИмяТаблицы = "",
	НовоеИмяТаблицы = "", РазрешитьНормализациюИмен = Истина) Экспорт

	Результат = ИмяПоля;
	Если Истина
		И ПараметрыДиалектаSQL.МногоТаблиц
		И ЧастьОбъединения <> Неопределено 
	Тогда // Пока не проверяем другие выражения
		ПозицияТочки = Найти(Результат, ".");
		Если Истина
			И РазрешитьНормализациюИмен
			И ПозицияТочки = 0 
		Тогда
			//ОбновитьДоступныеВременныеТаблицы(); // Неоптимально?
			Для Каждого ГруппаПолей Из ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.Элементы Цикл
				ДоступноеПоле = ГруппаПолей.Элементы.Найти("" + ГруппаПолей.Поле + "." + Результат);
				Если ДоступноеПоле <> Неопределено Тогда
					Результат = "" + ДоступноеПоле.Поле;
					// Правильно было бы проверить и другие таблицы для исключения неоднозначности привязки поля к таблице
					Прервать;
				КонецЕсли; 
			КонецЦикла;
		ИначеЕсли ЗначениеЗаполнено(СтароеИмяТаблицы) Тогда
			ИмяТаблицыПоля = Лев(Результат, ПозицияТочки - 1);
			Если ирНеглобальный.СтрокиРавныЛкс(ИмяТаблицыПоля, СтароеИмяТаблицы) Тогда
				Результат = НовоеИмяТаблицы + "." + Сред(Результат, ПозицияТочки + 1);
			КонецЕсли; 
		КонецЕсли; 
		Если РасширеннаяПроверка Тогда
			ПолеКомпоновки = Новый ПолеКомпоновкиДанных(Результат);
			ДоступноеПоле = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.НайтиПоле(ПолеКомпоновки);
			Если ДоступноеПоле = Неопределено Тогда
				ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока = ЗапросПакета;
				ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока = ЧастьОбъединения;
				ВызватьИсключение "Поле """ + ИмяПоля + """ не найдено";
			КонецЕсли;
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура ДобавитьПробелПослеТокена(Текст, ИмяПредыдущегоТокенаВниз)

	Если Истина // После них не ставим пробел
		И ИмяПредыдущегоТокенаВниз <> "."
		И ИмяПредыдущегоТокенаВниз <> "("
		И ИмяПредыдущегоТокенаВниз <> "&"
		И ИмяПредыдущегоТокенаВниз <> "?"
		И ИмяПредыдущегоТокенаВниз <> "@"
	Тогда
		Текст = Текст + " ";
	КонецЕсли; 

КонецПроцедуры

Функция ПолучитьСловоЯзыкаЗапросов(Слово) Экспорт

	Результат = Неопределено;
	Если ирНеглобальный.СтрокиРавныЛкс("AS", Слово) Тогда
		Если Не ПараметрыДиалектаSQL.КАК Тогда
			Результат = "";
		КонецЕсли;
	КонецЕсли; 
	Если Результат = Неопределено Тогда
		Если Истина
			И ПараметрыДиалектаSQL.Это1С
			И Не Английский1С
		Тогда
			Результат = мТерминалыЯзыкаЗапросов[Слово];
		Иначе
			Результат = Слово;
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

// Параметры:
//   РазрешитьНормализациюИмен - Булево - делать ли преобразование коротких имен полей к длинным (с именем таблицы)
//
Функция СобратьВыражениеЗапроса(Токен, Отступ = 0, Знач ЗапросПакета = Неопределено, Знач ЧастьОбъединения = Неопределено,
	СтароеИмяТаблицы = "", НовоеИмяТаблицы = "", выхЕстьАгрегаты = Ложь, РазрешитьНормализациюИмен = Истина) Экспорт
	
	Данные = Токен.Data;
	Если Данные = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если Токен.Kind = 1 Тогда
		Возврат Данные;
	КонецЕсли; 
	ИмяПравила = Данные.ParentRule.RuleNonterminal.Text;
	Если ИмяПравила = "<Parameter>" Тогда
		//ИмяПараметра = Данные.Tokens(1).Data.Tokens(0).Data;
		ИмяПараметра = Сред(Данные.Tokens(0).Data, 2);
		ПроверитьДобавитьПараметр(ИмяПараметра);
	ИначеЕсли ИмяПравила = "<TableParameter>" Тогда
		//ИмяПараметра = Данные.Tokens(1).Data.Tokens(0).Data;
		ИмяПараметра = Сред(Данные.Tokens(0).Data, 2);
		ПроверитьДобавитьПараметр(ИмяПараметра, Новый ОписаниеТипов("ТаблицаЗначений"));
	ИначеЕсли ИмяПравила = "<Agregate>" Тогда
		выхЕстьАгрегаты = Истина;
	КонецЕсли; 
	ЧислоТокенов = Данные.TokenCount;
	Результат = "";
	ЛевыйОтступ = ЛксПолучитьСтрокуПовтором(Символы.Таб, Отступ);
	Если ИмяПравила = "<Case>" Тогда
		Результат = ПолучитьСловоЯзыкаЗапросов("CASE") + СобратьВыражениеЗапроса(Данные.Tokens(1), Отступ, ЗапросПакета, ЧастьОбъединения,,, выхЕстьАгрегаты, РазрешитьНормализациюИмен) + "
		|" + ЛевыйОтступ + "	" + СобратьВыражениеЗапроса(Данные.Tokens(2), Отступ + 1, ЗапросПакета, ЧастьОбъединения,,, выхЕстьАгрегаты, РазрешитьНормализациюИмен) + "
		|" + ЛевыйОтступ + ПолучитьСловоЯзыкаЗапросов("END");
	ИначеЕсли ИмяПравила = "<WhenThen>" Тогда
		Результат = "
		|" + ЛевыйОтступ + "	" + ПолучитьСловоЯзыкаЗапросов("WHEN") + " " + СобратьВыражениеЗапроса(Данные.Tokens(1), Отступ + 1, ЗапросПакета, ЧастьОбъединения,,, выхЕстьАгрегаты, РазрешитьНормализациюИмен) + "
		|" + ЛевыйОтступ + "		" + ПолучитьСловоЯзыкаЗапросов("THEN") + " " + СобратьВыражениеЗапроса(Данные.Tokens(3), Отступ + 1, ЗапросПакета, ЧастьОбъединения,,, выхЕстьАгрегаты, РазрешитьНормализациюИмен);
		Если ЧислоТокенов > 4 Тогда
			Результат = Результат + СобратьВыражениеЗапроса(Данные.Tokens(4), Отступ, ЗапросПакета, ЧастьОбъединения,,, выхЕстьАгрегаты, РазрешитьНормализациюИмен);
		КонецЕсли; 
	ИначеЕсли Ложь
		Или ИмяПравила = "<AndExpr>"
		Или ИмяПравила = "<OrExpr>"
	Тогда
		Результат = СобратьВыражениеЗапроса(Данные.Tokens(0), Отступ, ЗапросПакета, ЧастьОбъединения,,, выхЕстьАгрегаты, РазрешитьНормализациюИмен) + "
		|" + ЛевыйОтступ + "	" + Данные.Tokens(1).Data + " " + СобратьВыражениеЗапроса(Данные.Tokens(2), Отступ, ЗапросПакета, ЧастьОбъединения,,, выхЕстьАгрегаты, РазрешитьНормализациюИмен);
	ИначеЕсли ИмяПравила = "<EmbededQuery>" Тогда
		Пакет =  ЗапросыПакета.СкопироватьКолонки();
		ЗапросПакета = ДобавитьЗапросПакета(Пакет);
		ЗаполнитьПоТокену(Данные.Tokens(1), , ЗапросПакета, ЧастьОбъединения, Null);
		ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
		Результат = "(" + Символы.ПС + ЛевыйОтступ + Символы.Таб + СобратьТекстПакета(Пакет, Символы.Таб) + ")";
	Иначе
		ИмяПредыдущегоТокена = Неопределено;
		Для ИндексТокена = 0 По Данные.TokenCount - 1 Цикл
			ТокенВниз = Данные.Tokens(ИндексТокена);
			Если ТокенВниз.Kind = 0 Тогда
				Если Результат <> "" Тогда
					ДобавитьПробелПослеТокена(Результат, ИмяПредыдущегоТокена);
				КонецЕсли; 
				// Не терминальный токен
				РезультатСнизу = СобратьВыражениеЗапроса(ТокенВниз, Отступ, ЗапросПакета, ЧастьОбъединения,,, выхЕстьАгрегаты, РазрешитьНормализациюИмен);
				ИмяПредыдущегоТокена = Неопределено;
			Иначе
				ИмяТокена = ТокенВниз.Name;
				// Терминальный токен
				Если Ложь // Перед ними не ставим пробел
					Или ИмяТокена = ")"
					Или ИмяТокена = "]"
					Или ИмяТокена = ","
					Или ИмяТокена = "."
					Или (Истина
						И ИндексТокена = 1
						И ИмяТокена = "(")
				Тогда
					РезультатСнизу = ТокенВниз.Data;
				ИначеЕсли Ложь
					Или ИмяТокена = "id"
					Или ИмяТокена = "BadID"
					Или ИмяТокена = "strLiteral"
					Или ИмяТокена = "numLiteral" 
					Или ИмяТокена = "Parameter" 
					Или ИмяТокена = "MultiCommentLine"
					Или ИмяТокена = "COMP_OPERATOR"
					Или ИмяТокена = "("
					Или ИмяТокена = "["
					Или ИмяТокена = "&"
					Или ИмяТокена = "?"
					Или ИмяТокена = "@"
					Или ИмяТокена = "+"
					Или ИмяТокена = "-"
					Или ИмяТокена = "*"
					Или ИмяТокена = "/"
				Тогда
					Если Результат <> "" Тогда
						ДобавитьПробелПослеТокена(Результат, ИмяПредыдущегоТокена);
					КонецЕсли; 
					РезультатСнизу = ТокенВниз.Data;
				Иначе
					Если Ложь
						Или ИмяПравила = "<ID>"
						Или ИмяПравила = "<SmartAS>"
						Или ИмяПравила = "<TableAS>"
					Тогда
						РезультатСнизу = ТокенВниз.Data;
					Иначе
						Если Результат <> "" Тогда
							ДобавитьПробелПослеТокена(Результат, ИмяПредыдущегоТокена);
						КонецЕсли; 
						РезультатСнизу = ПолучитьСловоЯзыкаЗапросов(ИмяТокена);
					КонецЕсли; 
				КонецЕсли; 
				ИмяПредыдущегоТокена = ИмяТокена;
			КонецЕсли;
			Результат = Результат + РезультатСнизу;
		КонецЦикла;
	КонецЕсли;
	Если ИмяПравила = "<Field>" Тогда
		Результат = ПолучитьПолноеИмяПоляВВыражении(Результат, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы, РазрешитьНормализациюИмен);
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ПолучитьАгрегатнуюФункцию(Токен, выхТокенАргументаФункции = Неопределено) Экспорт
	
	Результат = Неопределено;
	Если ТипЗнч(Токен) <> Тип("COMОбъект") Тогда
		Возврат Результат;
	КонецЕсли; 
	Данные = Токен.Data;
	Если Данные = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	выхТокенАргументаФункции = Токен;
	Если Токен.Kind = 0 Тогда
		КоличествоТокенов = Данные.TokenCount;
		ИмяПравила = Данные.ParentRule.RuleNonterminal.Text;
		Если ИмяПравила = "<Brackets>" Тогда
			Результат = ПолучитьАгрегатнуюФункцию(Данные.Tokens(1), выхТокенАргументаФункции);
		ИначеЕсли ИмяПравила = "<Agregate>" Тогда
			ТокенВниз = Данные.Tokens(0);
			Если ТокенВниз.Kind = 1 Тогда
				Результат = ТокенВниз.Name + "(";
				выхТокенАргументаФункции = Данные.Tokens(2);
			Иначе
				Результат = ПолучитьАгрегатнуюФункцию(ТокенВниз, выхТокенАргументаФункции);
			КонецЕсли; 
		ИначеЕсли ИмяПравила = "<Count>" Тогда
			ТокенВниз = Данные.Tokens(КоличествоТокенов - 2);
			Если ТокенВниз.Kind = 0 Тогда
				Результат = "COUNT" + "(";
				Если КоличествоТокенов = 5 Тогда 
					Результат = Результат + " DISTINCT";
					выхТокенАргументаФункции = Данные.Tokens(3);
				Иначе
					выхТокенАргументаФункции = Данные.Tokens(2);
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли КоличествоТокенов = 1 Тогда
			Результат = ПолучитьАгрегатнуюФункцию(Данные.Tokens(0), выхТокенАргументаФункции);
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, Токен, Отступ = 0, ЧастьОбъединения = Неопределено)
	
	ЕстьАгрегаты = Ложь;
	Представление = СобратьВыражениеЗапроса(Токен, Отступ,,ЧастьОбъединения,,, ЕстьАгрегаты);
	Если ЕстьАгрегаты Тогда
		ЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("");
	Иначе
		ЭлементОтбора.ЛевоеЗначение = Неопределено;
	КонецЕсли; 
	ЭлементОтбора.ПравоеЗначение = Токен;
	ЭлементОтбора.Представление = Представление;
	
КонецПроцедуры

Функция ПолучитьВыражениеЭлементаОтбораЛкс(ЭлементОтбора, Знач Отступ = 0, Знач ГруппаИзОдногоЭлемента = Ложь, выхЕстьАгрегаты = Ложь) Экспорт

	Если ГруппаИзОдногоЭлемента Тогда
		Отступ = Макс(Отступ - 1, 0);
	КонецЕсли; 
	Смещение = ЛксПолучитьСтрокуПовтором(Символы.Таб, Отступ);
	Если ЗначениеЗаполнено(ЭлементОтбора.Представление) Тогда
		Представление = ЭлементОтбора.Представление;
		Если ЭлементОтбора.ПравоеЗначение = Неопределено Тогда
			Токен = РазобратьВыражениеЗапроса(Представление);
			ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, Токен,  Отступ);
		КонецЕсли; 
		ПредставлениеЭлемента = "";
		Если ЭлементОтбора.ЛевоеЗначение <> Неопределено Тогда
			выхЕстьАгрегаты = Истина;
		КонецЕсли;
		ирНеглобальный.ДобавитьМногострочнуюСтрокуВТекстЛкс(ПредставлениеЭлемента, Представление, Смещение);
		Если Истина
			И Не ЛиВыражениеЯвляетсяПолем(Представление)
			И Не ГруппаИзОдногоЭлемента 
		Тогда
			ПредставлениеЭлемента = "(" + ПредставлениеЭлемента + ")";
		КонецЕсли; 
	Иначе
		ПредставлениеЭлемента = ПолучитьПредставлениеЗначенияНаЯзыке(ЭлементОтбора.ЛевоеЗначение)
			+ " " + ПолучитьПредставлениеЗначенияНаЯзыке(ЭлементОтбора.ВидСравнения);
		Если Истина
			И ЭлементОтбора.ВидСравнения <> ВидСравненияКомпоновкиДанных.Заполнено
			И ЭлементОтбора.ВидСравнения <> ВидСравненияКомпоновкиДанных.НеЗаполнено
		Тогда
			ПравоеЗначение = ЭлементОтбора.ПравоеЗначение;
			Если ТипЗнч(ПравоеЗначение) <> Тип("ПолеКомпоновкиДанных") Тогда
				XMLТип = СериализаторXDTO.XMLТипЗнч(ПравоеЗначение);
				Если XMLТип <> Неопределено Тогда
					Если Истина
						И Найти(XMLТип.URIПространстваИмен, "http://v8.1c.ru/8.1/data") > 0
						И Не ирНеглобальный.СтрокиРавныЛкс(XMLТип.URIПространстваИмен, "StandardBeginningDate")
					Тогда
						СтрокаПараметра = Параметры.Найти(ПравоеЗначение, "Значение");
						Если СтрокаПараметра = Неопределено Тогда
							ИмяПараметра = ирНеглобальный.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Параметры, "" + ПравоеЗначение,,, ПолучитьСловоЯзыкаЗапросов("Parameter"));
							СтрокаПараметра = Параметры.Добавить();
							СтрокаПараметра.Имя = ИмяПараметра;
							СтрокаПараметра.Значение = ПравоеЗначение;
							ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПараметра);
						КонецЕсли; 
						МассивТипов = Новый Массив();
						МассивТипов.Добавить(ТипЗнч(ПравоеЗначение));
						СтрокаПараметра.ТипЗначения = Новый ОписаниеТипов(СтрокаПараметра.ТипЗначения, МассивТипов);
						СтрокаПараметра.ЧислоОбращений = СтрокаПараметра.ЧислоОбращений + 1;
						ПравоеЗначение = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + ИмяПараметра);
						ЭлементОтбора.ПравоеЗначение = ПравоеЗначение;
					КонецЕсли; 
				КонецЕсли; 
			КонецЕсли; 
			СтрокаПравогоЗначения = ПолучитьПредставлениеЗначенияНаЯзыке(ПравоеЗначение);
			Если Ложь
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Содержит 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеСодержит
			Тогда
				Если ТипЗнч(ПравоеЗначение) = Тип("Строка") Тогда
					СтрокаПравогоЗначения = ПолучитьПредставлениеЗначенияНаЯзыке("%" + ПравоеЗначение + "%");
				КонецЕсли; 
			ИначеЕсли Ложь
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВИерархии
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВИерархии 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке 
				Или ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеВСписке 
			Тогда
				СтрокаПравогоЗначения = "(" + СтрокаПравогоЗначения + ")";
			КонецЕсли;
			ПредставлениеЭлемента = ПредставлениеЭлемента + " " + СтрокаПравогоЗначения;
		КонецЕсли; 
	КонецЕсли; 
	Возврат ПредставлениеЭлемента;

КонецФункции

// Параметры:
//  ФильтрацияАгрегатов - 
//		0 - не фильтровать
// 		1 - собирать только элементы без агрегатов
//		2 - собирать только элементы с агрегатами
//
Функция ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ГруппаОтбора, Отступ = 0, ФильтрацияАгрегатов = 0, выхЕстьАгрегаты = Ложь) Экспорт 
	
	#Если _ Тогда
		_Н = Новый НастройкиКомпоновкиДанных;
	    ГруппаОтбора = _Н.Отбор;
	#КонецЕсли
	Если ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		ТипГруппы = ГруппаОтбора.ТипГруппы;
	Иначе
		ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
	КонецЕсли;
	Смещение = ЛксПолучитьСтрокуПовтором(Символы.Таб, Отступ);
	СтрокаНе = "NOT";
	ЗначениеXDTO = СериализаторXDTO.ЗаписатьXDTO(ТипГруппы);
	Если ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе Тогда
		ОператорГруппы = "AND";
	Иначе
		ОператорГруппы = ВРег(СтрЗаменить(ЗначениеXDTO.ЛексическоеЗначение, "Group", ""));
	КонецЕсли; 
	ОператорГруппы = ПолучитьСловоЯзыкаЗапросов(ОператорГруппы);
	СтрокаНе = ПолучитьСловоЯзыкаЗапросов(СтрокаНе);
	ТекстГруппы = "";
	ГруппаИзОдногоЭлемента = ГруппаОтбора.Элементы.Количество() = 1;
	выхЕстьАгрегаты = Ложь;
	Для Каждого ЭлементОтбора Из ГруппаОтбора.Элементы Цикл
		Если Не ЭлементОтбора.Использование Тогда
			Продолжить;
		КонецЕсли; 
		ПредставлениеЭлемента = "";
		ЕстьАгрегаты = Ложь;
		Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			ПредставлениеЭлемента = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЭлементОтбора, Отступ + 1, ФильтрацияАгрегатов, ЕстьАгрегаты);
			Если Истина
				И Не ГруппаИзОдногоЭлемента 
				И ЭлементОтбора.ТипГруппы <> ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе
			Тогда
				ПредставлениеЭлемента = "(" + ПредставлениеЭлемента + ")";
			КонецЕсли;
		Иначе
			ПредставлениеЭлемента = ПолучитьВыражениеЭлементаОтбораЛкс(ЭлементОтбора, Отступ + 1, ГруппаИзОдногоЭлемента, ЕстьАгрегаты);
		КонецЕсли; 
		Если Ложь
			Или ТипЗнч(ГруппаОтбора) <> Тип("ОтборКомпоновкиДанных")
			Или ФильтрацияАгрегатов = 0
			Или (Истина
				И ФильтрацияАгрегатов = 1 
				И Не ЕстьАгрегаты)
			Или (Истина
				И ФильтрацияАгрегатов = 2 
				И ЕстьАгрегаты)
		Тогда
			Если ТекстГруппы <> "" Тогда
				ТекстГруппы = ТекстГруппы + Символы.ПС + Смещение + ОператорГруппы + " ";
			КонецЕсли; 
			ТекстГруппы = ТекстГруппы + ПредставлениеЭлемента;
		КонецЕсли;
		выхЕстьАгрегаты = выхЕстьАгрегаты Или ЕстьАгрегаты;
	КонецЦикла;
	Если Истина
		И ТекстГруппы <> "" 
		И (Ложь
			Или Отступ > 0
			Или ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе)
	Тогда
		//ТекстГруппы = "(" + ТекстГруппы + ")";
		Если ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе Тогда
			ТекстГруппы = СтрокаНе + " (" + ТекстГруппы + ")";
		КонецЕсли;
	КонецЕсли;
	Возврат ТекстГруппы;
	
КонецФункции

Функция РазобратьВыражениеЗапроса(ВыражениеЗапроса) Экспорт
	
	ТекстДляРазбора = "ВЫБРАТЬ " + Символы.ПС + ВыражениеЗапроса + " КАК _";
	//НачальныйТокен = РазобратьТекстЗапроса(ТекстДляРазбора, Истина, Ложь); // Сокращенное дерево не даст общими методами строить вложенные запросы
	НачальныйТокен = РазобратьТекстЗапроса(ТекстДляРазбора, , Ложь);
	Если НачальныйТокен = Неопределено Тогда
		ВызватьИсключение "Ошибка синтаксического разбора выражения """ + ВыражениеЗапроса + """";
	КонецЕсли; 
	//НачальныйТокен = НачальныйТокен.Data.Tokens(0).Data.Tokens(3).Data.Tokens(1); // При сокращенном дереве
	НачальныйТокен = НачальныйТокен.Data.Tokens(0).Data.Tokens(0).Data.Tokens(0).Data.Tokens(0).Data.Tokens(3).Data.Tokens(0).Data.Tokens(1);
	Возврат НачальныйТокен;
	
КонецФункции

Функция ДобавитьЧастьОбъединения(ЗапросПакета)

	ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения.Добавить();
	ЧастьОбъединения.Номер = ЗапросПакета.ЧастиОбъединения.Количество();
	ЧастьОбъединения.ВыбранныеТаблицы = ВыбранныеТаблицы.СкопироватьКолонки();
	ЧастьОбъединения.ВыбранныеПоля = ВыбранныеПоля.СкопироватьКолонки();
	ЧастьОбъединения.СвязиТаблиц = СвязиТаблиц.СкопироватьКолонки();
	ЧастьОбъединения.Группировки = Группировки.СкопироватьКолонки();
	ЧастьОбъединения.ОпцияРазличные = Ложь;
	ЧастьОбъединения.Компоновщик = Новый КомпоновщикНастроекКомпоновкиДанных;
	ЧастьОбъединения.Условие = ЧастьОбъединения.Компоновщик.Настройки;
	ОбновитьНаименованиеЧасти(ЧастьОбъединения);
	Возврат ЧастьОбъединения;

КонецФункции

Функция ДобавитьЗапросПакета(Пакет = Неопределено, Позиция = Неопределено)

	Если Пакет = Неопределено Тогда
		Пакет = ЗапросыПакета;
	КонецЕсли; 
	Если Позиция = Неопределено Тогда
		ЗапросПакета = Пакет.Добавить();
	Иначе
		ЗапросПакета = Пакет.Вставить(Позиция);
	КонецЕсли; 
	ЗапросПакета.ИД = Новый УникальныйИдентификатор();
	ЗапросПакета.Номер = ЗапросыПакета.Количество();
	ЗапросПакета.ЧастиОбъединения = ЧастиОбъединения.СкопироватьКолонки();
	ЗапросПакета.ПоляОбъединения = ПоляОбъединения.СкопироватьКолонки();
	ЗапросПакета.ГруппирующиеПоляИтогов = ГруппирующиеПоляИтогов.СкопироватьКолонки();
	ЗапросПакета.ГруппируемыеПоляИтогов = ГруппируемыеПоляИтогов.СкопироватьКолонки();
	ЗапросПакета.ОпцияОбщиеИтоги = Ложь;
	ЗапросПакета.ОпцияПервые = Ложь;
	ЗапросПакета.ОпцияРазрешенные = Ложь;
	ЗапросПакета.ОпцияАвтоупорядочивание = Ложь;
	ЗапросПакета.ПервыеКоличество = 0;
	ЗапросПакета.ИмяВременнойТаблицы = "";
	ЗапросПакета.ПоляПорядка = ПоляПорядка.СкопироватьКолонки();
	ЗапросПакета.ПоляИндекса = ПоляИндекса.СкопироватьКолонки();
	ЗапросПакета.ТипЗапроса = 0;
	ОбновитьНаименованиеЗапроса(ЗапросПакета);
	Возврат ЗапросПакета;

КонецФункции

Функция ДобавитьВыбраннуюТаблицу(ЧастьОбъединения = Неопределено)
	
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Добавить();
	ВыбраннаяТаблица.Параметры = ПараметрыТаблицы.СкопироватьКолонки();
	Возврат ВыбраннаяТаблица;
	
КонецФункции

Функция ПолучитьИмяБезКвадратныхСкобок(Имя)
	
	Результат = Имя;
	Если Лев(Результат, 1) = "[" Тогда
		Результат = Сред(Результат, 2, СтрДлина(Результат) - 2);
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ОпуститьсяДоПервогоЗначимогоТокена(Токен)

	Если Токен.Kind = 0 Тогда
		Возврат Токен;
	КонецЕсли; 
	Данные = Токен.Data;
	ИмяПравила = Данные.ParentRule.RuleNonterminal.Text;
	Если ИмяПравила = "<Brackets>" Тогда
		ЗначимыйТокен = ОпуститьсяДоПервогоЗначимогоТокена(Данные.Tokens(1));
		Возврат ЗначимыйТокен;
	ИначеЕсли Данные.TokenCount > 1  Тогда
		Возврат Токен;
	Иначе
		ПервыйТокен = Данные.Tokens(0);
		Если ПервыйТокен.Kind <> 0 Тогда
			Возврат Токен;
		Иначе
			Возврат ОпуститьсяДоПервогоЗначимогоТокена(ПервыйТокен);
		КонецЕсли; 
	КонецЕсли;
	
КонецФункции

Процедура ПостроитьДеревоЛогическогоВыражения(ГруппаОтбора, Токен, ЗапросПакета, ЧастьОбъединения)

	#Если _ Тогда
	    ОтборКомпоновки1 = Новый НастройкиКомпоновкиДанных;
		ГруппаОтбора = ОтборКомпоновки1.Отбор;
	#КонецЕсли
	Если Токен = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если Токен.Kind = 1 Тогда
		Если Ложь
			Или Токен.Name = "TRUE"
			Или Токен.Name = "FALSE"
		Тогда
			ЭлементОтбора = ГруппаОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЭлементОтбора.Представление = ПолучитьСловоЯзыкаЗапросов(Токен.Name);
			ЭлементОтбора.ПравоеЗначение = ЭлементОтбора.Представление;
			Возврат;
		КонецЕсли; 
	КонецЕсли; 
	Данные = Токен.Data;
	Если Данные.TokenCount = 0 Тогда
		Возврат;
	ИначеЕсли Данные.TokenCount = 1 Тогда
		ПостроитьДеревоЛогическогоВыражения(ГруппаОтбора, Данные.Tokens(0), ЗапросПакета, ЧастьОбъединения);
	Иначе
		ИмяПравила = Данные.ParentRule.RuleNonterminal.Text;
		Если ИмяПравила = "<OrExpr>" Тогда
			Если Истина
				И ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
				И ГруппаОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли
			Тогда
				ГруппаИли = ГруппаОтбора;
			Иначе
				ГруппаИли = ГруппаОтбора.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
				ГруппаИли.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
			КонецЕсли; 
			ПостроитьДеревоЛогическогоВыражения(ГруппаИли, Данные.Tokens(0), ЗапросПакета, ЧастьОбъединения);
			ПостроитьДеревоЛогическогоВыражения(ГруппаИли, Данные.Tokens(2), ЗапросПакета, ЧастьОбъединения);
		ИначеЕсли ИмяПравила = "<AndExpr>" Тогда
			Если Истина
				И ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
				И ГруппаОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли
			Тогда
				ГруппаИ = ГруппаОтбора.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
				ГруппаИ.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
			Иначе
				ГруппаИ = ГруппаОтбора;
			КонецЕсли; 
			ПостроитьДеревоЛогическогоВыражения(ГруппаИ, Данные.Tokens(0), ЗапросПакета, ЧастьОбъединения);
			ПостроитьДеревоЛогическогоВыражения(ГруппаИ, Данные.Tokens(2), ЗапросПакета, ЧастьОбъединения);
		ИначеЕсли ИмяПравила = "<NotExpr>" Тогда
			ГруппаИ = ГруппаОтбора.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			ГруппаИ.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе;
			ПостроитьДеревоЛогическогоВыражения(ГруппаИ, Данные.Tokens(1), ЗапросПакета, ЧастьОбъединения)
		ИначеЕсли Ложь
			Или ИмяПравила = "<CheckNULL>"
			Или ИмяПравила = "<CheckNotNULL>"
			Или ИмяПравила = "<CheckHierarchy>"
			Или ИмяПравила = "<CompareExpr>"
			Или ИмяПравила = "<CheckLIKE>"
			//Или ИмяПравила = "<CheckExpr>"
		Тогда
			ЭлементОтбора = ГруппаОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЛевоеЗначение = ПолучитьТерминОтбораКомпоновкиИзДанныхТокена(Данные.Tokens(0), ЗапросПакета, ЧастьОбъединения);
			ЭлементОтбора.ЛевоеЗначение = ЛевоеЗначение;
			Если ЛевоеЗначение = Неопределено Тогда
				ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, Токен, , ЧастьОбъединения);
			ИначеЕсли ИмяПравила = "<CheckNULL>" Тогда
				ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
			ИначеЕсли ИмяПравила = "<CheckNotNULL>" Тогда
				ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
			Иначе
				Если ИмяПравила = "<CheckHierarchy>" Тогда
					ПравыйТокен = Данные.Tokens(4);
				//ИначеЕсли ИмяПравила = "<CompareExpr>" Тогда
				//	ПравыйТокен = Данные.Tokens(2);
				//ИначеЕсли ИмяПравила = "<CheckExpr>" Тогда
				//	ПравыйТокен = Данные.Tokens(3);
				Иначе
					ПравыйТокен = Данные.Tokens(2);
				КонецЕсли; 
				ПравоеЗначение = ПолучитьТерминОтбораКомпоновкиИзДанныхТокена(ПравыйТокен, ЗапросПакета, ЧастьОбъединения);
				ЭлементОтбора.ПравоеЗначение = ПравоеЗначение;
				Если ПравоеЗначение = Неопределено Тогда
					ЗаполнитьЭлементОтбораПроизвольногоВыражения(ЭлементОтбора, Токен, , ЧастьОбъединения);
				ИначеЕсли ИмяПравила = "<CompareExpr>" Тогда
					ОператорСравнения = Данные.Tokens(1).Data;
					Если ОператорСравнения = "=" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
					ИначеЕсли ОператорСравнения = "<>" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.НеРавно;
					ИначеЕсли ОператорСравнения = ">" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.Больше;
					ИначеЕсли ОператорСравнения = "<" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.Меньше;
					ИначеЕсли ОператорСравнения = "<=" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно;
					ИначеЕсли ОператорСравнения = ">=" Тогда
						лВидСравнения = ВидСравненияКомпоновкиДанных.БольшеИлиРавно;
					Иначе
						ВызватьИсключение "Неизвестный вид сравнения """ + ОператорСравнения + """";
					КонецЕсли; 
					ЭлементОтбора.ВидСравнения = лВидСравнения;
				ИначеЕсли ИмяПравила = "<CheckLIKE>" Тогда
					ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Содержит;
				ИначеЕсли ИмяПравила = "<CheckHierarchy>" Тогда
					ЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.ВИерархии;
				КонецЕсли; 
			КонецЕсли;
		ИначеЕсли ИмяПравила = "<Brackets>" Тогда
			//Если Истина
			//	И ТипЗнч(ГруппаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
			//	И ГруппаОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли
			//Тогда
			//	ГруппаИ = ГруппаОтбора.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			//	ГруппаИ.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
			//Иначе
			//	ГруппаИ = ГруппаОтбора;
			//КонецЕсли; 
			ПостроитьДеревоЛогическогоВыражения(ГруппаОтбора, Данные.Tokens(1), ЗапросПакета, ЧастьОбъединения);
		Иначе
			ЭлементОтбора = ГруппаОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЗначимыйТокен = ОпуститьсяДоПервогоЗначимогоТокена(Токен);
			ЭлементОтбора.Представление = СобратьВыражениеЗапроса(ЗначимыйТокен,, ЗапросПакета, ЧастьОбъединения);
			ЭлементОтбора.ПравоеЗначение = Токен;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОсновныеДействияФормыОК(Кнопка = Неопределено)
	
	Если мРежимРедактированияТекста Тогда
		ПереключитьРежимРедактированияТекста();
	КонецЕсли; 
	Если мРежимРедактированияТекста Тогда
		Возврат;
	КонецЕсли; 
	ЭтаФорма.Модифицированность = Ложь;
	// Возвращаем текст всегда на диалекте источника
	Если Ложь
		Или мДиалектSQL <> ДиалектSQL 
	Тогда
		ДиалектSQL = мДиалектSQL;
		ОбновитьВсеВыражения();
	КонецЕсли; 
	СобратьПолныйТекст(, Истина);
	Закрыть(Истина);
	
КонецПроцедуры

Функция ПолучитьОпределениеТаблицы(ИмяИлиСтрокаВыбраннойТаблицы, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, Смещение = "")
	
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Если ТипЗнч(ИмяИлиСтрокаВыбраннойТаблицы) = Тип("Строка") Тогда
		СтрокаВыбраннойТаблицы = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(ИмяИлиСтрокаВыбраннойТаблицы), "НИмя");
	Иначе
		СтрокаВыбраннойТаблицы = ИмяИлиСтрокаВыбраннойТаблицы;
	КонецЕсли; 
	Если ЗначениеЗаполнено(СтрокаВыбраннойТаблицы.ПолноеИмя) Тогда
		Фрагменты = ЛксПолучитьМассивИзСтрокиСРазделителем(СтрокаВыбраннойТаблицы.ПолноеИмя);
		Результат = "";
		Для Каждого Фрагмент Из Фрагменты Цикл
			Если Результат <> "" Тогда
				Результат = Результат + ".";
			КонецЕсли; 
			Если Истина
				И Не ЛксЛиИмяПеременной(Фрагмент) 
				И Не (Истина
					И Лев(Фрагмент, 1) = ПараметрыДиалектаSQL.ПрефиксПараметра
					И ЛксЛиИмяПеременной(Сред(Фрагмент, 2)))
			Тогда
				Фрагмент = "[" + Фрагмент + "]";
			КонецЕсли; 
			Результат = Результат + Фрагмент;
		КонецЦикла;
		ТекстПараметров = "";
		Индекс = 0;
		Для каждого ПараметрТаблицы Из СтрокаВыбраннойТаблицы.Параметры Цикл
			Если Индекс > 0 Тогда
				ТекстПараметров = ТекстПараметров + ",";
			КонецЕсли; 
			ТекстПараметров = ТекстПараметров + Символы.ПС + Смещение + Символы.Таб;
			ТекстВыражения = ОбновитьВыражениеЗапроса(ПараметрТаблицы, ЭлементыФормы.ПараметрыТаблицы, ЗапросПакета, ЧастьОбъединения,,, Истина,, Ложь, Ложь);
			ирНеглобальный.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстПараметров, ТекстВыражения, Смещение + Символы.Таб);
			Индекс = Индекс + 1;
		КонецЦикла;
		Если ЗначениеЗаполнено(ТекстПараметров) Тогда
			Результат = Результат + "(" + ТекстПараметров + ")";
		КонецЕсли; 
	ИначеЕсли СтрокаВыбраннойТаблицы.ВложенныйПакет <> Неопределено Тогда
		лТекстПакета = СобратьТекстПакета(СтрокаВыбраннойТаблицы.ВложенныйПакет, Смещение);
		Результат = "(" + СокрЛ(лТекстПакета) + ")";
	Иначе
		ВызватьИсключение "У выбранной таблицы отсутствует определение"; 
	КонецЕсли; 
	Если Истина
		И ПараметрыДиалектаSQL.МногоТаблиц
		И ЗначениеЗаполнено(СтрокаВыбраннойТаблицы.Имя) 
	Тогда
		Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(СтрокаВыбраннойТаблицы.Имя);
	КонецЕсли; 
	КомментарийТаблицы = ПолучитьКомментарийДляВставки(СтрокаВыбраннойТаблицы.Комментарий, Смещение);
	Если ЗначениеЗаполнено(КомментарийТаблицы) Тогда
		Результат = КомментарийТаблицы + Результат;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Функция ПолучитьИмяСНеобходимымиСкобками(Имя)
	
	Результат = Имя;
	Если Не ЛксЛиИмяПеременной(Имя) Тогда
		Результат = "[" + Имя + "]";
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

// Параметры:
//   ЛиСобратьПакет - Булево, *Неопределено - собирать пакет, иначе только текущего запроса пакета
//
Функция СобратьПолныйТекст(Смещение = "", ЛиСобратьПакет = Неопределено)
	
	Если ЛиСобратьПакет = Неопределено Тогда
		ЛиСобратьПакет = ПолеТекстаОтображаетПакет;
	КонецЕсли; 
	ЗакончитьРедактированиеСвязанныхПолей();
	Если ЛиСобратьПакет Тогда
		Состояние("Сборка текста пакета...");
		Текст = СобратьТекстПакета();
	Иначе
		Состояние("Сборка текста запроса пакета...");
		Текст = СобратьТекстЗапросаПакета();
	КонецЕсли; 
	Состояние();
	Возврат Текст;
	
КонецФункции

Функция СобратьТекстПакета(Пакет = Неопределено, Смещение = "")

	Если Пакет = Неопределено Тогда
		Пакет = ЗапросыПакета;
	КонецЕсли; 
	Результат = "";
	Для Каждого ЗапросПакета Из Пакет Цикл
		ТекстЗапроса = СобратьТекстЗапросаПакета(ЗапросПакета, Смещение);
		Если Результат <> "" Тогда
			Результат = Результат + "
			|;
			|";
			Если Истина
				И Лев(ТекстЗапроса, СтрДлина(ПараметрыДиалектаSQL.СтрочныйКомментарий)) <> ПараметрыДиалектаSQL.СтрочныйКомментарий
			Тогда
				Результат = Результат + ЛксПолучитьСтрокуПовтором(ПараметрыДиалектаSQL.СтрочныйКомментарий, 20) + "
				|";
			КонецЕсли; 
		КонецЕсли; 
		Результат = Результат + ТекстЗапроса;
	КонецЦикла; 
	Возврат Результат;

КонецФункции

Функция СобратьТекстЗапросаПакета(ЗапросПакета = Неопределено, Смещение = "")

	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Результат = "";
	Если ирНеглобальный.СтрокиРавныЛкс(ЗапросПакета.ТипЗапроса, 2) Тогда
		Результат = Результат + ПолучитьКомментарийДляВставки(ЗапросПакета.Комментарий, Смещение);
		Если ЗначениеЗаполнено(Результат) Тогда
			Результат = Результат + Смещение;
		КонецЕсли; 
		Результат = Результат + ПолучитьСловоЯзыкаЗапросов("DROP") + " ";
		Если Не ПараметрыДиалектаSQL.INTOбезTABLE Тогда
			Результат = Результат + ПолучитьСловоЯзыкаЗапросов("TABLE") + " ";
		КонецЕсли; 
		Результат = Результат + XMLСтрока(ЗапросПакета.ИмяВременнойТаблицы);
		Возврат Результат;
	КонецЕсли; 
	Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
		ТекстЧасти = СобратьТекстЧастиОбъединения(ЗапросПакета, ЧастьОбъединения, Смещение);
		Если Результат <> "" Тогда
			Результат = Результат + "
			|" + ПолучитьСловоЯзыкаЗапросов("UNION");
			Если Не ЧастьОбъединения.БезДублей Тогда
				Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("ALL");
			КонецЕсли; 
			Результат = Результат + Символы.ПС;
		КонецЕсли; 
		Результат = Результат + ТекстЧасти;
	КонецЦикла;
	
	// ORDER BY
	ТекстПорядок = "";
	Для Каждого ЭлементПорядка Из ЗапросПакета.ПоляПорядка Цикл
		Если ТекстПорядок <> "" Тогда
			ТекстПорядок = ТекстПорядок + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстПорядок = ТекстПорядок + ПолучитьКомментарийДляВставки(ЭлементПорядка.Комментарий, Смещение + Символы.Таб);
		ТекстВыражения = ОбновитьВыражениеЗапроса(ЭлементПорядка, ЭлементыФормы.ПоляПорядка, ЗапросПакета,,,,,, Ложь, Ложь);
		ТекстПорядок = ТекстПорядок + ТекстВыражения;
		Если ЭлементПорядка.Направление = НаправлениеСортировки.Убыв Тогда
			ТекстПорядок = ТекстПорядок + " " + ПолучитьСловоЯзыкаЗапросов("DESC");
		КонецЕсли; 
	КонецЦикла;
	Если ТекстПорядок <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("ORDER") 
			+ " " + ПолучитьСловоЯзыкаЗапросов("BY") + Символы.ПС + Смещение + Символы.Таб + ТекстПорядок;
	КонецЕсли; 
	
	Если ПараметрыДиалектаSQL.INTOпослеORDER Тогда
		Если ирНеглобальный.СтрокиРавныЛкс(ЗапросПакета.ТипЗапроса, 1) Тогда
			Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("INTO") + " ";
			Если Не ПараметрыДиалектаSQL.INTOбезTABLE Тогда
				Результат = Результат + ПолучитьСловоЯзыкаЗапросов("TABLE") + " ";
			КонецЕсли; 
			Результат = Результат + XMLСтрока(ЗапросПакета.ИмяВременнойТаблицы);
		КонецЕсли; 
	КонецЕсли; 
	
	// INDEX BY
	ТекстИндекс = "";
	Для Каждого ЭлементИндекса Из ЗапросПакета.ПоляИндекса Цикл
		Если ТекстИндекс <> "" Тогда
			ТекстИндекс = ТекстИндекс + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстИндекс = ТекстИндекс + ПолучитьКомментарийДляВставки(ЭлементИндекса.Комментарий, Смещение + Символы.Таб);
		ТекстИндекс = ТекстИндекс + ЭлементИндекса.Определение;
	КонецЦикла;
	Если ТекстИндекс <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("INDEX") 
			+ " " + ПолучитьСловоЯзыкаЗапросов("BY") + Символы.ПС + Смещение + Символы.Таб + ТекстИндекс;
	КонецЕсли; 
		
	// TOTALS
	ТекстГруппирующиеПоля = "";
	Если ЗапросПакета.ОпцияОбщиеИтоги Тогда
		ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + ПолучитьСловоЯзыкаЗапросов("OVERALL");
	КонецЕсли; 
	Для Каждого СтрокаПоля Из ЗапросПакета.ГруппирующиеПоляИтогов Цикл
		Если ТекстГруппирующиеПоля <> "" Тогда
			ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + ПолучитьКомментарийДляВставки(СтрокаПоля.Комментарий, Смещение + Символы.Таб);
		ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + СтрокаПоля.Определение;
		Если Истина
			И ПараметрыДиалектаSQL.МногоТаблиц
			И ЗначениеЗаполнено(СтрокаПоля.Имя) 
		Тогда
			ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(СтрокаПоля.Имя);
		КонецЕсли; 
		Если ирНеглобальный.СтрокиРавныЛкс(СтрокаПоля.ТипИтогов, "Иерархия") Тогда
			ТекстГруппирующиеПоля = ТекстГруппирующиеПоля + " " + ПолучитьСловоЯзыкаЗапросов("HIERARCHY");
		КонецЕсли; 
	КонецЦикла;
	ТекстИтоговыеПоля = "";
	Для Каждого СтрокаПоля Из ЗапросПакета.ГруппируемыеПоляИтогов Цикл
		Если ТекстИтоговыеПоля <> "" Тогда
			ТекстИтоговыеПоля = ТекстИтоговыеПоля  + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстИтоговыеПоля = ТекстИтоговыеПоля + ПолучитьКомментарийДляВставки(СтрокаПоля.Комментарий, Смещение + Символы.Таб);
		ТекстИтоговыеПоля = ТекстИтоговыеПоля + СтрокаПоля.Определение;
		Если Истина
			И ПараметрыДиалектаSQL.МногоТаблиц 
			И ЗначениеЗаполнено(СтрокаПоля.Имя) 
		Тогда
			ТекстИтоговыеПоля = ТекстИтоговыеПоля + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(СтрокаПоля.Имя);
		КонецЕсли; 
	КонецЦикла;
	Если Ложь
		Или ТекстГруппирующиеПоля <> ""
		Или ТекстИтоговыеПоля <> ""
	Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("TOTALS");
		Если ЗначениеЗаполнено(ТекстИтоговыеПоля) Тогда
			Результат = Результат + Символы.ПС + Смещение + Символы.Таб + ТекстИтоговыеПоля;
		КонецЕсли; 
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("BY");
		Если ЗначениеЗаполнено(ТекстГруппирующиеПоля) Тогда
			Результат = Результат + Символы.ПС + Смещение + Символы.Таб + ТекстГруппирующиеПоля;
		КонецЕсли; 
	КонецЕсли; 
		
	Если Истина
		И ПараметрыДиалектаSQL.Это1С
		И ЗапросПакета.ОпцияАвтоупорядочивание 
	Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("AUTOORDER");
	КонецЕсли; 

	Возврат Результат;

КонецФункции

Функция ПолучитьКомментарийДляВставки(Комментарий, Смещение = "")
	
	Результат = "";
	Если Не ЗначениеЗаполнено(Комментарий) Тогда
		Возврат Результат;
	КонецЕсли; 
	Если Не ЗначениеЗаполнено(ПараметрыДиалектаSQL.СтрочныйКомментарий) Тогда
		ЛксСообщитьСУчетомМодальности("Проигнорирован комментарий (не поддерживается диалектом SQL): " + Комментарий, , СтатусСообщения.Внимание);
		Возврат Результат;
	КонецЕсли; 
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(Комментарий);
	Для Счетчик = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		Если Результат <> "" Тогда
			Результат = Результат + Смещение;
		КонецЕсли; 
		Результат = Результат + ПараметрыДиалектаSQL.СтрочныйКомментарий + ТекстовыйДокумент.ПолучитьСтроку(Счетчик) + Символы.ПС;
	КонецЦикла;
	Результат = Результат + Смещение;
	Возврат Результат;
	
КонецФункции

Функция СобратьТекстЧастиОбъединения(ЗапросПакета, ЧастьОбъединения, Смещение = "")

	Результат = "";
	
	// SELECT
	Результат = Результат + ПолучитьКомментарийДляВставки(ЧастьОбъединения.Комментарий, Смещение);
	Если ЗначениеЗаполнено(Результат) Тогда
		Результат = Результат + Смещение;
	КонецЕсли; 
	Результат = Результат + ПолучитьСловоЯзыкаЗапросов("SELECT");
	Если ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения[0] Тогда
		Если Истина
			И ПараметрыДиалектаSQL.Это1С
			И ЗапросПакета.ОпцияРазрешенные 
		Тогда
			Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("ALLOWED");
		КонецЕсли; 
		Если ЗапросПакета.ОпцияПервые Тогда
			Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("TOP") + " " + XMLСтрока(ЗапросПакета.ПервыеКоличество);
		КонецЕсли; 
	КонецЕсли; 
	Если ЧастьОбъединения.ОпцияРазличные Тогда
		Результат = Результат + " " + ПолучитьСловоЯзыкаЗапросов("DISTINCT");
	КонецЕсли; 
	ТекстПоляВыбора = "";
	ДобавленныеТаблицыВсеПоля = Новый Массив();
	Для Каждого СтрокаПоляОбъединения Из ЗапросПакета.ПоляОбъединения Цикл
		ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля.Найти(СтрокаПоляОбъединения["_" + ЧастьОбъединения.Номер], "ИД");
		ПсевдонимПоля = СтрокаПоляОбъединения.Имя;
		ТекстКомментария = "";
		Если ВыбранноеПоле = Неопределено Тогда
			ТекстВыражения = ПолучитьСловоЯзыкаЗапросов("NULL");
		ИначеЕсли ВыбранноеПоле.Автополе Тогда
			ПсевдонимПоля = "";
			ТекстВыражения = "*";
			Если ЧастьОбъединения.ВыбранныеТаблицы.Количество() > 1 Тогда
				ИмяТаблицы = ЛксПолучитьПервыйФрагмент(ВыбранноеПоле.Определение);
				ТекстВыражения = ИмяТаблицы + "." + ТекстВыражения;
				КлючТаблицы = НРег(ИмяТаблицы);
			Иначе
				КлючТаблицы = "";
			КонецЕсли; 
			Если ДобавленныеТаблицыВсеПоля.Найти(КлючТаблицы) = Неопределено Тогда
				ДобавленныеТаблицыВсеПоля.Добавить(КлючТаблицы);
			Иначе
				Продолжить;
			КонецЕсли; 
		Иначе
			ТекстВыражения = ОбновитьВыражениеЗапроса(ВыбранноеПоле, ЭлементыФормы.ВыбранныеПоля, ЗапросПакета, ЧастьОбъединения,,,,,, Ложь);
			ТекстКомментария = ПолучитьКомментарийДляВставки(ВыбранноеПоле.Комментарий, Смещение + Символы.Таб);
		КонецЕсли; 
		Если ТекстПоляВыбора <> "" Тогда
			ТекстПоляВыбора = ТекстПоляВыбора + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстПоляВыбора = ТекстПоляВыбора + ТекстКомментария;
		ирНеглобальный.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстПоляВыбора, ТекстВыражения, Смещение + Символы.Таб);
		Если Истина
			И ПараметрыДиалектаSQL.МногоТаблиц
			И ЗначениеЗаполнено(ПсевдонимПоля) 
		Тогда
			ТекстПоляВыбора = ТекстПоляВыбора + " " + ПолучитьСловоЯзыкаЗапросов("AS") + " " + ПолучитьИмяСНеобходимымиСкобками(СтрокаПоляОбъединения.Имя);
		КонецЕсли;
	КонецЦикла;
	Если Не ЗначениеЗаполнено(ТекстПоляВыбора) Тогда
		ТекстПоляВыбора = "*";
	КонецЕсли; 
	Результат = Результат + Символы.ПС + Смещение + Символы.Таб + ТекстПоляВыбора;
	
	Если Не ПараметрыДиалектаSQL.INTOпослеORDER Тогда
		Если ЧастьОбъединения = ЗапросПакета.ЧастиОбъединения[0] Тогда
			Если ирНеглобальный.СтрокиРавныЛкс(ЗапросПакета.ТипЗапроса, 1) Тогда
				Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("INTO") + " ";
				Если Не ПараметрыДиалектаSQL.INTOбезTABLE Тогда
					Результат = Результат + ПолучитьСловоЯзыкаЗапросов("TABLE") + " ";
				КонецЕсли; 
				Результат = Результат + XMLСтрока(ЗапросПакета.ИмяВременнойТаблицы);
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	
	ТекстИЗ = СобратьТекстИЗ(ЗапросПакета, ЧастьОбъединения, Смещение);
	Результат = Результат + ТекстИЗ;
	
	// WHERE
	ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЧастьОбъединения.Условие.Отбор, 1, 1);
	Если ТекстУсловия <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("WHERE");
		Результат = Результат + Символы.ПС + Смещение + Символы.Таб + ПолучитьКомментарийДляВставки(ЧастьОбъединения.КомментарийОтбора, Смещение + Символы.Таб);
		ирНеглобальный.ДобавитьМногострочнуюСтрокуВТекстЛкс(Результат, ТекстУсловия, Смещение);
	КонецЕсли; 
	
	// GROUP BY
	ТекстГруппировки = "";
	Для Каждого Группировка Из ЧастьОбъединения.Группировки Цикл
		Если ТекстГруппировки <> "" Тогда
			ТекстГруппировки = ТекстГруппировки + "," + Символы.ПС + Смещение + Символы.Таб;
		КонецЕсли; 
		ТекстГруппировки = ТекстГруппировки + ПолучитьКомментарийДляВставки(Группировка.Комментарий, Смещение + Символы.Таб);
		ТекстВыражения = ОбновитьВыражениеЗапроса(Группировка, ЭлементыФормы.Группировки, ЗапросПакета, ЧастьОбъединения,,,,,, Ложь);
		ирНеглобальный.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстГруппировки, ТекстВыражения, Смещение + Символы.Таб);
	КонецЦикла;
	Если ТекстГруппировки <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("GROUP") 
			+ " " + ПолучитьСловоЯзыкаЗапросов("BY") + Символы.ПС + Смещение + Символы.Таб + ТекстГруппировки;
	КонецЕсли; 
	
	// HAVING
	ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ЧастьОбъединения.Условие.Отбор, 1, 2);
	Если ТекстУсловия <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("HAVING");
		Результат = Результат + Символы.ПС + Смещение + Символы.Таб;
		ирНеглобальный.ДобавитьМногострочнуюСтрокуВТекстЛкс(Результат, ТекстУсловия, Смещение);
	КонецЕсли; 
	
	Возврат Результат;

КонецФункции

// Текст FROM
Функция СобратьТекстИЗ(ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено, Смещение = "")

	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Результат = "";
	// Делаем все соединения не правыми
	Для Каждого СвязьТаблиц Из ЧастьОбъединения.СвязиТаблиц Цикл
		Если Истина
			И Не СвязьТаблиц.ВсеСтрокиЛевой 
			И СвязьТаблиц.ВсеСтрокиПравой
		Тогда
			ПоменятьМестамиТаблицыСвязи(СвязьТаблиц);
		КонецЕсли; 
		//Если Истина
		//	И СвязьТаблиц.ВсеСтрокиЛевой = СвязьТаблиц.ВсеСтрокиПравой
		//	И СвязьТаблиц.ЛеваяТаблица > СвязьТаблиц.ПраваяТаблица
		//Тогда
		//	ПоменятьМестамиТаблицыСвязи(СвязьТаблиц);
		//КонецЕсли;
	КонецЦикла;
	ТекстТаблицы = "";
	ДобавленныеТаблицыСвязей = Новый Массив();
	КоличествоСдвигов = 0;
	КоличествоПарТаблиц = ЧастьОбъединения.СвязиТаблиц.Количество();
	Для Индекс = 0 По КоличествоПарТаблиц - 1 Цикл
		ПараТаблиц = ЧастьОбъединения.СвязиТаблиц[Индекс];
		ЛеваяТаблицаДобавлена = ДобавленныеТаблицыСвязей.Найти(ПараТаблиц.ЛеваяТаблица) <> Неопределено;
		ПраваяТаблицаДобавлена = ДобавленныеТаблицыСвязей.Найти(ПараТаблиц.ПраваяТаблица) <> Неопределено;
		Если Истина
			И ЛеваяТаблицаДобавлена
			И ПраваяТаблицаДобавлена
		Тогда
			ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока = ЗапросПакета;
			ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока = ЧастьОбъединения;
			ЭлементыФормы.ПанельОсновная.ТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения;
			ЭлементыФормы.ПанельЧасти.ТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.СвязиТаблиц;
			ВызватьИсключение "Противоречивая связь таблиц №" + (Индекс + 1) + " (" + ПараТаблиц.ЛеваяТаблица + " - " + ПараТаблиц.ПраваяТаблица + ")";
		КонецЕсли; 
		ОбеТаблицыНедобавлены = Истина
			И ДобавленныеТаблицыСвязей.Количество() > 0
			И Не ЛеваяТаблицаДобавлена
			И Не ПраваяТаблицаДобавлена;
		Если Истина
			И ОбеТаблицыНедобавлены
			И Индекс < КоличествоПарТаблиц - 1 - КоличествоСдвигов
		Тогда
			// Сдвигаем в конец
			ЧастьОбъединения.СвязиТаблиц.Сдвинуть(ПараТаблиц, КоличествоПарТаблиц - Индекс - 1);
			КоличествоСдвигов = КоличествоСдвигов + 1;
			Индекс = Индекс - 1;
		Иначе
			Если ОбеТаблицыНедобавлены Тогда
				ТекстТаблицы = ТекстТаблицы + "," + Символы.ПС + Смещение + Символы.Таб;
			КонецЕсли; 
			Если Истина
				И Не ЛеваяТаблицаДобавлена 
				И ПраваяТаблицаДобавлена
			Тогда
				СоединяемаяТаблица = ПараТаблиц.ЛеваяТаблица;
			Иначе
				СоединяемаяТаблица = ПараТаблиц.ПраваяТаблица;
			КонецЕсли; 
			ДобавленныеТаблицыСвязей.Добавить(ПараТаблиц.ЛеваяТаблица);
			ДобавленныеТаблицыСвязей.Добавить(ПараТаблиц.ПраваяТаблица);
			Если Ложь
				Или ТекстТаблицы = ""
				Или ОбеТаблицыНедобавлены
			Тогда
				ТекстТаблицы = ТекстТаблицы + Символы.ПС + Смещение + Символы.Таб + ПолучитьОпределениеТаблицы(ПараТаблиц.ЛеваяТаблица, ЗапросПакета, ЧастьОбъединения, Смещение + Символы.Таб);
			КонецЕсли; 
			ТекстТаблицы = ТекстТаблицы + Символы.ПС + Смещение + Символы.Таб;
			Если Истина
				И ПараТаблиц.ВсеСтрокиПравой 
				И ПараТаблиц.ВсеСтрокиЛевой
			Тогда
				ТекстТаблицы = ТекстТаблицы + ПолучитьСловоЯзыкаЗапросов("OUTER");
			ИначеЕсли ПараТаблиц.ВсеСтрокиЛевой Тогда 
				ТекстТаблицы = ТекстТаблицы + ПолучитьСловоЯзыкаЗапросов("LEFT");
			Иначе
				ТекстТаблицы = ТекстТаблицы + ПолучитьСловоЯзыкаЗапросов("INNER");
			КонецЕсли; 
			ТекстТаблицы = ТекстТаблицы + " " + ПолучитьСловоЯзыкаЗапросов("JOIN") 
				+ " " + ПолучитьОпределениеТаблицы(СоединяемаяТаблица, ЗапросПакета, ЧастьОбъединения, Смещение + Символы.Таб);
			ТекстУсловия = ПолучитьВыражениеОтбораКомпоновкиНаЯзыкеЛкс(ПараТаблиц.Условие.Отбор, 2);
			Если ПустаяСтрока(ТекстУсловия) Тогда
				ТекстУсловия = ПолучитьСловоЯзыкаЗапросов("TRUE");
			КонецЕсли; 
			ТекстТаблицы = ТекстТаблицы + Символы.ПС + Смещение + Символы.Таб + ПолучитьСловоЯзыкаЗапросов("ON") + " ";
			ирНеглобальный.ДобавитьМногострочнуюСтрокуВТекстЛкс(ТекстТаблицы, ТекстУсловия, Смещение);
		КонецЕсли; 
	КонецЦикла;
	Для Каждого ВыбраннаяТаблица Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
		Если ДобавленныеТаблицыСвязей.Найти(ВыбраннаяТаблица.Имя) = Неопределено Тогда
			Если ТекстТаблицы <> "" Тогда
				ТекстТаблицы = ТекстТаблицы + ",";
			КонецЕсли; 
			ТекстТаблицы = ТекстТаблицы + Символы.ПС + Смещение + Символы.Таб + ПолучитьОпределениеТаблицы(ВыбраннаяТаблица, ЗапросПакета, ЧастьОбъединения, Смещение + Символы.Таб);
		КонецЕсли;
	КонецЦикла;
	Если ТекстТаблицы <> "" Тогда
		Результат = Результат + Символы.ПС + Смещение + ПолучитьСловоЯзыкаЗапросов("FROM") + ТекстТаблицы;
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция ПоменятьМестамиТаблицыСвязи(СвязьТаблиц)

	// Меняем местами левую и правую стороны
	лЛеваяТаблица = СвязьТаблиц.ЛеваяТаблица;
	СвязьТаблиц.ЛеваяТаблица = СвязьТаблиц.ПраваяТаблица;
	СвязьТаблиц.ПраваяТаблица = лЛеваяТаблица;
	лВсеСтрокиЛевой = СвязьТаблиц.ВсеСтрокиЛевой;
	СвязьТаблиц.ВсеСтрокиЛевой = СвязьТаблиц.ВсеСтрокиПравой;
	СвязьТаблиц.ВсеСтрокиПравой = лВсеСтрокиЛевой;
	Возврат Неопределено;

КонецФункции

Функция ЗакончитьРедактированиеСвязанныхПолей()

	СохранитьЗапросПакета();
	Возврат Неопределено;

КонецФункции

Процедура ВыбранныеТаблицыПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если Истина
			И ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.ДоступныеТаблицы") 
		Тогда
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если Истина
			И ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("ОбработкаТабличнаяЧастьСтрока.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.ДоступныеТаблицы") 
		Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьДоступнуюТаблицуВВыбранные(СтрокаПеретаскивания);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДобавитьДоступнуюТаблицуВВыбранные(СтрокаДоступнойТаблицы)

	Если Истина
		И Не ПараметрыДиалектаSQL.МногоТаблиц
		И ВыбранныеТаблицы.Количество() > 0
	Тогда
		Возврат;
	КонецЕсли; 
	ВыбраннаяТаблица = ДобавитьВыбраннуюТаблицу();
	//ОпределениеТаблицы = СтрокаДоступнойТаблицы.Имя;
	//Если ЗначениеЗаполнено(СтрокаДоступнойТаблицы.Схема) Тогда
	//	ОпределениеТаблицы = СтрокаДоступнойТаблицы.Схема + "." + ОпределениеТаблицы;
	//КонецЕсли; 
	//ВыбраннаяТаблица.Определение = ОпределениеТаблицы;
	ВыбраннаяТаблица.Имя = ирНеглобальный.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ВыбранныеТаблицы, СтрокаДоступнойТаблицы.Имя);
	ВыбраннаяТаблица.ПолноеИмя = СтрокаДоступнойТаблицы.ПолноеИмя;
	ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ВыбраннаяТаблица);
	ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока = ВыбраннаяТаблица;
	ОбновитьНаименованиеЧасти();

КонецПроцедуры

Процедура ВыбранныеПоляПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если Ложь
			Или ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("ДоступноеПолеКомпоновкиДанных")
			Или (Истина
				И ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("СтрокаДереваЗначений")
				//И ПараметрыПеретаскивания.Значение.Владелец() = ДоступныеПоляВыбора // Так не работает
				И ЗначениеПеретаскивания[0].Владелец().Колонки.Найти("Имя") <> Неопределено)
		Тогда
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеПоляПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)

	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если Ложь
			Или ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("ДоступноеПолеКомпоновкиДанных")
			Или (Истина
				И ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("СтрокаДереваЗначений")
				//И ПараметрыПеретаскивания.Значение.Владелец() = ДоступныеПоляВыбора // Так не работает
				И ЗначениеПеретаскивания[0].Владелец().Колонки.Найти("Имя") <> Неопределено)
		Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(СтрокаПеретаскивания);
			КонецЦикла;  
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(СтрокаДоступногоПоля, Автополе = Ложь, ЗапросПакета = Неопределено,
	ЧастьОбъединения = Неопределено, СдвигИндексаПослеДобавления = 0, КонтролироватьУникальность = Ложь, ОбновитьПоляОбъединения = Истина)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если Истина
		И ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступноеПолеКомпоновкиДанных")
		И ЭтоНедоступноеДоступноеПоле(СтрокаДоступногоПоля) 
	Тогда
		Возврат;
	КонецЕсли; 
	Если Ложь
		Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступныеПоляКомпоновкиДанных")
		Или СтрокаДоступногоПоля.Родитель = Неопределено 
	Тогда
		//Если ирНеглобальный.СтрокиРавныЛкс("СистемныеПоля", "" + СтрокаДоступногоПоля.Поле) Тогда
		//	Возврат;
		//КонецЕсли; 
		// Все дочерние поля
		Если Ложь
			Или ТипЗнч(СтрокаДоступногоПоля) = Тип("ДоступныеПоляКомпоновкиДанных")
			Или Не ирНеглобальный.СтрокиРавныЛкс("ПараметрыДанных", "" + СтрокаДоступногоПоля.Поле) 
		Тогда
			Если ПараметрыДиалектаSQL.МногоТаблиц Тогда
				ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(СтрокаДоступногоПоля.Поле), "НИмя");
			Иначе
				ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы[0];
			КонецЕсли; 
			Если Не ВыбраннаяТаблица.ВсеПоля Тогда
				Ответ = Вопрос("Хотите включить выбор всех полей из таблицы?", РежимДиалогаВопрос.ДаНет);
				Если Ответ = КодВозвратаДиалога.Да Тогда
					ВыбраннаяТаблица.ВсеПоля = Истина;
					Автополе = Истина;
					КонтролироватьУникальность = Истина;
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли; 
		Для Каждого лСтрокаДоступногоПоля Из СтрокаДоступногоПоля.Элементы Цикл
			ДобавитьДоступноеПолеВВыбранныеПоля(лСтрокаДоступногоПоля, Автополе, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления,
				КонтролироватьУникальность, Ложь);
		КонецЦикла;
		Если ОбновитьПоляОбъединения Тогда
			ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
		КонецЕсли;
	Иначе
		//Если ирНеглобальный.СтрокиРавныЛкс("СистемныеПоля", "" + СтрокаДоступногоПоля.Родитель.Поле) Тогда
		//	Возврат;
		//КонецЕсли; 
		// Одно поле
		ДобавитьДоступноеПолеВВыбранныеПоля(СтрокаДоступногоПоля, Автополе, ЗапросПакета, ЧастьОбъединения, СдвигИндексаПослеДобавления,
			КонтролироватьУникальность, ОбновитьПоляОбъединения);
	КонецЕсли; 

КонецПроцедуры

Функция ДобавитьДоступноеПолеВВыбранныеПоля(СтрокаДоступногоПоля, Автополе = Ложь, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено,
	СдвигИндексаПослеДобавления = 0, КонтролироватьУникальность = Ложь, ОбновитьПоляОбъединения = Истина)

	Если ЭтоНедоступноеДоступноеПоле(СтрокаДоступногоПоля) Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ОпределениеПоля = ПолучитьПолноеИмяДоступногоПоля(СтрокаДоступногоПоля);
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	ТабличноеПоле = ЭлементыФормы.ВыбранныеПоля;
	Если КонтролироватьУникальность Тогда
	//Если Автополе Тогда
		СтрокаВыбранногоПоля = ЧастьОбъединения.ВыбранныеПоля.Найти(ОпределениеПоля, "Определение");
	КонецЕсли; 
	Если СтрокаВыбранногоПоля = Неопределено Тогда
		СтрокаВыбранногоПоля = ЧастьОбъединения.ВыбранныеПоля.Добавить();
		ЧастьОбъединения.ВыбранныеПоля.Сдвинуть(СтрокаВыбранногоПоля, СдвигИндексаПослеДобавления);
		СтрокаВыбранногоПоля.Определение = ОпределениеПоля;
		ИмяПоля = ПолучитьАвтоПсевдонимПоля(СтрокаВыбранногоПоля, ЧастьОбъединения);
		СтрокаВыбранногоПоля.Имя = ИмяПоля;
		СтрокаВыбранногоПоля.ИД = Новый УникальныйИдентификатор();
		ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаВыбранногоПоля);
		//СтрокаВыбранногоПоля.ТипЗначения = СтрокаДоступногоПоля.ТипЗначения;
	КонецЕсли; 
	СтрокаВыбранногоПоля.Автополе = Автополе;
	Если ОбновитьПоляОбъединения Тогда
		ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока = СтрокаВыбранногоПоля;
	КонецЕсли; 
	ПриИзмененииВыраженияВыбранногоПоля(СтрокаВыбранногоПоля, ЗапросПакета, ЧастьОбъединения, Ложь); // Надо делать после активизации строки
	Если ОбновитьПоляОбъединения Тогда
		ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
	КонецЕсли; 
	Возврат СтрокаВыбранногоПоля;

КонецФункции

Функция ПолучитьАвтоПсевдонимПоля(СтрокаВыбранногоПоля, ЧастьОбъединения = Неопределено)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	ПозицияТочки = Найти(СтрокаВыбранногоПоля.Определение, ".");
	ИмяПоля = Сред(СтрокаВыбранногоПоля.Определение, ПозицияТочки + 1);
	ИмяПоля = СтрЗаменить(ИмяПоля, ".", "");
	ИмяПоля = ирНеглобальный.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ЧастьОбъединения.ВыбранныеПоля, ИмяПоля);
	Возврат ИмяПоля;

КонецФункции

Процедура ПанельЧастиПриСменеСтраницы(Элемент = Неопределено, ТекущаяСтраница = Неопределено)
	
	ЗакончитьРедактированиеСвязанныхПолей();
	Если Элемент = Неопределено Тогда
		Элемент = ЭлементыФормы.ПанельЧасти;
	КонецЕсли; 
	Если ТекущаяСтраница = Неопределено Тогда
		ТекущаяСтраница = Элемент.ТекущаяСтраница.Имя;
	КонецЕсли; 
	Если ТипЗапроса <> 2 Тогда
		Если Ложь
			Или мСтараяСтраницаПанелиЧасти = ЭлементыФормы.ПанельЧасти.Страницы.ВыбранныеТаблицы 
		Тогда
			ЗагрузитьДоступныеНастройкиКомпоновки();
			СвязиТаблицПриАктивизацииСтроки();
		КонецЕсли; 
	КонецЕсли; 
	ПанельЧастиОбновитьТекущуюСтраницу();
	ЭтаФорма.мСтараяСтраницаПанелиЧасти = Элемент.Страницы[ТекущаяСтраница];
	
КонецПроцедуры

Функция ПанельЧастиОбновитьТекущуюСтраницу()

	лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.ТекущаяСтраница;
	Если лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.Группировки Тогда
		ДоступныеВыбранныеПоля = ВыбранныеПоля.Скопировать();
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.Текст Тогда
		ПересобратьВременныйТекстЧасти();
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.СвязиТаблиц Тогда
		ЭлементыФормы.СвязиТаблиц.ОбновитьСтроки();
		ЭлементыФормы.ВыборЛевойТаблицыСвязи.ОбновитьСтроки();
		ЭлементыФормы.ВыборПравойТаблицыСвязи.ОбновитьСтроки();
		Если ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока = Неопределено Тогда
			Если СвязиТаблиц.Количество() > 0 Тогда
				ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока = СвязиТаблиц[0];
			КонецЕсли; 
		КонецЕсли; 
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

Функция ПересобратьВременныйТекстЧасти()

	Состояние("Сборка текста части объединения...");
	ТекстЧасти = СобратьТекстЧастиОбъединения(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока, ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока);
	ирНеглобальный.УстановитьТекстПоляСохраняяПозициюЛкс(ЭлементыФормы.ПолеТекстаЧасти, ТекстЧасти);
	Состояние();
	Возврат Неопределено;

КонецФункции

Процедура ЗагрузитьДоступныеНастройкиКомпоновки()
	
	ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединения);
	КомпоновщикУсловияСвязи.Инициализировать(ЧастьОбъединения.ИсточникНастроек);
	Если ЧастиОбъединения.Количество() = 1 Тогда
		КомпоновщикЗапроса.Инициализировать(ЧастьОбъединения.ИсточникНастроек);
	Иначе
		КомпоновщикЗапроса.Инициализировать(Новый ИсточникДоступныхНастроекКомпоновкиДанных(Новый СхемаКомпоновкиДанных));
	КонецЕсли; 
	
КонецПроцедуры

Функция ОбновитьКомпоновщикЧастиОбъединения(ЧастьОбъединения = Неопределено)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	ДоступныеПоляВыбора = Новый ДеревоЗначений;
	ДоступныеПоляВыбора.Колонки.Добавить("Имя");
	ДоступныеПоляВыбора.Колонки.Добавить("ТипЗначения");
	Для Каждого ВыбраннаяТаблица Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
		СтрокаТаблицыВДереве = ДоступныеПоляВыбора.Строки.Добавить();
		ИмяТаблицы = ПолучитьИмяВыбраннойТаблицы(ВыбраннаяТаблица);
		СтрокаТаблицыВДереве.Имя = ИмяТаблицы;
		ДоступныеПоляТаблицы = ПолучитьДоступныеПоляТаблицы(ИмяТаблицы, ЧастьОбъединения);
		Для Каждого ДоступноеПолеТаблицы Из ДоступныеПоляТаблицы Цикл
			СтрокаПоляВДереве = СтрокаТаблицыВДереве.Строки.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаПоляВДереве, ДоступноеПолеТаблицы); 
		КонецЦикла;
	КонецЦикла;
	Если Параметры.Количество() > 0 Тогда
		СтрокаГруппыПараметраВДереве = ДоступныеПоляВыбора.Строки.Добавить();
		СтрокаГруппыПараметраВДереве.Имя = "<Параметры>";
		Для Каждого CтрокаПараметра Из Параметры Цикл
			СтрокаПараметраВДереве = СтрокаГруппыПараметраВДереве.Строки.Добавить();
			СтрокаПараметраВДереве.Имя = CтрокаПараметра.Имя;
			СтрокаПараметраВДереве.ТипЗначения = CтрокаПараметра.ТипЗначения;
		КонецЦикла;
	КонецЕсли; 
	
	СхемаКомпоновки = Новый СхемаКомпоновкиДанных;
	ИсточникДанных = ЛксДобавитьЛокальныйИсточникДанных(СхемаКомпоновки);
	НаборДанных = СхемаКомпоновки.НаборыДанных.Добавить(Тип("НаборДанныхОбъектСхемыКомпоновкиДанных"));
	НаборДанных.ИсточникДанных = ИсточникДанных.Имя;
	Для Каждого СтрокаДоступнойТаблицы Из ДоступныеПоляВыбора.Строки Цикл
		Если СтрокаДоступнойТаблицы.Имя = "<Параметры>" Тогда
			Продолжить;
		КонецЕсли; 
		ПапкаПолей = НаборДанных.Поля.Добавить(Тип("ПапкаПолейНабораДанныхСхемыКомпоновкиДанных"));
		ПапкаПолей.ПутьКДанным = СтрокаДоступнойТаблицы.Имя;
		ПапкаПолей.Заголовок = ПапкаПолей.ПутьКДанным;
		Для Каждого СтрокаДоступногоПоля Из СтрокаДоступнойТаблицы.Строки Цикл
			ПолеНабора = НаборДанных.Поля.Добавить(Тип("ПолеНабораДанныхСхемыКомпоновкиДанных"));
			ПолеНабора.Поле = СтрокаДоступногоПоля.Имя;
			Если ПараметрыДиалектаSQL.МногоТаблиц Тогда
				ПолеНабора.ПутьКДанным = СтрокаДоступнойТаблицы.Имя + "." + ПолеНабора.Поле;
			Иначе
				ПолеНабора.ПутьКДанным = ПолеНабора.Поле;
			КонецЕсли; 
			ПолеНабора.Заголовок = ПолеНабора.ПутьКДанным;
			ПолеНабора.ТипЗначения = СтрокаДоступногоПоля.ТипЗначения;
		КонецЦикла;
	КонецЦикла;
	Для Каждого Параметр Из Параметры Цикл
		ПараметрСхемы = СхемаКомпоновки.Параметры.Добавить();
		ПараметрСхемы.Имя = Параметр.Имя;
		ПараметрСхемы.ТипЗначения = Параметр.ТипЗначения;
	КонецЦикла;
	ИсточникНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(СхемаКомпоновки);
	ЧастьОбъединения.ИсточникНастроек = ИсточникНастроек;
	ЧастьОбъединения.Компоновщик.Инициализировать(ИсточникНастроек);
	Возврат ИсточникНастроек;

КонецФункции

Процедура ПриОткрытии()
	
	ЭтаФорма.мСтараяСтраницаПанелиЧасти = ЭлементыФормы.ПанельЧасти.ТекущаяСтраница;
	ЭтаФорма.мСтараяСтраницаПанелиОсновная = ЭлементыФормы.ПанельОсновная.ТекущаяСтраница;
	
	// +++.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой
	ПолеТекстовогоДокументаСКонтекстнойПодсказкой = Новый Структура;
	
	Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать().Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ВыражениеВыбранногоПоля, , 1, "ПроверитьВыражение", ЭтаФорма, "Выражение", Конфигурация);

	Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать().Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ВыражениеЭлементаУсловияСвязи, , 1, "ПроверитьВыражение", ЭтаФорма, "Выражение", Конфигурация);

	Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать().Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ВыражениеЭлементаУсловия, , 1, "ПроверитьВыражение", ЭтаФорма, "Выражение", Конфигурация);
		
	Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать().Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ВыражениеПараметраТаблицы, , 1, "ПроверитьВыражение", ЭтаФорма, "Выражение", Конфигурация);
		
	Обработки.ирКлсПолеТекстовогоДокументаСКонтекстнойПодсказкой.Создать().Инициализировать(ПолеТекстовогоДокументаСКонтекстнойПодсказкой,
		ЭтаФорма, ЭлементыФормы.ПолеТекстаЗапроса, , 1,,,, Конфигурация);
		
	// ---.КЛАСС.ПолеТекстовогоДокументаСКонтекстнойПодсказкой
		
	ЛксОбновитьТекстПослеМаркераВСтроке(ЭтаФорма.Заголовок,, мДиалектSQL);
	мТекущийДиалектSQL = мДиалектSQL;
	Если ЗапросыПакета.Количество() = 0 Тогда
		УстановитьДанные();
	КонецЕсли; 

КонецПроцедуры

// Выполняет программный код в контексте.
//
// Параметры:
//  ТекстДляВыполнения – Строка;
//  *ЛиСинтаксическийКонтроль - Булево, *Ложь - признак вызова только для синтаксического контроля.
//
Функция ПроверитьВыражение(ТекстДляПроверки, ЛиСинтаксическийКонтроль = Ложь) Экспорт
	

КонецФункции // ВычислитьВФорме()

Процедура ОбновитьДоступныеВременныеТаблицы() Экспорт
	
	СтрокиТаблиц = ДоступныеТаблицы.НайтиСтроки(Новый Структура("Тип", "ВременнаяТаблица"));
	Если ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока <> Неопределено Тогда
		ИндексТекущегоЗапроса = ЗапросыПакета.Индекс(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока);
	Иначе
		ИндексТекущегоЗапроса = ЗапросыПакета.Количество() - 1;
	КонецЕсли; 
	Для Каждого СтрокаКУдалению Из СтрокиТаблиц Цикл
		СтрокаПородившегоЗапроса = ЗапросыПакета.Найти(СтрокаКУдалению.ПородившийЗапрос, "ИД");
		Если Истина
			И СтрокаПородившегоЗапроса <> Неопределено
			И ИндексТекущегоЗапроса <= ЗапросыПакета.Индекс(СтрокаПородившегоЗапроса) 
		Тогда
			ДоступныеТаблицы.Удалить(СтрокаКУдалению);
		КонецЕсли; 
	КонецЦикла;
	СтруктураДобавленныхТаблиц = Новый Структура();
	Для Индекс = 0 По ИндексТекущегоЗапроса - 1 Цикл
		ЗапросПакета = ЗапросыПакета[Индекс];
		Если ЗапросПакета.ТипЗапроса = 1 Тогда
			//Если ДоступныеТаблицы.Найти(НРег(ЗапросПакета.ИмяВременнойТаблицы), "НПолноеИмя") = Неопределено Тогда
				СтруктураДобавленныхТаблиц.Вставить(ЗапросПакета.ИмяВременнойТаблицы, ЗапросПакета.ИД);
			//КонецЕсли; 
		ИначеЕсли ЗапросПакета.ТипЗапроса = 2 Тогда
			Если СтруктураДобавленныхТаблиц.Свойство(ЗапросПакета.ИмяВременнойТаблицы) Тогда
				СтруктураДобавленныхТаблиц.Удалить(ЗапросПакета.ИмяВременнойТаблицы);
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	Для Каждого КлючИЗначение Из СтруктураДобавленныхТаблиц Цикл
		ДобавитьДоступнуюТаблицу1С(КлючИЗначение.Ключ, "ВременнаяТаблица", , , КлючИЗначение.Значение);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьДоступныеТаблицы1С()

	//ОчиститьДоступныеНеВременныеТаблицы();
	ДоступныеВременныеТаблицы = ДоступныеТаблицы.Выгрузить(Новый Структура("Тип", "ВременнаяТаблица"));
	ДоступныеТаблицы.Очистить();
	Если ЭтотОбъект.мДоступныеТаблицыКонфигурации <> Неопределено Тогда
		ДоступныеТаблицы.Загрузить(ЭтотОбъект.мДоступныеТаблицыКонфигурации);
		ЛксЗагрузитьВТаблицуЗначений(ДоступныеВременныеТаблицы, ДоступныеТаблицы);
		Возврат;
	КонецЕсли; 
	ДоступныеТаблицы.Загрузить(ДоступныеВременныеТаблицы);
	Состояние("Подготовка метаданных...");
	ТабличноеПолеДоступныхТаблиц = ЭлементыФормы.ДоступныеТаблицы;
	Если ТабличноеПолеДоступныхТаблиц.ТекущаяСтрока <> Неопределено Тогда
		КлючТекущейСтроки = ТабличноеПолеДоступныхТаблиц.ТекущаяСтрока.ПолноеИмяОбъекта;
	КонецЕсли; 
	КоллекцияКорневыхТипов = Новый Массив;
	СтрокиМетаОбъектов = ирКэш.Получить().ТаблицаТиповМетаОбъектов.НайтиСтроки(Новый Структура("Категория", 0));
	Для Каждого СтрокаТаблицыМетаОбъектов Из СтрокиМетаОбъектов Цикл
		Единственное = СтрокаТаблицыМетаОбъектов.Единственное;
		Если Ложь
			Или Единственное = "Последовательность"
			Или Единственное = "КритерийОтбора"
			Или Единственное = "ЖурналДокументов"
			Или ЛксЛиКорневойТипОбъектаБД(Единственное)
			Или ЛксЛиКорневойТипРегистраБД(Единственное)
		Тогда
			КоллекцияКорневыхТипов.Добавить(Единственное);
		КонецЕсли;
	КонецЦикла;
	Если ирКэш.Получить().ВерсияПлатформы >= 802014 Тогда
		Для Каждого МетаВнешнийИсточникДанных Из Метаданные.ВнешниеИсточникиДанных Цикл
			КоллекцияКорневыхТипов.Добавить(МетаВнешнийИсточникДанных);
		КонецЦикла; 
	КонецЕсли; 
	ДобавитьДоступнуюТаблицу1С("Константы");
	КоллекцияКорневыхТипов.Добавить("Константа");
	мСтрокаТипаВнешнегоИсточникаДанных = мПлатформа.ПолучитьСтрокуТипаМетаОбъектов("ВнешнийИсточникДанных", , 0);
	Для Каждого КорневойТип Из КоллекцияКорневыхТипов Цикл
		СтрокаКорневогоТипа = мПлатформа.ПолучитьСтрокуТипаМетаОбъектов(КорневойТип);
		Если СтрокаКорневогоТипа = Неопределено Тогда
			СтрокаКорневогоТипа = мСтрокаТипаВнешнегоИсточникаДанных;
			МножественноеКорневогоТипа = СтрокаКорневогоТипа.Множественное;
			КоллекцияМетаданных = Метаданные.ВнешниеИсточникиДанных[КорневойТип.Имя].Таблицы;
			ПредставлениеКатегории = КорневойТип.Представление();
			СхемаТаблиц = "ВнешнийИсточникДанных." + КорневойТип.Имя;
		Иначе
			МножественноеКорневогоТипа = СтрокаКорневогоТипа.Множественное;
			КоллекцияМетаданных = Метаданные[МножественноеКорневогоТипа];
			ПредставлениеКатегории = ЛксПолучитьПредставлениеИзИдентификатора(МножественноеКорневогоТипа);
			СхемаТаблиц = "";
		КонецЕсли; 
		Если КоллекцияМетаданных.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		Для Каждого МетаИсточник Из КоллекцияМетаданных Цикл
			ПолноеИмяМД = МетаИсточник.ПолноеИмя();
			//Если ДоступныеОбъектыТипа <> Неопределено Тогда
			//	Если ДоступныеОбъектыТипа[НРег(МетаИсточник.Имя)] = Неопределено Тогда
			//		Продолжить;
			//	КонецЕсли; 
			//КонецЕсли;
			//
			ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД, ЛксПолучитьПервыйФрагмент(ПолноеИмяМД), МетаИсточник.Имя, СхемаТаблиц);
			Если ЛксЛиКорневойТипОбъектаБД(КорневойТип) Тогда
				СтруктураТЧ = ирНеглобальный.ПолучитьТабличныеЧастиОбъектаЛкс(МетаИсточник);
				Для Каждого КлючИЗначение Из СтруктураТЧ Цикл
					ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + "." + КлючИЗначение.Ключ, "ТабличнаяЧасть");
				КонецЦикла;
			КонецЕсли; 
			Если ирНеглобальный.ЕстьТаблицаИзмененийОбъектаМетаданных(МетаИсточник) Тогда
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".Изменения", "Изменения");
			КонецЕсли;
			Если КорневойТип = "РегистрСведений" Тогда 
				Если МетаИсточник.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
					ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".СрезПоследних", "ВиртуальнаяТаблица");
				КонецЕсли;
			ИначеЕсли КорневойТип = "РегистрНакопления" Тогда 
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".Обороты", "ВиртуальнаяТаблица");
				Если МетаИсточник.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
					ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".Остатки", "ВиртуальнаяТаблица");
					ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".ОстаткиИОбороты", "ВиртуальнаяТаблица");
				КонецЕсли;
			ИначеЕсли КорневойТип = "РегистрБухгалтерии" Тогда 
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".Обороты", "ВиртуальнаяТаблица");
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".ОборотыДтКт", "ВиртуальнаяТаблица");
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".ДвиженияССубконто", "ВиртуальнаяТаблица");
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".Остатки", "ВиртуальнаяТаблица");
				ДобавитьДоступнуюТаблицу1С(ПолноеИмяМД + ".ОстаткиИОбороты", "ВиртуальнаяТаблица");
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	ЭлементыФормы.ДоступныеТаблицы.Колонки.Тип.Видимость = Истина;
	ТекущаяСтрокаУстановлена = Ложь;
	Если КлючТекущейСтроки <> Неопределено Тогда
		НоваяТекущаяСтрока = ДоступныеТаблицы.Найти(КлючТекущейСтроки, "ПолноеИмяОбъекта", Истина);
		Если НоваяТекущаяСтрока <> Неопределено Тогда
			ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока = НоваяТекущаяСтрока;
			ТекущаяСтрокаУстановлена = Истина;
		КонецЕсли; 
	КонецЕсли;
	ЭтотОбъект.мДоступныеТаблицыКонфигурации = ДоступныеТаблицы.Выгрузить();
	ОчиститьДоступныеВременныеТаблицы(ЭтотОбъект.мДоступныеТаблицыКонфигурации);
	
КонецПроцедуры

Функция ДобавитьДоступнуюТаблицу1С(ПолноеИмя, ТипТаблицы = "", Имя = "", СхемаТаблицы = "", ПородившийЗапрос = 0)
	
	Фрагменты = ЛксПолучитьМассивИзСтрокиСРазделителем(ПолноеИмя);
	Если Фрагменты.Количество() > 1 Тогда
		Если Не ЗначениеЗаполнено(СхемаТаблицы) Тогда
			СхемаТаблицы = Фрагменты[0];
		КонецЕсли; 
		Фрагменты.Удалить(0);
	КонецЕсли;
	СтрокаТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмя), "НПолноеИмя");
	Если СтрокаТаблицы = Неопределено Тогда
		СтрокаТаблицы = ДоступныеТаблицы.Добавить();
		СтрокаТаблицы.Схема = СхемаТаблицы;
		СтрокаТаблицы.ПолноеИмя = ПолноеИмя;
		СтрокаТаблицы.НПолноеИмя = НРег(СтрокаТаблицы.ПолноеИмя);
		Если Не ЗначениеЗаполнено(Имя) Тогда
			СтрокаТаблицы.Имя = ЛксПолучитьСтрокуСРазделителемИзМассива(Фрагменты, ".");
		Иначе
			СтрокаТаблицы.Имя = Имя;
		КонецЕсли; 
		Если Не ЗначениеЗаполнено(ТипТаблицы) Тогда
			ТипТаблицы = ирНеглобальный.ПолучитьТипТаблицыБДЛкс(ПолноеИмя);
		КонецЕсли; 
		СтрокаТаблицы.Тип = ТипТаблицы;
		//СтрокаТаблицы.Описание = МетаИсточник.Представление();
	КонецЕсли; 
	СтрокаТаблицы.ПородившийЗапрос = ПородившийЗапрос;

КонецФункции

Функция ПолучитьДоступныеПоляТаблицы(ИмяИлиСтрокаВыбраннойТаблицы, ЧастьОбъединения = Неопределено)
	
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	Если ТипЗнч(ИмяИлиСтрокаВыбраннойТаблицы) = Тип("Строка") Тогда
		ВыбраннаяТаблица = ЧастьОбъединения.ВыбранныеТаблицы.Найти(НРег(ИмяИлиСтрокаВыбраннойТаблицы), "НИмя");
		Если ВыбраннаяТаблица = Неопределено Тогда
			ВызватьИсключение "Выбранная таблица """ + ИмяИлиСтрокаВыбраннойТаблицы+ """ не найдена";
		КонецЕсли; 
	Иначе
		ВыбраннаяТаблица = ИмяИлиСтрокаВыбраннойТаблицы;
	КонецЕсли; 
	ДоступныеПоляТаблицы = Новый ТаблицаЗначений;
	ДоступныеПоляТаблицы.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	ДоступныеПоляТаблицы.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
	ДоступныеПоляТаблицы.Колонки.Добавить("Поле", Новый ОписаниеТипов("Строка"));
	ДоступныеПоляТаблицы.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
	СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ВыбраннаяТаблица.ПолноеИмя), "НПолноеИмя");
	Если СтрокаДоступнойТаблицы <> Неопределено Тогда
		ПоляТаблицы = ПолучитьПоляДоступнойТаблицы(СтрокаДоступнойТаблицы);
	ИначеЕсли ВыбраннаяТаблица.ВложенныйПакет <> Неопределено Тогда
		ПоляТаблицы = ВыбраннаяТаблица.ВложенныйПакет[0].ЧастиОбъединения[0].ВыбранныеПоля;
		//СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения; // Здесь еще надо тип вычислять
	КонецЕсли;
	Если ПоляТаблицы <> Неопределено Тогда
		Для Каждого СтрокаПоля Из ПоляТаблицы Цикл
			СтрокаДоступногоПоля = ДоступныеПоляТаблицы.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаДоступногоПоля, СтрокаПоля); 
			ИмяПоля = СтрокаПоля.Имя;
			Если Не ЛксЛиИмяПеременной(ИмяПоля) Тогда
				ИмяПоля = "[" + ИмяПоля + "]";
			КонецЕсли; 
			СтрокаДоступногоПоля.Имя = СтрокаПоля.Имя;
			ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаДоступногоПоля);
			СтрокаДоступногоПоля.Поле = ИмяПоля;
			Если ЗначениеЗаполнено(ВыбраннаяТаблица.Имя) Тогда
				СтрокаДоступногоПоля.Поле = ВыбраннаяТаблица.Имя + "." + СтрокаДоступногоПоля.Поле;
			КонецЕсли; 
		КонецЦикла;
	КонецЕсли; 
	Возврат ДоступныеПоляТаблицы;

КонецФункции

Функция ПолучитьПоляДоступнойТаблицы(СтрокаДоступнойТаблицы)
	
	ПолноеИмяТаблицы = СтрокаДоступнойТаблицы.ПолноеИмя;
	ТаблицаПолей = Новый ТаблицаЗначений;
	ТаблицаПолей.Колонки.Добавить("Имя", Новый ОписаниеТипов("Строка"));
	ТаблицаПолей.Колонки.Добавить("ТипЗначения", Новый ОписаниеТипов("ОписаниеТипов"));
	Если СтрокаДоступнойТаблицы.Тип = "ВременнаяТаблица" Тогда
		ПородившийЗапрос = ЗапросыПакета.Найти(СтрокаДоступнойТаблицы.ПородившийЗапрос, "ИД");
		КолонкиРезультата = Новый Массив();
		Если ПородившийЗапрос <> Неопределено Тогда
			КолонкиРезультата = ПородившийЗапрос.ЧастиОбъединения[0].ВыбранныеПоля;
		Иначе
			ТекстЗапроса = "SELECT * FROM " + ПолноеИмяТаблицы + " WHERE FALSE";
			Если ТипЗнч(КонтекстВыполнения) = Тип("Запрос") Тогда
				ВременныйЗапрос = Новый Запрос;
				ВременныйЗапрос.МенеджерВременныхТаблиц = КонтекстВыполнения.МенеджерВременныхТаблиц;
				ВременныйЗапрос.Текст = ТекстЗапроса;
				РезультатВременногоЗапроса = Неопределено;
				Попытка
					РезультатВременногоЗапроса = ВременныйЗапрос.Выполнить();
				Исключение
				КонецПопытки;
				Если РезультатВременногоЗапроса <> Неопределено Тогда
					КолонкиРезультата = РезультатВременногоЗапроса.Колонки;
				КонецЕсли;
			ИначеЕсли ирНеглобальный.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
				//
			Иначе // ADO
				Попытка
					РезультатВременногоЗапроса = Конфигурация.Execute(ТекстЗапроса);
				Исключение
				КонецПопытки;
				Если РезультатВременногоЗапроса <> Неопределено Тогда
					РезультатТаблица = Новый ТаблицаЗначений;
					ирНеглобальный.ПолучитьКолонкиRecordsetADOЛкс(РезультатТаблица, РезультатВременногоЗапроса, Истина);
					КолонкиРезультата = РезультатТаблица.Колонки;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		Для Каждого ВыбранноеПоле Из КолонкиРезультата Цикл
			СтрокаПоля = ТаблицаПолей.Добавить();
			СтрокаПоля.Имя = ВыбранноеПоле.Имя;
			СтрокаПоля.ТипЗначения = ВыбранноеПоле.ТипЗначения;
		КонецЦикла;
	ИначеЕсли ТипЗнч(Конфигурация) = Тип("ОбъектМетаданныхКонфигурация") Тогда
		КомпоновщикТаблицы = ирКэш.ПолучитьКомпоновщикТаблицыМетаданныхЛкс(ПолноеИмяТаблицы, Ложь);
		Если КомпоновщикТаблицы <> Неопределено Тогда
			Для Каждого ДоступноеПоле Из КомпоновщикТаблицы.Настройки.ДоступныеПоляВыбора.Элементы Цикл
				Если ДоступноеПоле.Папка Тогда
					Продолжить;
				КонецЕсли; 
				СтрокаПоля = ТаблицаПолей.Добавить();
				СтрокаПоля.Имя = ДоступноеПоле.Поле;
				СтрокаПоля.ТипЗначения = ДоступноеПоле.ТипЗначения;
			КонецЦикла;
		КонецЕсли; 
	Иначе
		СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ПолноеИмяТаблицы), "НПолноеИмя");
		Если ирНеглобальный.СтрокиРавныЛкс(ДиалектSQL, "WQL") Тогда
			wbemFlagUseAmendedQualifiers = 131072; //&H20000
			ОписаниеКласса = Конфигурация.Get(СтрокаДоступнойТаблицы.Имя, wbemFlagUseAmendedQualifiers);
			ТаблицаКласса = Новый ТаблицаЗначений;
			МассивКоллекцийСвойств = Новый Массив();
			МассивКоллекцийСвойств.Добавить(ОписаниеКласса.Properties_);
			//Если СобиратьСистемныеСвойстваWMI Тогда
			//	МассивКоллекцийСвойств.Добавить(ОписаниеКласса.SystemProperties_);
			//КонецЕсли; 
			Для Каждого КоллекцияСвойств Из МассивКоллекцийСвойств Цикл
				Для Каждого Свойство Из КоллекцияСвойств Цикл
					ИмяТипа = ирНеглобальный.ПолучитьИмяТипаИзКвалификаторовWMIЛкс(Свойство);
					Попытка
						ОписаниеТипов = Новый ОписаниеТипов(ИмяТипа,,,, Новый КвалификаторыСтроки(1024)); // Доделать распознавание типов
					Исключение
						ОписаниеТипов = Новый ОписаниеТипов();
					КонецПопытки;
					ПредставлениеСвойства = ирНеглобальный.ПолучитьОписаниеЭлементаWMIЛкс(Свойство, "DisplayName");
					ТаблицаКласса.Колонки.Добавить(, ОписаниеТипов, ПредставлениеСвойства);
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = Свойство.Name;
					СтрокаПоля.ТипЗначения = ОписаниеТипов;
					//СтрокаПоля.Описание = ПредставлениеСвойства;
				КонецЦикла;
			КонецЦикла;
		Иначе // ADO
			Фильтры = Новый Массив();
			Фильтры.Добавить(); //TABLE_CATALOG
			Если ЗначениеЗаполнено(СтрокаДоступнойТаблицы.Схема) Тогда //TABLE_SCHEMA
				Фильтры.Добавить(СтрокаДоступнойТаблицы.Схема);
			Иначе
				Фильтры.Добавить(Неопределено);
			КонецЕсли; 
			Фильтры.Добавить(СтрокаДоступнойТаблицы.Имя); // TABLE_NAME
			Фильтры = Новый COMSafeArray(Фильтры, "VT_VARIANT");
			Состояние("Запрашиваем поля " + ПолноеИмяТаблицы + "...");
			ОписаниеПолейRecordSet = Конфигурация.OpenSchema(4, Фильтры); //adSchemaColumns
			ADOUtils = мПлатформа.ПолучитьADOUtils();
			Если ADOUtils <> Неопределено Тогда
				ОписаниеПолейТЗ = ADOUtils.ADORecordsetToValueTable(ОписаниеПолейRecordSet);
				Для Каждого СтрокаТЗ Из ОписаниеПолейТЗ Цикл
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = СтрокаТЗ.COLUMN_NAME;
					ЧисловаяРазрядность = СтрокаТЗ.NUMERIC_SCALE;
					ДлинаТипа = СтрокаТЗ.CHARACTER_MAXIMUM_LENGTH;
					ЧисловаяТочность = СтрокаТЗ.NUMERIC_PRECISION;
					НомерТипа = СтрокаТЗ.DATA_TYPE;
					FieldADO = ирНеглобальный.FieldADO(СтрокаПоля.Имя, НомерТипа, ДлинаТипа, ЧисловаяТочность, ЧисловаяРазрядность);
					СтрокаПоля.ТипЗначения = ирНеглобальный.FieldADO_ПолучитьТип1C(FieldADO);
				КонецЦикла;
			Иначе
				Пока Не ОписаниеПолейRecordSet.EOF() Цикл
					СтрокаПоля = ТаблицаПолей.Добавить();
					СтрокаПоля.Имя = ОписаниеПолейRecordSet.Fields("COLUMN_NAME").Value;
					ЧисловаяРазрядность = ОписаниеПолейRecordSet.Fields("NUMERIC_SCALE").Value;
					ДлинаТипа = ОписаниеПолейRecordSet.Fields("CHARACTER_MAXIMUM_LENGTH").Value;
					ЧисловаяТочность = ОписаниеПолейRecordSet.Fields("NUMERIC_PRECISION").Value;
					НомерТипа = ОписаниеПолейRecordSet.Fields("DATA_TYPE").Value;
					FieldADO = ирНеглобальный.FieldADO(СтрокаПоля.Имя, НомерТипа, ДлинаТипа, ЧисловаяТочность, ЧисловаяРазрядность);
					СтрокаПоля.ТипЗначения = ирНеглобальный.FieldADO_ПолучитьТип1C(FieldADO);
					ОписаниеПолейRecordSet.MoveNext();
				КонецЦикла;
			КонецЕсли; 
		КонецЕсли; 
		Состояние();
	КонецЕсли; 
	Возврат ТаблицаПолей;
	
КонецФункции

Процедура ОбновлениеОтображения()
	
	ЛксОбновитьЗаголовкиСтраницПанелей(ЭтаФорма);
	Если ПараметрыДиалектаSQL <> Неопределено Тогда
		ЭлементыФормы.ВыбранныеТаблицыПанельЭлемента.Доступность = ЭлементыФормы.ВыбранныеТаблицы.Значение.Количество() > 0;
		ЭлементыФормы.ВыбранныеПоляПанельЭлемента.Доступность = ЭлементыФормы.ВыбранныеПоля.Значение.Количество() > 0;
		ЭлементыФормы.СвязиТаблицПанельЭлемента.Доступность = ЭлементыФормы.СвязиТаблиц.Значение.Количество() > 0;
		ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.Доступность = ЭлементыФормы.ДеревоУсловияСвязи.Значение.Элементы.Количество() > 0;
		ЭлементыФормы.РежимОбъединения.Доступность = Истина
			И ПараметрыДиалектаSQL.Объединения 
			И ЧастиОбъединения.Количество() = 1;
		ЭлементыФормы.ЛиПакетныйЗапрос.Доступность = Истина
			И ПараметрыДиалектаSQL.Пакет 
			И ЗапросыПакета.Количество() = 1;
		ЭлементыФормы.ИмяВременнойТаблицы.Доступность = Ложь
			Или ТипЗапроса = 1
			Или ТипЗапроса = 2;
		ЭлементыФормы.КомментарийОтбора.Доступность = ТипЗапроса <> 2;
		ЭлементыФормы.ОпцияПервые.Доступность = Истина
			И ПараметрыДиалектаSQL.Первые 
			И ТипЗапроса <> 2;
		ЭлементыФормы.ПервыеКоличество.Доступность = Истина
			И ПараметрыДиалектаSQL.Первые
			И ТипЗапроса <> 2;
		ЭлементыФормы.ОпцияРазрешенные.Доступность = Истина
			И ПараметрыДиалектаSQL.Это1С
			И ТипЗапроса <> 2;
		//Если ТипЗапроса = 2 Тогда
		//	Если Истина
		//		И ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения
		//		И ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> ЭлементыФормы.ПанельОсновная.Страницы.Текст
		//	Тогда
		//		ЭлементыФормы.ПанельОсновная.ТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения;
		//	КонецЕсли; 
		//	Если Истина
		//		И ЭлементыФормы.ПанельЧасти.ТекущаяСтраница <> ЭлементыФормы.ПанельЧасти.Страницы.КомментарийЧасти
		//	Тогда
		//		ЭлементыФормы.ПанельЧасти.ТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.КомментарийЧасти;
		//	КонецЕсли; 
		//КонецЕсли; 
		ЭлементыФормы.ПанельОсновная.Страницы.ПоляИндекса.Видимость = ТипЗапроса = 1;
		ЭлементыФормы.ПанельОсновная.Страницы.ПоляПорядка.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельОсновная.Страницы.Параметры.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельОсновная.Страницы.Итоги.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельОсновная.Страницы.ПоляОбъединения.Видимость = Истина
			И ПараметрыДиалектаSQL.Объединения 
			И ЧастиОбъединения.Количество() > 1;
		ЭлементыФормы.ПанельЧасти.Страницы.СвязиТаблиц.Видимость = ВыбранныеТаблицы.Количество() > 1;
		ЭлементыФормы.ПанельЧасти.Страницы.ВыбранныеПоля.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельЧасти.Страницы.ВыбранныеТаблицы.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельЧасти.Страницы.ДеревоУсловия.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельЧасти.Страницы.Группировки.Видимость = ТипЗапроса <> 2;
		ЭлементыФормы.ПанельЧасти.Страницы.Текст.Видимость = ТипЗапроса <> 2;
	КонецЕсли; 

КонецПроцедуры

Функция ПриВыводеСтрокиДоступныхТаблицСвязи(ОформлениеСтроки, ДанныеСтроки)

	ТаблицаДобавленаВСвязи = Ложь
		Или СвязиТаблиц.Найти(ДанныеСтроки.Имя, "ЛеваяТаблица") <> Неопределено 
		Или СвязиТаблиц.Найти(ДанныеСтроки.Имя, "ПраваяТаблица") <> Неопределено;
	Если ТаблицаДобавленаВСвязи Тогда
		ОформлениеСтроки.ЦветТекста = ЦветаСтиля.ирТекстИнформационнойНадписи;
	КонецЕсли; 
	Возврат Неопределено;

КонецФункции

Процедура СвязиТаблицПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если НоваяСтрока Тогда
		Если СвязиТаблиц.Количество() = 1 Тогда
			Элемент.ТекущиеДанные.ЛеваяТаблица = ВыбранныеТаблицы[0].Имя;
			Элемент.ТекущиеДанные.ПраваяТаблица = ВыбранныеТаблицы[1].Имя;
		Иначе
			Элемент.ТекущиеДанные.ЛеваяТаблица = СвязиТаблиц[0].ЛеваяТаблица;
			ДобавленныеТаблицыСвязей = СвязиТаблиц.ВыгрузитьКолонку("ЛеваяТаблица");
			Для Каждого ИмяТаблицы Из СвязиТаблиц.ВыгрузитьКолонку("ПраваяТаблица") Цикл
				ДобавленныеТаблицыСвязей.Добавить(ИмяТаблицы);
			КонецЦикла;
			Для Каждого ВыбраннаяТаблица Из ВыбранныеТаблицы Цикл
				Если ДобавленныеТаблицыСвязей.Найти(ВыбраннаяТаблица.Имя) = Неопределено Тогда
					Элемент.ТекущиеДанные.ПраваяТаблица = ВыбраннаяТаблица.Имя;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не ЗначениеЗаполнено(Элемент.ТекущиеДанные.ПраваяТаблица) Тогда
				ЗаполнитьЗначенияСвойств(Элемент.ТекущиеДанные, СвязиТаблиц[СвязиТаблиц.Количество() - 2], "ПраваяТаблица, ВсеСтрокиЛевой, ВсеСтрокиПравой"); 
			КонецЕсли; 
		КонецЕсли; 
		Элемент.ТекущиеДанные.Условие = Новый НастройкиКомпоновкиДанных;
		ЭлементОтбора = Элемент.ТекущиеДанные.Условие.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЗагрузитьСвязьТаблицы();
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыборЛевойТаблицыСвязиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ПриВыводеСтрокиДоступныхТаблицСвязи(ОформлениеСтроки, ДанныеСтроки);
	ВыбранныеТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ВыборПравойТаблицыСвязиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ПриВыводеСтрокиДоступныхТаблицСвязи(ОформлениеСтроки, ДанныеСтроки);
	ВыбранныеТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ВыбранныеТаблицыИмяПриИзменении(Элемент)
	
	ЗакончитьРедактированиеСвязанныхПолей();
	ПереименоватьВыбраннуюТаблицу();
	ЗагрузитьВыражениеУсловия();
	ЗагрузитьВыражениеУсловияСвязи();
	ЗагрузитьПараметрТаблицы();
	ЗагрузитьВыбранноеПоле();
	ЗагрузитьСвязьТаблицы();
	ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(мТекущаяСтрокаВыбранныеТаблицы);
	
КонецПроцедуры

Процедура ПереименоватьВыбраннуюТаблицу()
	
	НовоеИмяТаблицы = мТекущаяСтрокаВыбранныеТаблицы.Имя;
	//Если ирНеглобальный.СтрокиРавныЛкс(мТекущееИмяТаблицы, НовоеИмяТаблицы)  Тогда
	Если мТекущееИмяТаблицы = НовоеИмяТаблицы Тогда
		Возврат;
	КонецЕсли; 
	Состояние("Обновление выражений...");
	ЧастьОбъединения = мТекущаяСтрокаЧастиОбъединения;
	Для Каждого ВыбранноеПоле Из ЧастьОбъединения.ВыбранныеПоля Цикл
		ОбновитьВыражениеЗапроса(ВыбранноеПоле, ЭлементыФормы.ВыбранныеПоля, , ЧастьОбъединения, мТекущееИмяТаблицы, НовоеИмяТаблицы);
	КонецЦикла;
	Для Каждого ПолеГруппировки Из ЧастьОбъединения.Группировки Цикл
		ОбновитьВыражениеЗапроса(ПолеГруппировки, ЭлементыФормы.Группировки, , ЧастьОбъединения, мТекущееИмяТаблицы, НовоеИмяТаблицы);
	КонецЦикла;
	Для Каждого СвязьТаблиц Из ЧастьОбъединения.СвязиТаблиц Цикл
		ОбновитьВыраженияОтбора(СвязьТаблиц.Условие.Отбор, ЭлементыФормы.ДеревоУсловияСвязи, , ЧастьОбъединения, мТекущееИмяТаблицы, НовоеИмяТаблицы);
		Если ирНеглобальный.СтрокиРавныЛкс(СвязьТаблиц.ЛеваяТаблица, мТекущееИмяТаблицы) Тогда
			СвязьТаблиц.ЛеваяТаблица = НовоеИмяТаблицы;
		КонецЕсли; 
		Если ирНеглобальный.СтрокиРавныЛкс(СвязьТаблиц.ПраваяТаблица, мТекущееИмяТаблицы) Тогда
			СвязьТаблиц.ПраваяТаблица = НовоеИмяТаблицы;
		КонецЕсли; 
	КонецЦикла;
	ОбновитьВыраженияОтбора(ЧастьОбъединения.Условие.Отбор, ЭлементыФормы.ДеревоУсловия, , ЧастьОбъединения, мТекущееИмяТаблицы, НовоеИмяТаблицы);
	Для Каждого ПолеПорядка Из мТекущаяСтрокаЗапросыПакета.ПоляПорядка Цикл
		ОбновитьВыражениеЗапроса(ПолеПорядка, ЭлементыФормы.ПоляПорядка,,,,,,, Ложь);
	КонецЦикла;
	//Для Каждого ГруппируемоеПолеИтогов Из ЗапросПакета.ГруппируемыеПоляИтогов Цикл
	//	ОбновитьВыражениеЗапроса(ГруппируемоеПолеИтогов);
	//КонецЦикла;
	//Для Каждого ГруппирующееПолеИтогов Из ЗапросПакета.ГруппирующиеПоляИтогов Цикл
	//	ОбновитьВыражениеЗапроса(ГруппирующееПолеИтогов);
	//КонецЦикла;
	Состояние("");

КонецПроцедуры


Процедура ДоступныеПоляЛевогоПоляПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрокаУсловияСвязи = ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока;
	Если Истина
		И ТекущаяСтрокаУсловияСвязи <> Неопределено
		И Не Элемент.ТекущаяСтрока.Папка
		И ТипЗнч(ТекущаяСтрокаУсловияСвязи) = Тип("ЭлементОтбораКомпоновкиДанных")
	Тогда
		ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока.ЛевоеЗначение = Элемент.ТекущаяСтрока.Поле;
	КонецЕсли; 

КонецПроцедуры

Процедура ДоступныеПоляПравогоПоляПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрокаУсловияСвязи = ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока;
	Если Истина
		И ТекущаяСтрокаУсловияСвязи <> Неопределено
		И Не Элемент.ТекущаяСтрока.Папка
		И ТипЗнч(ТекущаяСтрокаУсловияСвязи) = Тип("ЭлементОтбораКомпоновкиДанных")
	Тогда
		ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока.ПравоеЗначение = Элемент.ТекущаяСтрока.Поле;
	КонецЕсли; 

КонецПроцедуры

Процедура ВыборЛевойТаблицыСвязиПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрокаСвязи = ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока;
	Если ТекущаяСтрокаСвязи <> Неопределено Тогда
		Если ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока.ЛеваяТаблица <> Элемент.ТекущаяСтрока.Имя Тогда
			ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока.ЛеваяТаблица = Элемент.ТекущаяСтрока.Имя;
			//ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока, "ЛеваяТаблица");
			ПриУстановкеЛевойТаблицыСвязи();
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура ПриУстановкеЛевойТаблицыСвязи()
	
	// Надо раскрыть ветвь ее доступных полей
	
КонецПроцедуры

Процедура ВыборПравойТаблицыСвязиПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрокаСвязи = ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока;
	Если ТекущаяСтрокаСвязи <> Неопределено Тогда
		Если ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока.ПраваяТаблица <> Элемент.ТекущаяСтрока.Имя Тогда
			ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока.ПраваяТаблица = Элемент.ТекущаяСтрока.Имя;
			//ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ЭлементыФормы.СвязиТаблиц.ТекущаяСтрока, "ПраваяТаблица");
			ПриУстановкеПравойТаблицыСвязи();
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура ПриУстановкеПравойТаблицыСвязи()
	
	// Надо раскрыть ветвь ее доступных полей
	
КонецПроцедуры

Процедура СвязиТаблицПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ДанныеСтроки.Условие <> Неопределено Тогда
		ОформлениеСтроки.Ячейки.Условие.УстановитьТекст(ДанныеСтроки.Условие.Отбор);
	КонецЕсли; 
	ОформлениеСтроки.Ячейки.Номер.Значение = СвязиТаблиц.Индекс(ДанныеСтроки) + 1;
	ОформитьЯчейкуИмениТаблицы(Элемент, ОформлениеСтроки, ДанныеСтроки, "ЛеваяТаблица");
	ОформитьЯчейкуИмениТаблицы(Элемент, ОформлениеСтроки, ДанныеСтроки, "ПраваяТаблица");
	
КонецПроцедуры

Процедура СохранитьВыбранноеПоле()
	
	Если мТекущаяСтрокаВыбранногоПоля = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если ВыбранныеПоля.Индекс(мТекущаяСтрокаВыбранногоПоля) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	мТекущаяСтрокаВыбранногоПоля.Определение = ЭлементыФормы.ВыражениеВыбранногоПоля.ПолучитьТекст();
	ПриИзмененииВыраженияВыбранногоПоля(мТекущаяСтрокаВыбранногоПоля);
	
КонецПроцедуры

Процедура ПриИзмененииВыраженияВыбранногоПоля(ВыбранноеПоле = Неопределено, ЗапросПакета = Неопределено, ЧастьОбъединения = Неопределено,
	ОбновитьПоляОбъединения = Истина)

	Если ВыбранноеПоле = Неопределено Тогда
		ВыбранноеПоле = мТекущаяСтрокаВыбранногоПоля;
	КонецЕсли; 
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	ЕстьАгрегаты = Ложь;
	ОбновитьВыражениеЗапроса(ВыбранноеПоле,,,,,,, ЕстьАгрегаты);
	ВыбранноеПоле.ТипЗначения = ПолучитьТипЗначенияВыражения(ВыбранноеПоле.Токен, ЧастьОбъединения);
	ВыбранноеПоле.АгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(ВыбранноеПоле.Токен);
	ВыбранноеПоле.ЕстьАгрегаты = ЕстьАгрегаты;
	Если мТекущаяСтрокаВыбранногоПоля = ВыбранноеПоле Тогда
		ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст(мТекущаяСтрокаВыбранногоПоля.Определение);
	КонецЕсли; 
	ОбновитьГруппировки();
	Если ОбновитьПоляОбъединения Тогда
		ОбновитьПоляОбъединенияЗапроса(ЗапросПакета);
	КонецЕсли; 

КонецПроцедуры

Процедура ОбновитьГруппировки()
	
	ЭлементыФормы.ВыбранныеПоля.Колонки.Группировка.ТолькоПросмотр = Автогруппировки;
	ЭлементыФормы.Группировки.ТолькоПросмотр = Автогруппировки;
	Если Автогруппировки Тогда
		КопияГруппировок = Группировки.Скопировать();
		Группировки.Очистить();
		ЕстьАгрегаты = ВыбранныеПоля.Найти(Истина, "ЕстьАгрегаты") <> Неопределено;
		Если ЕстьАгрегаты Тогда
			Для Каждого ВыбранноеПоле Из ВыбранныеПоля Цикл
				Если ВыбранноеПоле.ЕстьАгрегаты Тогда
					Продолжить;
				КонецЕсли; 
				Группировка = Группировки.Найти(ВыбранноеПоле.Определение, "Определение");
				Если Группировка = Неопределено Тогда
					Группировка = Группировки.Добавить();
					Группировка.Определение = ВыбранноеПоле.Определение;
					Группировка.Токен = ВыбранноеПоле.Токен; // !Опасно
					СтрокаКопииГруппировки = КопияГруппировок.Найти(ВыбранноеПоле.Определение, "Определение"); // Чувствительность к регистру!
					Если СтрокаКопииГруппировки <> Неопределено Тогда
						Группировка.Комментарий = СтрокаКопииГруппировки.Комментарий;
					КонецЕсли; 
				КонецЕсли;
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура СохранитьВыражениеУсловияСвязи()
	
	Если Ложь 
		Или мТекущаяСтрокаУсловияСвязи = Неопределено 
		Или ТипЗнч(мТекущаяСтрокаУсловияСвязи) = Тип("ОтборКомпоновкиДанных")
	Тогда
		Возврат;
	КонецЕсли; 
	Родитель = ирНеглобальный.ПолучитьРодителяСтрокиДереваЛкс(мТекущаяСтрокаУсловияСвязи, КомпоновщикУсловияСвязи.Настройки.Отбор);
	Если Родитель.Элементы.Индекс(мТекущаяСтрокаУсловияСвязи) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	Если Не ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.Выражение.Доступность Тогда
		Возврат;
	КонецЕсли; 
	мТекущаяСтрокаУсловияСвязи.Представление = ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.ПолучитьТекст();
	//ОбновитьВыражениеЗапроса(мТекущаяСтрокаУсловияСвязи, ЭлементыФормы.ДеревоУсловияСвязи);
	ОбновитьВыражениеЗапроса(мТекущаяСтрокаУсловияСвязи);
	
КонецПроцедуры

Процедура СохранитьВыражениеУсловия()
	
	Если Ложь 
		Или мТекущаяСтрокаУсловия = Неопределено 
		Или ТипЗнч(мТекущаяСтрокаУсловия) = Тип("ОтборКомпоновкиДанных")
	Тогда
		Возврат;
	КонецЕсли; 
	Родитель = ирНеглобальный.ПолучитьРодителяСтрокиДереваЛкс(мТекущаяСтрокаУсловия, КомпоновщикЧасти.Настройки.Отбор);
	Если Родитель.Элементы.Индекс(мТекущаяСтрокаУсловия) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	Если Не ЭлементыФормы.ВыражениеЭлементаУсловия.Доступность Тогда
		Возврат;
	КонецЕсли;
	мТекущаяСтрокаУсловия.Представление = ЭлементыФормы.ВыражениеЭлементаУсловия.ПолучитьТекст();
	//ОбновитьВыражениеЗапроса(мТекущаяСтрокаУсловия, ЭлементыФормы.ДеревоУсловия);
	ОбновитьВыражениеЗапроса(мТекущаяСтрокаУсловия);
	
КонецПроцедуры

Процедура СохранитьУсловиеСвязи()
	
	Если мТекущаяСтрокаСвязи = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если СвязиТаблиц.Индекс(мТекущаяСтрокаСвязи) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	СохранитьВыражениеУсловияСвязи();
	мТекущаяСтрокаСвязи.Условие = КомпоновщикУсловияСвязи.ПолучитьНастройки();
	
КонецПроцедуры

Процедура ДеревоУсловияСвязиПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьВыражениеУсловияСвязи();
	ЗагрузитьВыражениеУсловияСвязи();
	
КонецПроцедуры

Процедура ЗагрузитьВыражениеУсловияСвязи()

	мТекущаяСтрокаУсловияСвязи = ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока;
	Если ТипЗнч(мТекущаяСтрокаУсловияСвязи) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Если ТипЗнч(мТекущаяСтрокаУсловияСвязи.ЛевоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
			СтрокаВыбораЛевогоПоля = КомпоновщикУсловияСвязи.Настройки.ДоступныеПоляОтбора.НайтиПоле(мТекущаяСтрокаУсловияСвязи.ЛевоеЗначение);
			Если СтрокаВыбораЛевогоПоля <> Неопределено Тогда
				ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока = СтрокаВыбораЛевогоПоля;
			КонецЕсли; 
		КонецЕсли; 
		Если ТипЗнч(мТекущаяСтрокаУсловияСвязи.ПравоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
			СтрокаВыбораПравогоПоля = КомпоновщикУсловияСвязи.Настройки.ДоступныеПоляОтбора.НайтиПоле(мТекущаяСтрокаУсловияСвязи.ПравоеЗначение);
			Если СтрокаВыбораПравогоПоля <> Неопределено Тогда
				ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи.ТекущаяСтрока = СтрокаВыбораПравогоПоля;
			КонецЕсли; 
		КонецЕсли; 
		ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.УстановитьТекст(мТекущаяСтрокаУсловияСвязи.Представление);
		ЭлементыФормы.УсловиеСвязиПанельЭлемента.Доступность = Истина;
		Если мТекущаяСтрокаУсловияСвязи.Представление = "" Тогда
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.ВыборПолей.Доступность = Истина;
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.Выражение.Доступность = Ложь;
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.ТекущаяСтраница = ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.ВыборПолей;
		Иначе
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.Выражение.Доступность = Истина;
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.ВыборПолей.Доступность = Ложь;
			ЭлементыФормы.УсловиеСвязиПанельЭлемента.ТекущаяСтраница = ЭлементыФормы.УсловиеСвязиПанельЭлемента.Страницы.Выражение;
		КонецЕсли; 
	Иначе
		ЭлементыФормы.УсловиеСвязиПанельЭлемента.Доступность = Ложь;
		ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.УстановитьТекст("");
	КонецЕсли; 
	
КонецПроцедуры

Процедура УсловияПриАктивизацииСтроки(Элемент)
	
	СохранитьВыражениеУсловия();
	мТекущаяСтрокаУсловия = Элемент.ТекущаяСтрока;
	Если мТекущаяСтрокаУсловия <> Неопределено Тогда
		ЭлементыФормы.ВыражениеЭлементаУсловия.УстановитьТекст(мТекущаяСтрокаУсловия.Представление);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПередОкончаниемРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования, Отказ)
	
	Если Не ОтменаРедактирования Тогда
		Элемент.ТекущиеДанные.Имя = ирНеглобальный.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Элемент.Значение, Элемент.ТекущиеДанные,,, ПолучитьСловоЯзыкаЗапросов("Table"));
		ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(Элемент.ТекущиеДанные);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеПоляПередОкончаниемРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования, Отказ)
	
	Если Не ОтменаРедактирования Тогда
		Элемент.ТекущиеДанные.Имя = ирНеглобальный.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Элемент.Значение, Элемент.ТекущиеДанные,,,
			ПолучитьСловоЯзыкаЗапросов("Field"));
	КонецЕсли; 

КонецПроцедуры

Процедура ПодстрокаФильтраДоступныхТаблицОчистка(Элемент, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	Элемент.Значение = "";
	
КонецПроцедуры

Процедура ПодстрокаФильтраДоступныхТаблицПриИзменении(Элемент)
	
	ирНеглобальный.ПолеВводаСИсториейВыбора_ПриИзмененииЛкс(Элемент, Метаданные().Имя);
	ЭлементыФормы.ДоступныеТаблицы.ОтборСтрок.Имя.ВидСравнения = ВидСравнения.Содержит;
	ЭлементыФормы.ДоступныеТаблицы.ОтборСтрок.Имя.Использование = Истина;

КонецПроцедуры

Процедура ПодстрокаФильтраДоступныхТаблицНачалоВыбораИзСписка(Элемент, СтандартнаяОбработка)
	
	ирНеглобальный.ПолеВводаСИсториейВыбора_НачалоВыбораИзСпискаЛкс(Элемент, Метаданные().Имя);

КонецПроцедуры

Процедура ДоступныеТаблицыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ДобавитьДоступнуюТаблицуВВыбранные(ВыбраннаяСтрока);
	
КонецПроцедуры

Процедура ДоступныеПоляВыбораВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьДоступноеПолеСДочернимиВВыбранныеПоля(ВыбраннаяСтрока);
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	Если Не ПараметрыДиалектаSQL.МногоТаблиц Тогда
		Возврат;
	КонецЕсли; 
	ВложенныйПакет = ОткрытьВложенныйПакет();
	Если ВложенныйПакет <> Неопределено Тогда
		ИмяТаблицы = ирНеглобальный.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ВыбранныеТаблицы, "ВложенныйЗапрос","ВложенныйПакет");
		ВыбраннаяТаблица = ДобавитьВыбраннуюТаблицу();
		ВыбраннаяТаблица.ВложенныйПакет = ВложенныйПакет;
		ВыбраннаяТаблица.Имя = ИмяТаблицы;
		ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ВыбраннаяТаблица);
		Элемент.ТекущаяСтрока = ВыбраннаяТаблица;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеПоляПриАктивизацииСтроки(Элемент)
	
	СохранитьВыбранноеПоле();
	ЗагрузитьВыбранноеПоле();

КонецПроцедуры

Процедура ЗагрузитьВыбранноеПоле()

	мТекущаяСтрокаВыбранногоПоля = ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока;
	Если мТекущаяСтрокаВыбранногоПоля <> Неопределено Тогда
		ВыражениеПоля = мТекущаяСтрокаВыбранногоПоля.Определение;
		РазрешеноИзменение = Не мТекущаяСтрокаВыбранногоПоля.Автополе;
	Иначе
		ВыражениеПоля = "";
		РазрешеноИзменение = Ложь;
	КонецЕсли; 
	ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст(ВыражениеПоля);
	ЭлементыФормы.ВыражениеВыбранногоПоля.Доступность = РазрешеноИзменение;

КонецПроцедуры

Процедура ВыбранныеПоляПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ОформлениеСтроки.Ячейки.Группировка.ОтображатьФлажок = Истина;
	СтрокаГруппировки = Группировки.Найти(ДанныеСтроки.Определение, "Определение");
	Если СтрокаГруппировки <> Неопределено Тогда
		ОформлениеСтроки.Ячейки.Группировка.Флажок = Истина;
		ОформлениеСтроки.Ячейки.Группировка.ТолькоПросмотр = Ложь
			Или ДанныеСтроки.ЕстьАгрегаты
			Или ДанныеСтроки.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"));
	КонецЕсли;
	Если ДанныеСтроки.Автополе Тогда
		ОформлениеСтроки.ЦветФона = ЦветаСтиля.ирЦветФонаВычисляемогоЗначения;
	КонецЕсли; 
	ОформлениеСтроки.Ячейки.АгрегатнаяФункция.ТолькоПросмотр = Ложь
		Или ДанныеСтроки.Токен = Неопределено 
		Или ДанныеСтроки.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"))
		Или (Истина
			И ДанныеСтроки.ЕстьАгрегаты
			И ДанныеСтроки.АгрегатнаяФункция = Неопределено);
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);
	
КонецПроцедуры

Функция ПолучитьИндексКартинкиВыражения(ВыражениеИлиТокен, ЧастьОбъединения = Неопределено)
	
	ТипЗначения = ПолучитьТипЗначенияВыражения(ВыражениеИлиТокен, ЧастьОбъединения);
	ИндексКартинки = ирНеглобальный.ПолучитьИндексКартинкиТипаЛкс(ТипЗначения);
	Возврат ИндексКартинки;
	
КонецФункции

Функция ПолучитьТипЗначенияВыражения(ВыражениеИлиТокен, ЧастьОбъединения = Неопределено)

	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если ТипЗнч(ВыражениеИлиТокен) = Тип("Строка") Тогда
		Токен = РазобратьВыражениеЗапроса(ВыражениеИлиТокен);
	Иначе
		Токен = ВыражениеИлиТокен;
	КонецЕсли; 
	Если ТипЗнч(Токен) = Тип("COMОбъект") Тогда
		Если Токен.Kind = 0 Тогда
			ДанныеТокена = Токен.Data;
			ИмяПравила = ДанныеТокена.ParentRule.RuleNonterminal.Text;
			Если ИмяПравила = "<Field>" Тогда
				//ПолноеИмяПоля = ПолучитьТекстИзТокена(Токен);
				ПолноеИмяПоля = СобратьВыражениеЗапроса(Токен,,, ЧастьОбъединения);;
				//ПолеКомпоновки = Новый ПолеКомпоновкиДанных(ПолноеИмяПоля);
				//ДоступноеПоле = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.НайтиПоле(ПолеКомпоновки); // Так очень долго работает особенно для дочерних полей от многотипных полей
				Фрагменты = ЛксПолучитьМассивИзСтрокиСРазделителем(ПолноеИмяПоля);
				Если Фрагменты.Количество() = 2 Тогда // Это приемлемая плата за вспомогательную информацию, которой являются типы значений полей
					ДоступноеПолеТаблицы = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.Элементы.Найти(Фрагменты[0]);
					Если ДоступноеПолеТаблицы <> Неопределено Тогда
						ДоступноеПоле = ДоступноеПолеТаблицы.Элементы.Найти(ПолноеИмяПоля);
						Если ДоступноеПоле <> Неопределено Тогда
							Результат = ДоступноеПоле.ТипЗначения;
						КонецЕсли; 
					КонецЕсли; 
				КонецЕсли; 
			ИначеЕсли ИмяПравила = "<Parameter>" Тогда
				//ИмяПараметра = ДанныеТокена.Tokens(1).Data.Tokens(0).Data;
				//ПолеКомпоновки = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + Результат);
				//ДоступноеПоле = ЧастьОбъединения.Компоновщик.Настройки.ДоступныеПоляВыбора.НайтиПоле(ПолноеИмяПоля);
				//Если ДоступноеПоле <> Неопределено Тогда
				//	Результат = ДоступноеПоле.ТипЗначение;
				//КонецЕсли; 
			ИначеЕсли Ложь
				Или ИмяПравила = "<Datetime>"
				Или ИмяПравила = "<DateDiff>"
				Или ИмяПравила = "<DateAdd>"
				Или ИмяПравила = "<BeginOfPeriod>"
				Или ИмяПравила = "<EndOfPeriod>"
			Тогда
				Результат = Новый ОписаниеТипов("Дата");
			ИначеЕсли Ложь
				Или ИмяПравила = "<Substring>"
			Тогда
				Результат = Новый ОписаниеТипов("Строка");
			ИначеЕсли Ложь
				Или ИмяПравила = "<Count>"
			Тогда
				Результат = Новый ОписаниеТипов("Число");
			ИначеЕсли ИмяПравила = "<Cast>" Тогда
				Результат = ПолучитьТипФункцииCast(ДанныеТокена.Tokens(4), ЧастьОбъединения);
			ИначеЕсли Ложь
				Или ИмяПравила = "<Type>"
				Или ИмяПравила = "<ValueType>"
			Тогда
				Результат = Новый ОписаниеТипов("Тип");
			ИначеЕсли ИмяПравила = "<Meaning>" Тогда
				ПолноеИмяПредопределенного = СобратьВыражениеЗапроса(ДанныеТокена.Tokens(2));
				Фрагменты = ЛксПолучитьМассивИзСтрокиСРазделителем(ПолноеИмяПредопределенного);
				Фрагменты.Удалить(Фрагменты.ВГраница());
				ИмяСсылочногоТипа = ЛксПолучитьСтрокуСРазделителемИзМассива(Фрагменты, ".");
				ИмяСсылочногоТипа = СтрЗаменить(ИмяСсылочногоТипа, ".", "Ссылка.");
				Попытка
					Результат = Новый ОписаниеТипов(ИмяСсылочногоТипа);
				Исключение
				КонецПопытки; 
			// Далее идут правила, допускающие напрямую вложнные правила
			ИначеЕсли ДанныеТокена.TokenCount = 1 Тогда
				Результат = ПолучитьТипЗначенияВыражения(ДанныеТокена.Tokens(0), ЧастьОбъединения);
			ИначеЕсли Ложь
				Или ИмяПравила = "<AddExpr>" 
			Тогда
				Результат = ПолучитьТипЗначенияВыражения(ДанныеТокена.Tokens(0), ЧастьОбъединения);
			ИначеЕсли Ложь
				Или ИмяПравила = "<MultExpr>" 
			Тогда
				Результат = Новый ОписаниеТипов("Число");
			ИначеЕсли Ложь
				Или ИмяПравила = "<NotExpr>" 
				Или ИмяПравила = "<AndExpr>" 
				Или ИмяПравила = "<OrExpr>" 
				Или ИмяПравила = "<CheckNULL>" 
				Или ИмяПравила = "<CheckNotNULL>" 
				Или ИмяПравила = "<CheckLIKE>" 
				Или ИмяПравила = "<CheckHierarchy>" 
				Или ИмяПравила = "<CheckExpr>" 
			Тогда
				Результат = Новый ОписаниеТипов("Булево");
			ИначеЕсли ИмяПравила = "<Brackets>" Тогда
				Результат = ПолучитьТипЗначенияВыражения(ДанныеТокена.Tokens(1), ЧастьОбъединения);
			КонецЕсли; 
		Иначе
			ИмяТокена = Токен.Name;
			Если ирНеглобальный.СтрокиРавныЛкс(ИмяТокена, "numLiteral") Тогда
				Результат = Новый ОписаниеТипов("Число");
			ИначеЕсли ирНеглобальный.СтрокиРавныЛкс(ИмяТокена, "strLiteral") Тогда
				Результат = Новый ОписаниеТипов("Строка");
			ИначеЕсли Ложь
				Или ирНеглобальный.СтрокиРавныЛкс(ИмяТокена, "TRUE")
				Или ирНеглобальный.СтрокиРавныЛкс(ИмяТокена, "FALSE")
			Тогда
				Результат = Новый ОписаниеТипов("Булево");
			Иначе
				Результат = Новый ОписаниеТипов();
			КонецЕсли; 
		КонецЕсли;
	КонецЕсли;
	Если Результат = Неопределено Тогда
		Результат = Новый ОписаниеТипов();
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция ПолучитьТипФункцииCast(ТокенТипа, ЧастьОбъединения)

	ПервыйТокен = ТокенТипа.Data.Tokens(0);
	Если Истина
		И ПервыйТокен.Kind = 1
		И ПервыйТокен.Data = "(" 
	Тогда
		Результат = ПолучитьТипФункцииCast(ТокенТипа.Data.Tokens(1), ЧастьОбъединения);
	ИначеЕсли ПервыйТокен.Kind = 1 Тогда
		Результат = Новый ОписаниеТипов(ПервыйТокен.Data);
	Иначе
		ИмяПравилаТипа = ПервыйТокен.Data.ParentRule.RuleNonterminal.Text;
		Если ИмяПравилаТипа = "<NumericType>" Тогда
			Результат = Новый ОписаниеТипов("Число");
		ИначеЕсли ИмяПравилаТипа = "<StringType>" Тогда
			Результат = Новый ОписаниеТипов("Строка");
		ИначеЕсли ИмяПравилаТипа = "<TableName>" Тогда
			ИмяСсылочногоТипа = СобратьВыражениеЗапроса(ПервыйТокен);
			ИмяСсылочногоТипа = СтрЗаменить(ИмяСсылочногоТипа, ".", "Ссылка.");
			ИмяСсылочногоТипа = Новый ОписаниеТипов(ИмяСсылочногоТипа);
			Попытка
				Результат = Новый ОписаниеТипов(ИмяСсылочногоТипа);
			Исключение
			КонецПопытки; 
		ИначеЕсли ИмяПравилаТипа = "<Brackets>" Тогда
		Иначе
			ВызватьИсключение "Неизвестный тип " + ИмяПравилаТипа + " в функции CAST";
		КонецЕсли; 
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Функция ПолучитьТерминОтбораКомпоновкиИзДанныхТокена(Токен, ЗапросПакета, ЧастьОбъединения)
	
	//Результат = СобратьВыражениеЗапроса(ДанныеТокена);
	ДанныеТокена = Токен.Data;
	Если Токен.Kind = 0 Тогда
		ИмяПравила = ДанныеТокена.ParentRule.RuleNonterminal.Text;
		Если ИмяПравила = "<Field>" Тогда
			//Результат = ПолучитьТекстИзТокена(Токен);
			Результат = СобратьВыражениеЗапроса(Токен,,, ЧастьОбъединения);
			Результат = ПолучитьПолноеИмяПоляВВыражении(Результат, ЗапросПакета, ЧастьОбъединения);
			Результат = Новый ПолеКомпоновкиДанных(Результат);
			Возврат Результат;
		ИначеЕсли ИмяПравила = "<Parameter>" Тогда
			//Результат = ДанныеТокена.Tokens(1).Data.Tokens(0).Data;
			Результат = Сред(ДанныеТокена.Tokens(0).Data, 2);
			ПроверитьДобавитьПараметр(Результат);
			Результат = Новый ПолеКомпоновкиДанных("ПараметрыДанных." + Результат);
			Возврат Результат;
		ИначеЕсли ИмяПравила = "<Datetime>" Тогда
			Год = ДанныеТокена.Tokens(2).Data;
			Месяц = ДанныеТокена.Tokens(4).Data;
			День = ДанныеТокена.Tokens(6).Data;
			Если ДанныеТокена.TokenCount > 8 Тогда
				Час = ДанныеТокена.Tokens(8).Data;
				Минута = ДанныеТокена.Tokens(10).Data;
				Секунда = ДанныеТокена.Tokens(12).Data;
			Иначе
				Час = 0;
				Минута = 0;
				Секунда = 0;
			КонецЕсли; 
			Результат = Дата(Год, Месяц, День, Час, Минута, Секунда);
			Возврат Результат;
		КонецЕсли; 
	Иначе
		ИмяТокена = Токен.Name;
		Если ирНеглобальный.СтрокиРавныЛкс(ИмяТокена, "numLiteral") Тогда
			Результат = Вычислить(ДанныеТокена);
		ИначеЕсли ирНеглобальный.СтрокиРавныЛкс(ИмяТокена, "strLiteral") Тогда
			Результат = Токен.Data;
			Результат = Сред(Результат, 2, СтрДлина(Результат) - 2);
			Результат = СтрЗаменить(Результат, """""", """");
		ИначеЕсли ирНеглобальный.СтрокиРавныЛкс(ИмяТокена, "TRUE") Тогда
			Результат = Истина;
		ИначеЕсли ирНеглобальный.СтрокиРавныЛкс(ИмяТокена, "FALSE") Тогда
			Результат = Ложь;
		КонецЕсли; 
		Возврат Результат;
	КонецЕсли; 
	Если ДанныеТокена.TokenCount = 1 Тогда
		Результат = ПолучитьТерминОтбораКомпоновкиИзДанныхТокена(ДанныеТокена.Tokens(0), ЗапросПакета, ЧастьОбъединения);
	Иначе
		Результат = Неопределено;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура ВыбранныеПоляПриИзмененииФлажка(Элемент, Колонка)
	
	Если ЭлементыФормы.ВыбранныеПоля.Колонки.Группировка = Колонка Тогда
		СтрокаГруппировки = Группировки.Найти(ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока.Определение, "Определение");
		Если СтрокаГруппировки <> Неопределено Тогда
			Группировки.Удалить(СтрокаГруппировки);
		Иначе
			СтрокаГруппировки = Группировки.Добавить();
			СтрокаГруппировки.Определение = ЭлементыФормы.ВыбранныеПоля.ТекущаяСтрока.Определение;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПараметрыПередОкончаниемРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования, Отказ)
	
	Если Не ОтменаРедактирования Тогда
		Элемент.ТекущиеДанные.Имя = ирНеглобальный.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(Элемент.Значение, Элемент.ТекущиеДанные,,, ПолучитьСловоЯзыкаЗапросов("Parameter"));
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДоступныеВыбранныеПоляПорядкаВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтрокаПорядка = ПоляПорядка.Найти(ВыбраннаяСтрока.Имя, "Определение");
	Если СтрокаПорядка = Неопределено Тогда
		СтрокаПорядка = ПоляПорядка.Добавить();
		СтрокаПорядка.Определение = ВыбраннаяСтрока.Имя;
		ОбновитьВыражениеЗапроса(СтрокаПорядка,,,,,,,, Ложь);
	КонецЕсли; 
	ЭлементыФормы.ПоляПорядка.ТекущаяСтрока = СтрокаПорядка;
	
КонецПроцедуры

Процедура ДоступныеПоляПорядкаВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ПолноеИмяПоля = ПолучитьПолноеИмяДоступногоПоля(ВыбраннаяСтрока);
	Если ПолноеИмяПоля = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	СтрокаПорядка = ПоляПорядка.Найти(ПолноеИмяПоля, "Определение");
	Если СтрокаПорядка = Неопределено Тогда
		СтрокаПорядка = ПоляПорядка.Добавить();
		СтрокаПорядка.Определение = ПолноеИмяПоля;
		ОбновитьВыражениеЗапроса(СтрокаПорядка,,,,,,,, Ложь);
	КонецЕсли; 
	ЭлементыФормы.ПоляПорядка.ТекущаяСтрока = СтрокаПорядка;
	
КонецПроцедуры

Процедура ПорядокВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если Колонка = ЭлементыФормы.ПоляПорядка.Колонки.Направление Тогда
		Если ВыбраннаяСтрока.Направление = НаправлениеСортировки.Убыв Тогда
			ВыбраннаяСтрока.Направление = НаправлениеСортировки.Возр;
		Иначе
			ВыбраннаяСтрока.Направление = НаправлениеСортировки.Убыв;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Функция ПолучитьПолноеИмяДоступногоПоля(ДоступноеПоле)
	
	Результат = "" + ДоступноеПоле.Поле;
	Возврат Результат;
	
КонецФункции

Процедура УсловияПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если НоваяСтрока Тогда
		Элемент.ТекущиеДанные.Сравнение = "=";
		Элемент.ТекущиеДанные.ЛевоеВыражение = 1;
		Элемент.ТекущиеДанные.ПравоеВыражение = 1;
		//СвязиТаблицПриАктивизацииСтроки();
	КонецЕсли; 

КонецПроцедуры

Процедура ПередЗакрытием(Отказ, СтандартнаяОбработка)
	
	Если Модифицированность Тогда
		Ответ = Вопрос("Хотите сохранить изменения?", РежимДиалогаВопрос.ДаНетОтмена);
		Если Ответ = КодВозвратаДиалога.Да Тогда
			ОсновныеДействияФормыОК();
		ИначеЕсли Ответ = КодВозвратаДиалога.Отмена Тогда
			Отказ = Истина;
		КонецЕсли;
	КонецЕсли; 
	Если Не Отказ Тогда
		ЛксИзменитьСвернутость(Истина, ЭлементыФормы.ПанельЧастей, ЭлементыФормы.вРазделительПанельЧастей, Панель, "лево");
		ЛксИзменитьСвернутость(Истина, ЭлементыФормы.ПанельПакета, ЭлементыФормы.вРазделительПанельПакета, Панель, "лево");
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДоступныеТаблицыПриАктивизацииСтроки(Элемент)
	
	ТекущаяСтрока = ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока;
	ПоляДоступнойТаблицы.Очистить();
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ЛксЗагрузитьВТаблицуЗначений(ПолучитьПоляДоступнойТаблицы(ТекущаяСтрока), ПоляДоступнойТаблицы);
	ПоляДоступнойТаблицы.Сортировать("Имя");
	
КонецПроцедуры

Процедура ОткрытьОтладчик(Кнопка)
	
	ВызватьИсключение ирНеглобальный.ПолучитьПриглашениеОткрытьОтладчикЛкс();
	
КонецПроцедуры

Процедура ДеревоУсловияПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ДанныеСтроки <> Элемент.Значение Тогда
		ЭтоПроизвольноеУсловие = ДанныеСтроки.Представление <> "";
		ОформлениеСтроки.Ячейки.Произвольное.ОтображатьФлажок = Не ЭтоПроизвольноеУсловие И ТипЗнч(ДанныеСтроки) = Тип("ЭлементОтбораКомпоновкиДанных");
		ОформлениеСтроки.Ячейки.Произвольное.Флажок = ЭтоПроизвольноеУсловие;
		Если ЭтоПроизвольноеУсловие Тогда
			ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДеревоУсловияПриИзмененииФлажка(Элемент, Колонка)
	
	Если Элемент.Колонки.Произвольное = Колонка Тогда
		ПереключитьРежимПроизвольногоВыраженияОтбора(Элемент, Колонка);
		ЗагрузитьВыражениеУсловия();
	КонецЕсли; 

КонецПроцедуры

Процедура ПриПолученииДанныхДоступныхПолей(Элемент, ОформленияСтрок)

	ЛксПриПолученииДанныхДоступныхПолейКомпоновки(ОформленияСтрок);

КонецПроцедуры // ПриПолученииДанныхДоступныхПолей()

Процедура УсловияПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		ОбновитьЭлементОтбораПослеИзменения(Элемент);
		ЭлементыФормы.ВыражениеЭлементаУсловия.УстановитьТекст(мТекущаяСтрокаУсловия.Представление);
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеПоляПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		Если НоваяСтрока Тогда
			мТекущаяСтрокаВыбранногоПоля.ИД = Новый УникальныйИдентификатор();
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОчиститьДанные() Экспорт
	
	ЗапросыПакета.Очистить();
	ЧастиОбъединения.Очистить();
	ВыбранныеПоля.Очистить();
	ПоляПорядка.Очистить();
	Группировки.Очистить();
	СвязиТаблиц.Очистить();
	Параметры.Очистить();
	ЭтаФорма.ОпцияПервые = Неопределено;
	ЭтаФорма.ОпцияРазличные = Неопределено;
	ЭтаФорма.ОпцияАвтоупорядочивание = Неопределено;
	ЭтаФорма.ОпцияРазрешенные = Неопределено;
	ЭтаФорма.РежимОбъединения = Ложь;
	ЭтаФорма.ЛиПакетныйЗапрос = Ложь;
	ЭтаФорма.ТипЗапроса = 0;
	КомпоновщикЧасти.Настройки.Отбор.Элементы.Очистить();
	
КонецПроцедуры

Процедура ПереключитьРежимРедактированияТекста()
	
	ЭтаФорма.мРежимРедактированияТекста = Не мРежимРедактированияТекста;
	ЭлементыФормы.ПолеТекстаОтображаетПакет.Доступность = Не мРежимРедактированияТекста;
	ЭлементыФормы.КПТекст.Кнопки.Редактировать.Пометка = мРежимРедактированияТекста;
	ЭлементыФормы.КПТекст.Кнопки.ОтменитьРедактирование.Доступность = мРежимРедактированияТекста;
	ЭлементыФормы.ПолеТекстаЗапроса.ТолькоПросмотр = Не мРежимРедактированияТекста;
	Для Каждого Страница Из ЭлементыФормы.ПанельОсновная.Страницы Цикл
		Если ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> Страница Тогда
			Страница.Доступность = Не мРежимРедактированияТекста;
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры

Процедура КПТекстРедактировать(Кнопка)

	Если мРежимРедактированияТекста Тогда
		Компонента = ПолеТекстовогоДокументаСКонтекстнойПодсказкой[ЭлементыФормы.ПолеТекстаЗапроса.Имя];
		Если Компонента.ЗагрузитьТекстВКонструктор() = Истина Тогда
			ПереключитьРежимРедактированияТекста();
		КонецЕсли; 
	Иначе
		ПереключитьРежимРедактированияТекста();
	КонецЕсли; 
	
КонецПроцедуры

Процедура ДиалектSQLОчистка(Элемент, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ЭтаФорма.ДиалектSQL = мДиалектSQL;
	
КонецПроцедуры

Процедура ОбновитьВсеВыражения()
	
	Состояние("Обновление выражений...");
	ОбновитьВсеВыраженияПакета();
	Состояние("");
	
КонецПроцедуры

Функция ОбновитьВсеВыраженияПакета(Пакет = Неопределено)

	Если Пакет = Неопределено Тогда
		Пакет = ЗапросыПакета;
	КонецЕсли; 
	Для Каждого ЗапросПакета Из Пакет Цикл
		Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
			Для Каждого ВыбраннаяТаблица Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
				Если ВыбраннаяТаблица.ВложенныйПакет <> Неопределено Тогда
					ОбновитьВсеВыраженияПакета(ВыбраннаяТаблица.ВложенныйПакет);
				КонецЕсли; 
				Для каждого ПараметрТаблицы Из ВыбраннаяТаблица.Параметры Цикл
					Если Не ЗначениеЗаполнено(ПараметрТаблицы.Определение) Тогда
						Продолжить;
					КонецЕсли; 
					ОбновитьВыражениеЗапроса(ПараметрТаблицы, ЭлементыФормы.ПараметрыТаблицы, ЗапросПакета, ЧастьОбъединения);
				КонецЦикла;
			КонецЦикла;
			Для Каждого ВыбранноеПоле Из ЧастьОбъединения.ВыбранныеПоля Цикл
				ОбновитьВыражениеЗапроса(ВыбранноеПоле, ЭлементыФормы.ВыбранныеПоля, ЗапросПакета, ЧастьОбъединения);
			КонецЦикла;
			Для Каждого ПолеГруппировки Из ЧастьОбъединения.Группировки Цикл
				ОбновитьВыражениеЗапроса(ПолеГруппировки, ЭлементыФормы.Группировки, ЗапросПакета, ЧастьОбъединения);
			КонецЦикла;
			Для Каждого СвязьТаблиц Из ЧастьОбъединения.СвязиТаблиц Цикл
				ОбновитьВыраженияОтбора(СвязьТаблиц.Условие.Отбор, ЭлементыФормы.ДеревоУсловияСвязи, ЗапросПакета, ЧастьОбъединения);
			КонецЦикла;
			ОбновитьВыраженияОтбора(ЧастьОбъединения.Условие.Отбор, ЭлементыФормы.ДеревоУсловия,, ЗапросПакета, ЧастьОбъединения);
		КонецЦикла;
		Для Каждого ПолеПорядка Из ЗапросПакета.ПоляПорядка Цикл
			ОбновитьВыражениеЗапроса(ПолеПорядка, ЭлементыФормы.ПоляПорядка, ЗапросПакета);
		КонецЦикла;
		Для Каждого ГруппируемоеПолеИтогов Из ЗапросПакета.ГруппируемыеПоляИтогов Цикл
			ОбновитьВыражениеЗапроса(ГруппируемоеПолеИтогов, ЭлементыФормы.ГруппируемыеПоляИтогов, ЗапросПакета);
		КонецЦикла;
		Для Каждого ГруппирующееПолеИтогов Из ЗапросПакета.ГруппирующиеПоляИтогов Цикл
			ОбновитьВыражениеЗапроса(ГруппирующееПолеИтогов, ЭлементыФормы.ГруппирующиеПоляИтогов, ЗапросПакета);
		КонецЦикла;
	КонецЦикла;
	Возврат Неопределено;

КонецФункции

Процедура ОбновитьВыраженияОтбора(ГруппаОтбора, ТабличноеПоле = Неопределено,
	Знач ЗапросПакета = Неопределено, Знач ЧастьОбъединения = Неопределено, СтароеИмяТаблицы = "", НовоеИмяТаблицы = "")
	
	Для Каждого ЭлементГруппы Из ГруппаОтбора.Элементы Цикл
		Если ТипЗнч(ЭлементГруппы) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			ОбновитьВыраженияОтбора(ЭлементГруппы, ТабличноеПоле, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы);
		Иначе
			Если ЭлементГруппы.Представление <> "" Тогда
				ОбновитьВыражениеЗапроса(ЭлементГруппы, ТабличноеПоле, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы);
			Иначе
				Если ТипЗнч(ЭлементГруппы.ЛевоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
					ЭлементГруппы.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(
						ПолучитьПолноеИмяПоляВВыражении("" + ЭлементГруппы.ЛевоеЗначение, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы));
				КонецЕсли; 
				Если ТипЗнч(ЭлементГруппы.ПравоеЗначение) = Тип("ПолеКомпоновкиДанных") Тогда
					ЭлементГруппы.ПравоеЗначение = Новый ПолеКомпоновкиДанных(
						ПолучитьПолноеИмяПоляВВыражении("" + ЭлементГруппы.ПравоеЗначение, ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы));
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьИмяВыбраннойТаблицы(СтрокаВыбраннойТаблицы)

	Если Не ЗначениеЗаполнено(СтрокаВыбраннойТаблицы.Имя) Тогда
		СтрокаВыбраннойТаблицы.Имя = ирНеглобальный.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(СтрокаВыбраннойТаблицы.Владелец(), СтрокаВыбраннойТаблицы.ПолноеИмя, "Имя");
		ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаВыбраннойТаблицы);
	КонецЕсли;
	Результат = СтрокаВыбраннойТаблицы.Имя;
	Возврат Результат;

КонецФункции

Функция ПолучитьТекстОператораТокена(Данные, НачальныйИндекс, КонечныйИндекс)

	ТекстОператора = "";
	Для Индекс = НачальныйИндекс По КонечныйИндекс Цикл
		Если ТекстОператора <> "" Тогда
			ТекстОператора = ТекстОператора + " " + ТекстОператора;
		КонецЕсли; 
		ИмяТерминала = Данные.Tokens(Индекс).ParentRule.RuleNonterminal.Name;
		ТекстОператора = ТекстОператора + " " + ПолучитьСловоЯзыкаЗапросов(ИмяТерминала);
	КонецЦикла;

	Возврат Неопределено;

КонецФункции

Функция ОбновитьВыражениеЗапроса(СтрокаТаблицыВыражений, ТабличноеПоле = Неопределено, Знач ЗапросПакета = Неопределено, Знач ЧастьОбъединения = Неопределено,
	СтароеИмяТаблицы = "", НовоеИмяТаблицы = "", РазрешитьПустое = Ложь, выхЕстьАгрегаты = Истина, РазрешитьНормализациюИмен = Истина, Пересобрать = Истина)

	НачальныйТокенВыражения = Неопределено;
	Если ТипЗнч(СтрокаТаблицыВыражений) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		ВыражениеЗапроса = СтрокаТаблицыВыражений.Представление;
		Если Не Пересобрать Тогда
			НачальныйТокенВыражения = СтрокаТаблицыВыражений.ПравоеЗначение;
		КонецЕсли; 
	Иначе
		ВыражениеЗапроса = СтрокаТаблицыВыражений.Определение;
		Если Не Пересобрать Тогда
			НачальныйТокенВыражения = СтрокаТаблицыВыражений.Токен;
		КонецЕсли; 
	КонецЕсли; 
	Если Ложь
		Или (Истина
			И РазрешитьПустое 
			И ПустаяСтрока(ВыражениеЗапроса))
		Или (Истина
			И Не ЗначениеЗаполнено(СтароеИмяТаблицы)
			И ЛиВыражениеЯвляетсяПолем(ВыражениеЗапроса))
	Тогда
		Результат = ВыражениеЗапроса;
		НачальныйТокенВыражения = ВыражениеЗапроса;
	Иначе
		Если ЗапросПакета = Неопределено Тогда
			ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
		КонецЕсли; 
		Если ЧастьОбъединения = Неопределено Тогда
			ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
		КонецЕсли; 
		Попытка
			Если ТипЗнч(НачальныйТокенВыражения) <> Тип("COMОбъект") Тогда
				НачальныйТокенВыражения = РазобратьВыражениеЗапроса(ВыражениеЗапроса);
			КонецЕсли; 
			Результат = СобратьВыражениеЗапроса(НачальныйТокенВыражения, , ЗапросПакета, ЧастьОбъединения, СтароеИмяТаблицы, НовоеИмяТаблицы, выхЕстьАгрегаты, РазрешитьНормализациюИмен);
		Исключение
			Если ТабличноеПоле <> Неопределено Тогда
				ЭтаФорма.ТекущийЭлемент = ТабличноеПоле;
				ТабличноеПоле.ТекущаяСтрока = СтрокаТаблицыВыражений;
				ВызватьИсключение;
			КонецЕсли;
			Возврат Неопределено;
		КонецПопытки; 
	КонецЕсли; 
	Если ТипЗнч(СтрокаТаблицыВыражений) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		СтрокаТаблицыВыражений.Представление = Результат;
		СтрокаТаблицыВыражений.ПравоеЗначение = НачальныйТокенВыражения;
	Иначе
		СтрокаТаблицыВыражений.Определение = Результат;
		СтрокаТаблицыВыражений.Токен = НачальныйТокенВыражения;
	КонецЕсли; 
	Возврат Результат;

КонецФункции

Процедура ДиалектSQLПриИзменении(Элемент = Неопределено)
	
	ЗакончитьРедактированиеСвязанныхПолей();
	УстановитьДиалектSQL();
	ОбновитьВсеВыражения();
	Если ЭлементыФормы.ПанельОсновная.ТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.Текст Тогда
		ПересобратьВременныйПолныйТекст();
	ИначеЕсли Истина
		И ЭлементыФормы.ПанельОсновная.ТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения 
		И ЭлементыФормы.ПанельЧасти.ТекущаяСтраница = ЭлементыФормы.ПанельЧасти.Страницы.Текст
	Тогда
		ПересобратьВременныйТекстЧасти();
	КонецЕсли; 
	
КонецПроцедуры

Процедура УстановитьДиалектSQL(НовыйДиалектSQL = Неопределено) Экспорт
	
	Если НовыйДиалектSQL <> Неопределено Тогда
		ЭтаФорма.ДиалектSQL = НовыйДиалектSQL;
	КонецЕсли; 
	ПараметрыДиалектаSQL = мДиалектыSQL.Найти(ДиалектSQL, "Диалект");
	Если НЕ ПараметрыДиалектаSQL.ВременныеТаблицы Тогда
		ЭтаФорма.ТипЗапроса = 0;
	КонецЕсли; 
	ЭлементыФормы.ПанельОсновная.Страницы.Итоги.Видимость = ПараметрыДиалектаSQL.Это1С;
	ЭлементыФормы.ПанельОсновная.Страницы.Параметры.Видимость = ПараметрыДиалектаSQL.Параметры;
	ЭлементыФормы.ПанельОсновная.Страницы.ПоляОбъединения.Видимость = ПараметрыДиалектаSQL.Объединения;
	ЭлементыФормы.ПанельЧасти.Страницы.СвязиТаблиц.Видимость = ПараметрыДиалектаSQL.МногоТаблиц;
	ЭлементыФормы.ВыбранныеПоля.Колонки.Имя.Видимость = ПараметрыДиалектаSQL.МногоТаблиц;
	ЭлементыФормы.ПанельЧасти.Страницы.Группировки.Видимость = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ВыбранныеПоля.Колонки.АгрегатнаяФункция.Видимость = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ВыбранныеПоля.Колонки.АгрегатнаяФункция.ИзменятьНастройку = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ВыбранныеПоля.Колонки.Группировка.Видимость = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ВыбранныеПоля.Колонки.Группировка.ИзменятьНастройку = ПараметрыДиалектаSQL.Группировки;
	ЭлементыФормы.ТипЗапроса.Доступность = ПараметрыДиалектаSQL.ВременныеТаблицы;
	РазрешеныКомментриии = ЗначениеЗаполнено(ПараметрыДиалектаSQL.СтрочныйКомментарий);
	ЭлементыФормы.ПанельЧасти.Страницы.КомментарийЧасти.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.ВыбранныеТаблицы.Колонки.Комментарий.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.ВыбранныеПоля.Колонки.Комментарий.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.Группировки.Колонки.Комментарий.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.ПоляИндекса.Колонки.Комментарий.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.ГруппируемыеПоляИтогов.Колонки.Комментарий.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.ГруппирующиеПоляИтогов.Колонки.Комментарий.Видимость = РазрешеныКомментриии;
	ЭлементыФормы.ОпцияАвтоупорядочивание.Доступность = ПараметрыДиалектаSQL.Это1С;
	ЭлементыФормы.Английский1С.Доступность = ПараметрыДиалектаSQL.Это1С;
	
	АгрегатныеФункции = Новый СписокЗначений();
	АгрегатныеФункции.Добавить("SUM(", ПолучитьСловоЯзыкаЗапросов("SUM"));
	АгрегатныеФункции.Добавить("MAX(", ПолучитьСловоЯзыкаЗапросов("MAX"));
	АгрегатныеФункции.Добавить("MIN(", ПолучитьСловоЯзыкаЗапросов("MIN"));
	АгрегатныеФункции.Добавить("AVG(", ПолучитьСловоЯзыкаЗапросов("AVG"));
	АгрегатныеФункции.Добавить("COUNT(", ПолучитьСловоЯзыкаЗапросов("COUNT"));
	АгрегатныеФункции.Добавить("COUNT(DISTINCT ", ПолучитьСловоЯзыкаЗапросов("COUNT") + " " + ПолучитьСловоЯзыкаЗапросов("DISTINCT"));
	ПоляВвводаАгрегатныхФункций = Новый Массив();
	ПоляВвводаАгрегатныхФункций.Добавить(ЭлементыФормы.ВыбранныеПоля.Колонки.АгрегатнаяФункция.ЭлементУправления);
	ПоляВвводаАгрегатныхФункций.Добавить(ЭлементыФормы.ГруппируемыеПоляИтогов.Колонки.АгрегатнаяФункция.ЭлементУправления);
	Для Каждого ПолеВвводаАгрегатнойФункции Из ПоляВвводаАгрегатныхФункций Цикл
		СписокВыбора = ПолеВвводаАгрегатнойФункции.СписокВыбора;
		СписокВыбора.Очистить();
		Для Каждого АгрегатнаяФункция Из АгрегатныеФункции Цикл
			СписокВыбора.Добавить(АгрегатнаяФункция.Значение, АгрегатнаяФункция.Представление);
		КонецЦикла;
	КонецЦикла;
		
КонецПроцедуры

Процедура ПересобратьВременныйПолныйТекст()
	
	Текст = СобратьПолныйТекст();
	ирНеглобальный.УстановитьТекстПоляСохраняяПозициюЛкс(ЭлементыФормы.ПолеТекстаЗапроса, Текст);

КонецПроцедуры

Процедура ПанельОсновнаяПриСменеСтраницы(Элемент = Неопределено, ТекущаяСтраница =  Неопределено)
	
	ЗакончитьРедактированиеСвязанныхПолей();
	Элемент = ЭлементыФормы.ПанельОсновная;
	ТекущаяСтраница = Элемент.Страницы.Индекс(Элемент.ТекущаяСтраница);
	Если ТипЗапроса <> 2 Тогда
		Если Ложь
			Или мСтараяСтраницаПанелиОсновная = ЭлементыФормы.ПанельОсновная.Страницы.Параметры
			Или мСтараяСтраницаПанелиОсновная = ЭлементыФормы.ПанельОсновная.Страницы.ЧастиОбъединения
		Тогда
			ЗагрузитьДоступныеНастройкиКомпоновки();
		КонецЕсли; 
	КонецЕсли; 
	ПанельОсновнаяОбновитьТекущуюСтраницу();
	ЭтаФорма.мСтараяСтраницаПанелиОсновная = Элемент.Страницы[ТекущаяСтраница];
	
КонецПроцедуры

Процедура ПанельОсновнаяОбновитьТекущуюСтраницу()

	лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.ТекущаяСтраница;
	Если лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.Текст Тогда
		ПересобратьВременныйПолныйТекст();
	//ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.Итоги Тогда
	//	ЭтаФорма.ДоступныеПоляИтогов = ЧастиОбъединения[0].ВыбранныеПоля;
	ИначеЕсли лТекущаяСтраница = ЭлементыФормы.ПанельОсновная.Страницы.ПоляОбъединения Тогда
		ОбновитьТабличноеПолеПоляОбъединения();
	КонецЕсли; 

КонецПроцедуры

Процедура ОбновитьПоляОбъединенияЗапроса(ЗапросПакета = Неопределено)
	
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	ЗапросПакета.ПоляОбъединения.Очистить();
	Пока ЗапросПакета.ПоляОбъединения.Колонки.Количество() > мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей Цикл
		ЗапросПакета.ПоляОбъединения.Колонки.Удалить(мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей);
	КонецЦикла;
	Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
		КолонкаЧастиИД = ЗапросПакета.ПоляОбъединения.Колонки.Добавить("_" + ЧастьОбъединения.Номер);
		КолонкаЧастиОпределение = ЗапросПакета.ПоляОбъединения.Колонки.Добавить("Определение" + ЧастьОбъединения.Номер);
		НачальноеКоличество = ЧастьОбъединения.ВыбранныеПоля.Количество(); 
		Для Счетчик = 1 По НачальноеКоличество Цикл
			ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля[НачальноеКоличество - Счетчик];
			СтрокаПсевдонимаПоля = ЗапросПакета.ПоляОбъединения.Найти(ВыбранноеПоле.Имя, "Имя");
			Если СтрокаПсевдонимаПоля = Неопределено Тогда
				СтрокаПсевдонимаПоля = ЗапросПакета.ПоляОбъединения.Вставить(0);
				СтрокаПсевдонимаПоля.Имя = ВыбранноеПоле.Имя;
				ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаПсевдонимаПоля);
			КонецЕсли; 
			СтрокаПсевдонимаПоля[КолонкаЧастиИД.Имя] = ВыбранноеПоле.ИД;
			СтрокаПсевдонимаПоля[КолонкаЧастиОпределение.Имя] = ВыбранноеПоле.Определение;
			Если ирНеглобальный.СтрокиРавныЛкс(ВыбранноеПоле.Определение, "NULL") Тогда
				ЧастьОбъединения.ВыбранныеПоля.Удалить(ВыбранноеПоле);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	Для Каждого ПолеОбъединения Из ЗапросПакета.ПоляОбъединения Цикл
		ОбновитьТипЗначенияПоляОбъединения(ЗапросПакета, ПолеОбъединения);
	КонецЦикла;
	ОбновитьРолиИтогов(ЗапросПакета);
	
КонецПроцедуры

Функция ОбновитьТабличноеПолеПоляОбъединения()

	ОбновитьПоляОбъединенияЗапроса();
	Пока ЭлементыФормы.ПоляОбъединения.Колонки.Количество() > мЧислоСтатическихКолонокТППоляПсевдонимовПолей Цикл 
		ЭлементыФормы.ПоляОбъединения.Колонки.Удалить(мЧислоСтатическихКолонокТППоляПсевдонимовПолей);
	КонецЦикла;
	Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
		КолонкаТП = ЭлементыФормы.ПоляОбъединения.Колонки.Добавить("Определение" + ЧастьОбъединения.Номер);
		КолонкаТП.ТекстШапки = ЧастьОбъединения.Имя;
		КолонкаТП.Данные = КолонкаТП.Имя;
		КолонкаТП.КартинкиСтрок = БиблиотекаКартинок.ирТипыДоступныхПолейКомпоновки;
		КолонкаТП.ТолькоПросмотр = Истина;
	КонецЦикла;

КонецФункции

Процедура СвязиТаблицПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьУсловиеСвязи();
	ЗагрузитьСвязьТаблицы();

КонецПроцедуры

Процедура ЗагрузитьСвязьТаблицы()
	
	Элемент = ЭлементыФормы.СвязиТаблиц;
	мТекущаяСтрокаСвязи = Элемент.ТекущаяСтрока;
	НоваяНастройкаКомпоновки = Новый НастройкиКомпоновкиДанных;
	Если мТекущаяСтрокаСвязи <> Неопределено Тогда
		СтрокаВыбораЛевойТаблицы = ЭлементыФормы.ВыборЛевойТаблицыСвязи.Значение.Найти(мТекущаяСтрокаСвязи.ЛеваяТаблица, "Имя");
		Если СтрокаВыбораЛевойТаблицы <> Неопределено Тогда
			ЭлементыФормы.ВыборЛевойТаблицыСвязи.ТекущаяСтрока = СтрокаВыбораЛевойТаблицы;
		КонецЕсли; 
		СтрокаВыбораПравойТаблицы = ЭлементыФормы.ВыборПравойТаблицыСвязи.Значение.Найти(мТекущаяСтрокаСвязи.ПраваяТаблица, "Имя");
		Если СтрокаВыбораПравойТаблицы <> Неопределено Тогда
			ЭлементыФормы.ВыборПравойТаблицыСвязи.ТекущаяСтрока = СтрокаВыбораПравойТаблицы;
		КонецЕсли; 
		Если мТекущаяСтрокаСвязи.Условие <> Неопределено Тогда
			НоваяНастройкаКомпоновки = мТекущаяСтрокаСвязи.Условие; 
		КонецЕсли; 
	КонецЕсли; 
	КомпоновщикУсловияСвязи.ЗагрузитьНастройки(НоваяНастройкаКомпоновки);
	Если КомпоновщикУсловияСвязи.Настройки.Отбор.Элементы.Количество() > 0 Тогда
		ЭлементыФормы.ДеревоУсловияСвязи.ТекущаяСтрока = КомпоновщикУсловияСвязи.Настройки.Отбор.Элементы[0];
	КонецЕсли; 

КонецПроцедуры

Процедура ДеревоУсловияПриАктивизацииСтроки(Элемент = Неопределено)
		
	СохранитьВыражениеУсловия();
	ЗагрузитьВыражениеУсловия();

КонецПроцедуры

Процедура ЗагрузитьВыражениеУсловия()

	мТекущаяСтрокаУсловия = ЭлементыФормы.ДеревоУсловия.ТекущаяСтрока;
	Если ТипЗнч(мТекущаяСтрокаУсловия) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		ЭлементыФормы.ВыражениеЭлементаУсловия.Доступность = мТекущаяСтрокаУсловия.Представление <> "";
		ЭлементыФормы.ВыражениеЭлементаУсловия.УстановитьТекст(мТекущаяСтрокаУсловия.Представление);
	Иначе
		ЭлементыФормы.ВыражениеЭлементаУсловия.Доступность = Ложь;
		ЭлементыФормы.ВыражениеЭлементаУсловия.УстановитьТекст("");
	КонецЕсли; 

КонецПроцедуры

Процедура ДеревоУсловияСвязиПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		ОбновитьЭлементОтбораПослеИзменения(Элемент);
		ЭлементыФормы.ВыражениеЭлементаУсловияСвязи.УстановитьТекст(мТекущаяСтрокаУсловияСвязи.Представление);
	КонецЕсли; 

КонецПроцедуры

Процедура Английский1СПриИзменении(Элемент)
	
	ДиалектSQLПриИзменении();

КонецПроцедуры

Процедура ОбъединениеПриИзменении(Элемент)
	
	ЛксИзменитьСвернутость(РежимОбъединения, ЭлементыФормы.ПанельЧастей, ЭлементыФормы.вРазделительПанельЧастей, Панель, "лево");
	
КонецПроцедуры

Процедура СохранитьЧастьОбъединения()
	
	Если мТекущаяСтрокаЧастиОбъединения = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ЧастиОбъединения.Индекс(мТекущаяСтрокаЧастиОбъединения) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	СохранитьВыбраннуюТаблицу();
	СохранитьВыбранноеПоле();
	СохранитьВыражениеУсловия();
	СохранитьУсловиеСвязи();
	//мТекущаяСтрокаЧастиОбъединения.Условие = КомпоновщикЧасти.ПолучитьНастройки();
	мТекущаяСтрокаЧастиОбъединения.ОпцияРазличные = ОпцияРазличные;
	мТекущаяСтрокаЧастиОбъединения.Автогруппировки = Автогруппировки;
	мТекущаяСтрокаЧастиОбъединения.Комментарий = ЭлементыФормы.КомментарийЧасти.ПолучитьТекст();
	мТекущаяСтрокаЧастиОбъединения.КомментарийОтбора = ЭлементыФормы.КомментарийОтбора.ПолучитьТекст();
	ОбновитьНаименованиеЧасти(мТекущаяСтрокаЧастиОбъединения);
	
КонецПроцедуры

Процедура СохранитьЗапросПакета()
	
	Если мТекущаяСтрокаЗапросыПакета = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ЗапросыПакета.Индекс(мТекущаяСтрокаЗапросыПакета) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	СохранитьЧастьОбъединения();
	//мТекущаяСтрокаЗапросыПакета.ПоляПорядка = ПоляПорядка.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ПоляИндекса = ПоляИндекса.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ГруппирующиеПоляИтогов = ГруппирующиеПоляИтогов.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ЧастиОбъединения = ЧастиОбъединения.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ПоляОбъединения = ПоляОбъединения.Скопировать();
	//мТекущаяСтрокаЗапросыПакета.ГруппируемыеПоляИтогов = ГруппируемыеПоляИтогов.Скопировать();
	мТекущаяСтрокаЗапросыПакета.ТипЗапроса = ТипЗапроса;
	Если ТипЗапроса = 2 Тогда
		мТекущаяСтрокаЗапросыПакета.Комментарий = ЭлементыФормы.КомментарийЧасти.ПолучитьТекст();
	Иначе
		мТекущаяСтрокаЗапросыПакета.Комментарий = "";
	КонецЕсли; 
	мТекущаяСтрокаЗапросыПакета.ОпцияОбщиеИтоги = ОпцияОбщиеИтоги;
	мТекущаяСтрокаЗапросыПакета.ОпцияАвтоупорядочивание = ОпцияАвтоупорядочивание;
	мТекущаяСтрокаЗапросыПакета.ОпцияПервые = ОпцияПервые;
	мТекущаяСтрокаЗапросыПакета.ОпцияРазрешенные = ОпцияРазрешенные;
	мТекущаяСтрокаЗапросыПакета.ПервыеКоличество = ПервыеКоличество;
	мТекущаяСтрокаЗапросыПакета.ИмяВременнойТаблицы = ИмяВременнойТаблицы;
	Если Не ЗначениеЗаполнено(ИмяВременнойТаблицы) Тогда
		мТекущаяСтрокаЗапросыПакета.ИмяВременнойТаблицы = ирНеглобальный.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ЗапросыПакета, мТекущаяСтрокаЗапросыПакета, "ИмяВременнойТаблицы");
	КонецЕсли; 
	ОбновитьНаименованиеЗапроса(мТекущаяСтрокаЗапросыПакета);
	
КонецПроцедуры

Процедура ЧастиОбъединенияПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьЧастьОбъединения();
	ЗагрузитьЧастьОбъединения();
	
КонецПроцедуры

Процедура ЗагрузитьЧастьОбъединения()
	
	Элемент = ЭлементыФормы.ЧастиОбъединения;
	мТекущаяСтрокаЧастиОбъединения = Элемент.ТекущаяСтрока;
	мТекущаяСтрокаВыбранногоПоля = Неопределено;
	мТекущаяСтрокаВыбранныеТаблицы = Неопределено;
	мТекущаяСтрокаУсловия = Неопределено;
	мТекущаяСтрокаСвязи = Неопределено;
	мТекущаяСтрокаУсловияСвязи = Неопределено;
	мТекущаяСтрокаПараметраТаблицы = Неопределено;
	мТекущаяСтрокаПараметраТаблицы = Неопределено;
	Если мТекущаяСтрокаЧастиОбъединения <> Неопределено Тогда
		ЭлементыФормы.ВыражениеПараметраТаблицы.УстановитьТекст("");
		ЭлементыФормы.ВыражениеВыбранногоПоля.УстановитьТекст("");
		ЭлементыФормы.КомментарийЧасти.УстановитьТекст(мТекущаяСтрокаЧастиОбъединения.Комментарий);
		ЭлементыФормы.КомментарийОтбора.УстановитьТекст(мТекущаяСтрокаЧастиОбъединения.КомментарийОтбора);
		//ОбновитьДоступныеВременныеТаблицы();
		ЭтаФорма.ВыбранныеТаблицы = мТекущаяСтрокаЧастиОбъединения.ВыбранныеТаблицы;
		ЭтаФорма.ВыбранныеПоля = мТекущаяСтрокаЧастиОбъединения.ВыбранныеПоля;
		ЭтаФорма.СвязиТаблиц = мТекущаяСтрокаЧастиОбъединения.СвязиТаблиц;
		ЭтаФорма.Группировки = мТекущаяСтрокаЧастиОбъединения.Группировки;
		ЭтаФорма.КомпоновщикЧасти = мТекущаяСтрокаЧастиОбъединения.Компоновщик;
		Если КомпоновщикЧасти.Настройки.Отбор.Элементы.Количество() > 0 Тогда
			ЭлементыФормы.ДеревоУсловия.ТекущаяСтрока = КомпоновщикЧасти.Настройки.Отбор.Элементы[0];
		КонецЕсли; 
		ЗагрузитьДоступныеНастройкиКомпоновки();
		КомпоновщикУсловияСвязи.ЗагрузитьНастройки(Новый НастройкиКомпоновкиДанных);
		ЭтаФорма.ОпцияРазличные = мТекущаяСтрокаЧастиОбъединения.ОпцияРазличные;
		ЭтаФорма.Автогруппировки = мТекущаяСтрокаЧастиОбъединения.Автогруппировки;
		ОбновитьГруппировки();
		ПанельЧастиОбновитьТекущуюСтраницу();
	КонецЕсли; 

КонецПроцедуры

Процедура ЧастиОбъединенияПередУдалением(Элемент, Отказ)
	
	Если Элемент.Значение.Количество() = 1 Тогда
		Отказ = Истина;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ЧастиОбъединенияПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	СохранитьЗапросПакета(); // Может уже не надо
	ЧастьОбъединения = ДобавитьЧастьОбъединения(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока);
	ЗагрузитьЗапросПакета(); // Может уже не надо
	Элемент.ТекущаяСтрока = ЧастьОбъединения;
	
КонецПроцедуры

Процедура ДоступныеПоляИтоговВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ДобавитьПолеОбъединенияВГруппирующиеПоля(ВыбраннаяСтрока);

КонецПроцедуры

Процедура ДобавитьПолеОбъединенияВГруппирующиеПоля(ПолеОбъединения)
	
	Если Ложь
		Или ЗначениеЗаполнено(ПолеОбъединения.РольИтога) 
		Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"))
	Тогда
		Возврат;
	КонецЕсли; 
	ОпределениеПоля = "" + ПолеОбъединения.Имя;
	СтрокаГруппирующегоПоля = ГруппирующиеПоляИтогов.Найти(ОпределениеПоля, "Определение");
	Если СтрокаГруппирующегоПоля = Неопределено Тогда
		СтрокаГруппирующегоПоля = ГруппирующиеПоляИтогов.Добавить();
		СтрокаГруппирующегоПоля.Определение = ОпределениеПоля;
		СтрокаГруппирующегоПоля.ТипИтогов = "Элементы";
		//ПолеОбъединения.РольИтога = 1; // так не будет работать, т.к. при перетаскивании созадается копия строки
		ОбновитьРолиИтогов();
	КонецЕсли; 
	ЭлементыФормы.ГруппирующиеПоляИтогов.ТекущаяСтрока = СтрокаГруппирующегоПоля;

КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если Не ЗначениеЗаполнено(ДанныеСтроки.Имя) Тогда
		ОформлениеСтроки.Ячейки.Имя.УстановитьТекст(ДанныеСтроки.Определение);
		ОформлениеСтроки.Ячейки.Имя.ЦветТекста = Новый Цвет(128, 128, 128);
	КонецЕсли;
	
КонецПроцедуры

Процедура ЛиПакетныйЗапросПриИзменении(Элемент = Неопределено) Экспорт
	
	ЛксИзменитьСвернутость(ЛиПакетныйЗапрос, ЭлементыФормы.ПанельПакета, ЭлементыФормы.вРазделительПанельПакета, Панель, "лево");

КонецПроцедуры

Процедура ЗапросыПакетаПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	ЗапросПакета = ДобавитьЗапросПакета();
	Элемент.ТекущаяСтрока = ЗапросПакета;

КонецПроцедуры

Процедура ЗапросыПакетаПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьЗапросПакета();
	ЗагрузитьЗапросПакета();

КонецПроцедуры

Процедура ЗагрузитьЗапросПакета()
	
	Элемент = ЭлементыФормы.ЗапросыПакета;
	мТекущаяСтрокаЗапросыПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	мТекущаяСтрокаГруппируемогоПоля = Неопределено;
	Если мТекущаяСтрокаЗапросыПакета <> Неопределено Тогда
		ЭлементыФормы.ВыражениеГруппируемогоПоля.УстановитьТекст("");
		ЭтаФорма.ЧастиОбъединения = мТекущаяСтрокаЗапросыПакета.ЧастиОбъединения;
		ЭтаФорма.ТипЗапроса = мТекущаяСтрокаЗапросыПакета.ТипЗапроса;
		ЭтаФорма.РежимОбъединения = мТекущаяСтрокаЗапросыПакета.ЧастиОбъединения.Количество() > 1;
		ЭтаФорма.ПоляПорядка = мТекущаяСтрокаЗапросыПакета.ПоляПорядка;
		ЭтаФорма.ПоляОбъединения = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока.ПоляОбъединения;
		ЭтаФорма.ПоляИндекса = мТекущаяСтрокаЗапросыПакета.ПоляИндекса;
		ЭтаФорма.ГруппируемыеПоляИтогов = мТекущаяСтрокаЗапросыПакета.ГруппируемыеПоляИтогов;
		ЭтаФорма.ГруппирующиеПоляИтогов = мТекущаяСтрокаЗапросыПакета.ГруппирующиеПоляИтогов;
		ЭтаФорма.ОпцияРазрешенные = мТекущаяСтрокаЗапросыПакета.ОпцияРазрешенные;
		ЭтаФорма.ОпцияОбщиеИтоги = мТекущаяСтрокаЗапросыПакета.ОпцияОбщиеИтоги;
		ЭтаФорма.ОпцияПервые = мТекущаяСтрокаЗапросыПакета.ОпцияПервые;
		ЭтаФорма.ОпцияАвтоупорядочивание = мТекущаяСтрокаЗапросыПакета.ОпцияАвтоупорядочивание;
		ЭтаФорма.ИмяВременнойТаблицы = мТекущаяСтрокаЗапросыПакета.ИмяВременнойТаблицы;
		ЭтаФорма.ПервыеКоличество = мТекущаяСтрокаЗапросыПакета.ПервыеКоличество;
		ЭтаФорма.КомпоновщикЗапроса = мТекущаяСтрокаЗапросыПакета.Компоновщик;
		ДоступныеПоляПсевдонима.Очистить();
		ОбновитьДоступныеВременныеТаблицы();
		ОбновитьЗаголовкиСтраницПанелиДоступныхТаблиц();
		ПанельОсновнаяОбновитьТекущуюСтраницу();
		Если ЭлементыФормы.ПанельОсновная.ТекущаяСтраница <> ЭлементыФормы.ПанельОсновная.Страницы.ПоляОбъединения Тогда
			ОбновитьТабличноеПолеПоляОбъединения();
		КонецЕсли;
		Если ТипЗапроса = 2 Тогда
			ЭлементыФормы.КомментарийЧасти.УстановитьТекст(мТекущаяСтрокаЗапросыПакета.Комментарий);
			мТекущаяСтрокаЧастиОбъединения = Неопределено;
		Иначе
			Если ЭтаФорма.ЧастиОбъединения.Количество() = 0 Тогда
				ДобавитьЧастьОбъединения(мТекущаяСтрокаЗапросыПакета);
			КонецЕсли; 
			Если Истина
				И ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока = Неопределено 
				И ЧастиОбъединения.Количество() > 0
			Тогда
				ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока = ЧастиОбъединения[0];
			Иначе
				ЧастиОбъединенияПриАктивизацииСтроки();
			КонецЕсли; 
		КонецЕсли; 
		ЛксИзменитьСвернутость(РежимОбъединения, ЭлементыФормы.ПанельЧастей, ЭлементыФормы.вРазделительПанельЧастей, Панель, "лево");
	КонецЕсли; 

КонецПроцедуры

Процедура ДоступныеТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Тип = ДанныеСтроки.Тип;
	ИндексКартинки = ирНеглобальный.ПолучитьИндексКартинкиТипаТаблицыБДЛкс(Тип);
	ОформлениеСтроки.Ячейки.Имя.ОтображатьКартинку = Истина;
	ОформлениеСтроки.Ячейки.Имя.ИндексКартинки = ИндексКартинки;
	
КонецПроцедуры

Процедура ОформитьЯчейкуИмениТаблицы(Элемент, ОформлениеСтроки, ДанныеСтроки, ИмяЯчейкиТаблицы)
	
	ИндексКартинки = Неопределено;
	СтрокаВыбраннойТаблицы = ВыбранныеТаблицы.Найти(ДанныеСтроки[ИмяЯчейкиТаблицы], "Имя");
	Если СтрокаВыбраннойТаблицы = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ИндексКартинки = ПолучитьИндексКартинкиВыбраннойТаблицы(СтрокаВыбраннойТаблицы);
	ОформлениеСтроки.Ячейки[ИмяЯчейкиТаблицы].ОтображатьКартинку = Истина;
	ОформлениеСтроки.Ячейки[ИмяЯчейкиТаблицы].ИндексКартинки = ИндексКартинки;
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	СтрокаДоступнойТаблицы = Неопределено;
	ИндексКартинки = ПолучитьИндексКартинкиВыбраннойТаблицы(ДанныеСтроки, СтрокаДоступнойТаблицы);
	ОформлениеСтроки.Ячейки.Имя.ОтображатьКартинку = Истина;
	ОформлениеСтроки.Ячейки.Имя.ИндексКартинки = ИндексКартинки;
	Если Истина
		И ДанныеСтроки.ВложенныйПакет = Неопределено
		И СтрокаДоступнойТаблицы = Неопределено 
		И Найти(ДанныеСтроки.ПолноеИмя, ".") > 0
	Тогда
		ОформлениеСтроки.ЦветФона = ЦветаСтиля.ирЦветФонаОшибки;
	КонецЕсли; 
	
КонецПроцедуры

Функция ПолучитьИндексКартинкиВыбраннойТаблицы(ДанныеСтроки, выхСтрокаДоступнойТаблицы = Неопределено)

	ИндексКартинки = Неопределено;
	Если ДанныеСтроки.ВложенныйПакет <> Неопределено Тогда
		ИндексКартинки = 0;
	КонецЕсли; 
	Если ИндексКартинки = Неопределено Тогда
		выхСтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ДанныеСтроки.ПолноеИмя), "НПолноеИмя");
		Если выхСтрокаДоступнойТаблицы <> Неопределено Тогда
			Тип = выхСтрокаДоступнойТаблицы.Тип;
		КонецЕсли; 
	КонецЕсли; 
	Если ИндексКартинки = Неопределено Тогда
		ИндексКартинки = ирНеглобальный.ПолучитьИндексКартинкиТипаТаблицыБДЛкс(Тип);
	КонецЕсли;
	Возврат ИндексКартинки;

КонецФункции

Процедура ТипЗапросаПриИзменении(Элемент)
	
	ОбновитьНаименованиеЗапроса(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока);

КонецПроцедуры

Процедура ОбновитьНаименованиеЗапроса(ЗапросПакета) Экспорт
	
	Если ЗапросПакета.ТипЗапроса = 0 Тогда
		ЗапросПакета.Имя = "" + ЗапросПакета.Номер;
		Если ЗапросПакета.ЧастиОбъединения.Количество() > 0 Тогда
			ИмяЧастиОбъединения = Сред(ЗапросПакета.ЧастиОбъединения[0].Имя, СтрДлина("" + ЗапросПакета.ЧастиОбъединения[0].Номер + ",") + 1);
			Если Не ПустаяСтрока(ИмяЧастиОбъединения) Тогда
				ЗапросПакета.Имя = ЗапросПакета.Имя + "," + ИмяЧастиОбъединения;
			КонецЕсли; 
		КонецЕсли; 
	ИначеЕсли ЗапросПакета.ТипЗапроса = 1 Тогда
		ЗапросПакета.Имя = "+" + ЗапросПакета.ИмяВременнойТаблицы;
	ИначеЕсли ЗапросПакета.ТипЗапроса = 2 Тогда
		ЗапросПакета.Имя = "-" + ЗапросПакета.ИмяВременнойТаблицы;
	Иначе
		ЗапросПакета.Имя = "" + ЗапросПакета.Номер;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОбновитьНаименованиеЧасти(ЧастьОбъединения = Неопределено)
	
	Если ЧастьОбъединения = Неопределено Тогда
		ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока;
	КонецЕсли; 
	ИмяЧасти = "" + ЧастьОбъединения.Номер;
	Для Каждого СтрокаВыбраннойТаблицы Из ЧастьОбъединения.ВыбранныеТаблицы Цикл
		Если ИмяЧасти <> "" Тогда
			ИмяЧасти = ИмяЧасти + ",";
		КонецЕсли; 
		ИмяЧасти = ИмяЧасти + СтрокаВыбраннойТаблицы.Имя;
	КонецЦикла;
	ЧастьОбъединения.Имя = ИмяЧасти;
	ЧастьОбъединения.Имя = ирНеглобальный.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ЧастьОбъединения.Владелец(), ЧастьОбъединения,, Ложь);
	
КонецПроцедуры

Процедура ВыбранныеТаблицыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если ВыбраннаяСтрока.ВложенныйПакет <> Неопределено Тогда
		СтандартнаяОбработка = Ложь;
		ОткрытьВложенныйПакет(ВыбраннаяСтрока.ВложенныйПакет);
	КонецЕсли; 
	
КонецПроцедуры

Функция ОткрытьВложенныйПакет(ВложенныйПакет = Неопределено)
	
	ФормаКонструктора = ПолучитьФорму("КонструкторЗапроса", ЭтаФорма);
	ФормаКонструктора.ЭтоВложенныйЗапрос = Истина;
	ФормаКонструктора.УстановитьДиалектSQL(ДиалектSQL);
	ЗаполнитьЗначенияСвойств(ФормаКонструктора, ЭтаФорма, "РасширеннаяПроверка, Английский1С"); 
	Если ВложенныйПакет <> Неопределено Тогда
		ФормаКонструктора.ЗапросыПакета = ВложенныйПакет.Скопировать();
	КонецЕсли; 
	РезультатФормы = ФормаКонструктора.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		ВложенныйПакет = ФормаКонструктора.ЗапросыПакета;
	КонецЕсли; 
	ОбновитьДоступныеВременныеТаблицы();
	Возврат ВложенныйПакет;
	
КонецФункции

Процедура ИмяВременнойТаблицыПриИзменении(Элемент)

	ОбновитьНаименованиеЗапроса(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока);
	
КонецПроцедуры

Процедура ОбновитьНомераЗапросов()
	
	Для Каждого ЗапросПакета Из ЗапросыПакета Цикл
		ЗапросПакета.Номер = ЗапросыПакета.Индекс(ЗапросПакета) + 1; 
		ОбновитьНаименованиеЗапроса(ЗапросПакета);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗапросыПакетаПослеУдаления(Элемент)
	
	ОбновитьНомераЗапросов();
	
КонецПроцедуры

Процедура СохранитьВыбраннуюТаблицу()
	
	Если мТекущаяСтрокаВыбранныеТаблицы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ВыбранныеТаблицы.Индекс(мТекущаяСтрокаВыбранныеТаблицы) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли; 
	СохранитьПараметрТаблицы();
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПриАктивизацииСтроки(Элемент)
	
	СохранитьВыбраннуюТаблицу();
	ЗагрузитьВыбраннуюТаблицу();
	
КонецПроцедуры

Процедура ЗагрузитьВыбраннуюТаблицу()
	
	Элемент = ЭлементыФормы.ВыбранныеТаблицы;
	мТекущаяСтрокаВыбранныеТаблицы = Элемент.ТекущаяСтрока;
	НоваяДоступностьКнопки = Истина
		И мТекущаяСтрокаВыбранныеТаблицы <> Неопределено
		И мТекущаяСтрокаВыбранныеТаблицы.ВложенныйПакет <> Неопределено;
	//ЭлементыФормы.КПВыбранныеТаблицы.Кнопки.ПреобразоватьВПодзапрос.Доступность = НоваяДоступностьКнопки;
	ЭлементыФормы.КПВыбранныеТаблицы.Кнопки.ПеренестиВоВременнуюТаблицу.Доступность = НоваяДоступностьКнопки;
	мТекущееИмяТаблицы = Неопределено;
	ПараметрыТаблицы = ПараметрыТаблицы.СкопироватьКолонки(); // Тут нельзя очищать сущесвующую таблицу, т.к. она может принадлежать кому то
	ЭлементыФормы.ВыражениеПараметраТаблицы.УстановитьТекст("");
	Если мТекущаяСтрокаВыбранныеТаблицы <> Неопределено Тогда
		мТекущееИмяТаблицы = мТекущаяСтрокаВыбранныеТаблицы.Имя;
		ЭтаФорма.ПараметрыТаблицы = мТекущаяСтрокаВыбранныеТаблицы.Параметры;
		ДоступнаяТаблица = ДоступныеТаблицы.Найти(НРег(мТекущаяСтрокаВыбранныеТаблицы.ПолноеИмя), "НПолноеИмя");
		КоличествоПараметровДоступнойТаблицы = 0;
		Если ДоступнаяТаблица <> Неопределено Тогда
			Если ДоступнаяТаблица.Тип = "ВиртуальнаяТаблица" Тогда
				//МассивЗащитыОтРекурсии.Очистить();
				ТаблицаСтруктурТиповКонтекста = ОпределитьТипЗначенияКонтекста(Элемент.ТекущаяСтрока.ПолноеИмя);
				Если ТаблицаСтруктурТиповКонтекста.Количество() > 0 Тогда
					СтруктураТипа = ТаблицаСтруктурТиповКонтекста[0];
					ИмяОбщегоТипа = СтруктураТипа.ИмяОбщегоТипа;
					ИмяВиртуальнойТаблицы = ЛксПолучитьПоследнийФрагмент(ИмяОбщегоТипа);
					ТипКонтекста = Лев(ИмяОбщегоТипа, СтрДлина(ИмяОбщегоТипа) - СтрДлина(ИмяВиртуальнойТаблицы) - 1);
					СтруктураКлюча = Новый Структура("ТипКонтекста, Слово, ЯзыкПрограммы", ТипКонтекста, ИмяВиртуальнойТаблицы, 1);
					НайденныеСтроки = мПлатформа.ТаблицаПараметров.НайтиСтроки(СтруктураКлюча);
					КоличествоПараметровДоступнойТаблицы = НайденныеСтроки.Количество();
					Для Счетчик = 1 По КоличествоПараметровДоступнойТаблицы Цикл
						СтрокаОписанияПараметра = НайденныеСтроки[Счетчик - 1];
						// Защита от двойных параметров для вирт. таблиц регистра бухгалтерии
						СтрокаПараметра = ПараметрыТаблицы.Найти(СтрокаОписанияПараметра.Параметр, "Имя");
						Если СтрокаПараметра <> Неопределено Тогда
							Продолжить;
						КонецЕсли; 
						Если Счетчик > ПараметрыТаблицы.Количество() Тогда
							СтрокаПараметра = ПараметрыТаблицы.Добавить();
							СтрокаПараметра.Номер = Счетчик;
						Иначе
							СтрокаПараметра = ПараметрыТаблицы[Счетчик - 1];
						КонецЕсли; 
						СтрокаПараметра.Имя = СтрокаОписанияПараметра.Параметр;
					КонецЦикла;
				КонецЕсли; 
			КонецЕсли; 
		КонецЕсли; 
		Для Индекс = КоличествоПараметровДоступнойТаблицы По ПараметрыТаблицы.Количество() - 1 Цикл
			СтрокаПараметра = ПараметрыТаблицы[Индекс];
			НомерПараметра = Индекс + 1;
			СтрокаПараметра.Имя = "Неизвестный" + (НомерПараметра);
			СтрокаПараметра.Номер = НомерПараметра;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

Процедура СохранитьПараметрТаблицы()
	
	Если мТекущаяСтрокаПараметраТаблицы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ПараметрыТаблицы.Индекс(мТекущаяСтрокаПараметраТаблицы) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли;
	мТекущаяСтрокаПараметраТаблицы.Определение = ЭлементыФормы.ВыражениеПараметраТаблицы.ПолучитьТекст();
	ОбновитьВыражениеЗапроса(мТекущаяСтрокаПараметраТаблицы,,,,,, Истина);
	
КонецПроцедуры

Процедура ЗагрузитьПараметрТаблицы()
	
	мТекущаяСтрокаПараметраТаблицы = ЭлементыФормы.ПараметрыТаблицы.ТекущаяСтрока;
	Если мТекущаяСтрокаПараметраТаблицы = Неопределено Тогда
		НовыйТекст = "";
	Иначе
		НовыйТекст = мТекущаяСтрокаПараметраТаблицы.Определение;
	КонецЕсли; 
	ЭлементыФормы.ВыражениеПараметраТаблицы.УстановитьТекст(НовыйТекст);
	
КонецПроцедуры

Процедура ПараметрыТаблицыПриАктивизацииСтроки(Элемент = Неопределено)
	
	СохранитьПараметрТаблицы();
	ЗагрузитьПараметрТаблицы();
	
КонецПроцедуры

Процедура КППараметрыТаблицыПодсказатьПараметр(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ПараметрыТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ЭтотОбъект.мНомерПараметра = ТекущаяСтрока.Номер;
	ОткрытьПоискВСинтаксПомощнике(ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока.ПолноеИмя);
	
КонецПроцедуры

Процедура КПДоступныеТаблицыПерейтиКОпределению(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	Если ТекущаяСтрока.Тип = "ВременнаяТаблица" Тогда
		ПородившаяСтрокаПакета = ЗапросыПакета.Найти(ТекущаяСтрока.ПородившийЗапрос, "ИД");
		Если ПородившаяСтрокаПакета <> Неопределено Тогда
			ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока = ПородившаяСтрокаПакета;
		КонецЕсли; 
	Иначе
		ОткрытьПоискВСинтаксПомощнике(ТекущаяСтрока.ПолноеИмя);
	КонецЕсли; 
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыНайтиВСписке(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока <> Неопределено Тогда
		СтрокаДоступнойТаблицы = ДоступныеТаблицы.Найти(НРег(ТекущаяСтрока.ПолноеИмя), "НПолноеИмя");
		Если СтрокаДоступнойТаблицы <> Неопределено Тогда
			ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока = СтрокаДоступнойТаблицы;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьТекущуюЧастьПсевдонима()
	
	ТекущаяКолонка = ЭлементыФормы.ПоляОбъединения.ТекущаяКолонка;
	Если ТекущаяКолонка = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли; 
	ИмяКолонки = ТекущаяКолонка.Данные;
	Если ПоляОбъединения.Колонки.Индекс(ПоляОбъединения.Колонки[ИмяКолонки]) < мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей Тогда
		Возврат Неопределено;
	КонецЕсли; 
	Префикс = "Определение";
	Результат = ЧастиОбъединения.Найти(Число(Сред(ИмяКолонки, СтрДлина(Префикс) + 1)), "Номер");
	Возврат Результат;
	
КонецФункции

Процедура ПсевдонимыПолейПриАктивизацииКолонки(Элемент)
	
	ДоступныеПоляПсевдонима.Очистить();
	ВыбраннаяЧасть = ПолучитьТекущуюЧастьПсевдонима();
	Если ВыбраннаяЧасть = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	СтрокаДоступногоПоля = ДоступныеПоляПсевдонима.Добавить();
	СтрокаДоступногоПоля.Определение = "<Отсутствует>";
	Для Каждого ВыбранноеПоле Из ВыбраннаяЧасть.ВыбранныеПоля Цикл
		СтрокаДоступногоПоля = ДоступныеПоляПсевдонима.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаДоступногоПоля, ВыбранноеПоле); 
	КонецЦикла;
	ПсевдонимыПолейПриАктивизацииСтроки();
	
КонецПроцедуры

Процедура ВыбранныеПоляЧастиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если Истина
		И ДанныеСтроки.Имя = "" 
		И ДанныеСтроки.Определение <> "<Отсутствует>"
	Тогда
		ОформлениеСтроки.ЦветФона = ЦветаСтиля.ирЦветФонаОшибки;
	КонецЕсли;
	
КонецПроцедуры

Процедура ДоступныеПоляПсевдонимаПриАктивизацииСтроки(Элемент)
	
	Если Элемент.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	СтароеИмяПоля = Элемент.ТекущаяСтрока.Имя;
	ВыбраннаяЧасть = ПолучитьТекущуюЧастьПсевдонима();
	Если ВыбраннаяЧасть = Неопределено Тогда
		Возврат;
	КонецЕсли;
	СтараяСвязьПоля = ПоляОбъединения.Найти(СтароеИмяПоля, "Имя");
	Если СтараяСвязьПоля = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока Тогда
		Возврат;
	КонецЕсли; 
	Если СтараяСвязьПоля <> Неопределено Тогда
		СтараяСвязьПоля["_" + ВыбраннаяЧасть.Номер] = Неопределено;
		СтараяСвязьПоля["Определение" + ВыбраннаяЧасть.Номер] = Неопределено; // <Отсутствует>
		УдалитьСтаруюСтроку = Истина;
		Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
			Если ЗначениеЗаполнено(СтараяСвязьПоля["_" + ЧастьОбъединения.Номер]) Тогда
				УдалитьСтаруюСтроку = Ложь;
				Прервать;
			КонецЕсли; 
		КонецЦикла;
		Если УдалитьСтаруюСтроку Тогда
			ПоляОбъединения.Удалить(СтараяСвязьПоля);
		КонецЕсли; 
	КонецЕсли; 
	Если ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	НовоеИмя = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока.Имя;
	СтрокаДляОтвязки = ДоступныеПоляПсевдонима.Найти(НовоеИмя, "Имя");
	Если СтрокаДляОтвязки <> Неопределено Тогда
		СтрокаНовогоПсевдонима = ПоляОбъединения.Добавить();
		АвтоПсевдонимОтвязанногоПоля = ПолучитьАвтоПсевдонимПоля(СтрокаДляОтвязки, ВыбраннаяЧасть);
		АвтоПсевдонимОтвязанногоПоля = ирНеглобальный.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ПоляОбъединения, АвтоПсевдонимОтвязанногоПоля);
		СтрокаНовогоПсевдонима.Имя = АвтоПсевдонимОтвязанногоПоля;
		ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаНовогоПсевдонима);
		ЗаполнитьЗначенияСвойств(СтрокаНовогоПсевдонима, ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока, "_" + ВыбраннаяЧасть.Номер + "," + "Определение" + ВыбраннаяЧасть.Номер); 
		ВыбранноеПоле = ВыбраннаяЧасть.ВыбранныеПоля.Найти(СтрокаДляОтвязки.ИД, "ИД");
		СтрокаНовогоПсевдонима.ТипЗначения = ВыбранноеПоле.ТипЗначения;
		СтрокаДляОтвязки.Имя = АвтоПсевдонимОтвязанногоПоля;
		ВыбранноеПоле.Имя = АвтоПсевдонимОтвязанногоПоля;
	КонецЕсли; 
	Если Элемент.ТекущаяСтрока.Определение <> "<Отсутствует>" Тогда
		Элемент.ТекущаяСтрока.Имя = НовоеИмя; 
	КонецЕсли; 
	СтрокаВыбранногоПоля = ВыбраннаяЧасть.ВыбранныеПоля.Найти(Элемент.ТекущаяСтрока.ИД, "ИД");
	Если СтрокаВыбранногоПоля <> Неопределено Тогда
		СтрокаВыбранногоПоля.Имя = НовоеИмя;
	КонецЕсли; 
	ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока["_" + ВыбраннаяЧасть.Номер] = Элемент.ТекущаяСтрока.ИД;
	ОпределениеПоля = Элемент.ТекущаяСтрока.Определение;
	Если ОпределениеПоля = "<Отсутствует>" Тогда
		ОпределениеПоля = "";
	КонецЕсли; 
	ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока["Определение" + ВыбраннаяЧасть.Номер] = ОпределениеПоля;
	ОбновитьТипЗначенияПоляОбъединения();
	
КонецПроцедуры

Процедура ОбновитьТипЗначенияПоляОбъединения(ЗапросПакета = Неопределено, ПолеОбъединения = Неопределено)
	
	Если ПолеОбъединения = Неопределено Тогда
		ПолеОбъединения = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока;
	КонецЕсли;
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли;
	Результат = Новый ОписаниеТипов();
	Для Каждого ЧастьОбъединения Из ЗапросПакета.ЧастиОбъединения Цикл
		ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля.Найти(ПолеОбъединения["_" + ЧастьОбъединения.Номер], "ИД");
		Если ВыбранноеПоле <> Неопределено Тогда
			ТипЗначенияПоляЧасти = ВыбранноеПоле.ТипЗначения;
		Иначе
			ТипЗначенияПоляЧасти = Новый ОписаниеТипов("Null");
		КонецЕсли; 
		Результат = Новый ОписаниеТипов(Результат, ТипЗначенияПоляЧасти.Типы());
	КонецЦикла;
	ПолеОбъединения.ТипЗначения = Результат;
	
КонецПроцедуры

Процедура ПсевдонимыПолейПриАктивизацииСтроки(Элемент = Неопределено)
	
	Элемент = ЭлементыФормы.ПоляОбъединения;
	ВыбраннаяЧасть = ПолучитьТекущуюЧастьПсевдонима();
	Если ВыбраннаяЧасть = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	СтрокаДоступногоПоля = ДоступныеПоляПсевдонима.Найти(Элемент.ТекущаяСтрока.Имя, "Имя");
	ИД = Элемент.ТекущаяСтрока["_" + ВыбраннаяЧасть.Номер];
	Если СтрокаДоступногоПоля <> Неопределено Тогда
		Если СтрокаДоступногоПоля.ИД = ИД Тогда
			ЭлементыФормы.ДоступныеПоляПсевдонима.ТекущаяСтрока = СтрокаДоступногоПоля;
		КонецЕсли; 
	ИначеЕсли Истина
		И Не ЗначениеЗаполнено(ИД)
		И ДоступныеПоляПсевдонима.Количество() > 0 
	Тогда
		ЭлементыФормы.ДоступныеПоляПсевдонима.ТекущаяСтрока = ДоступныеПоляПсевдонима[0];
	КонецЕсли; 
	
КонецПроцедуры

Процедура ПсевдонимыПолейИмяПриИзменении(Элемент)
	
	ПриИзмененииИмениПоляОбъединения();
	
КонецПроцедуры

Процедура ПриИзмененииИмениПоляОбъединения(ПолеОбъединения = Неопределено)
	
	Если ПолеОбъединения = Неопределено Тогда
		ПолеОбъединения = ЭлементыФормы.ПоляОбъединения.ТекущаяСтрока;
	КонецЕсли;
	ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ПолеОбъединения);
	Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
		ИД = ПолеОбъединения["_" + ЧастьОбъединения.Номер];
		Если ЗначениеЗаполнено(ИД) Тогда
			СтрокаВыбранногоПоля = ЧастьОбъединения.ВыбранныеПоля.Найти(ИД, "ИД");
			СтрокаВыбранногоПоля.Имя = ирНеглобальный.ПолучитьАвтоУникальноеИмяВКоллекцииСтрокЛкс(ПоляОбъединения, ПолеОбъединения,, Ложь,
				ПолучитьСловоЯзыкаЗапросов("Field"));
			ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаВыбранногоПоля);
			//Если ЧастьОбъединения = ЭлементыФормы.ЧастиОбъединения.ТекущаяСтрока Тогда
			//	СтрокаВыбранногоПоля = ВыбранныеПоля.Найти(ИД, "ИД");
			//	СтрокаВыбранногоПоля.Имя = Элемент.Значение;
			//КонецЕсли; 
		КонецЕсли; 
	КонецЦикла;

КонецПроцедуры


Процедура ДоступныеПоляИндексаВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтрокаПоля = ПоляИндекса.Найти(ВыбраннаяСтрока.Имя, "Определение");
	Если СтрокаПоля = Неопределено Тогда
		СтрокаПоля = ПоляИндекса.Добавить();
		СтрокаПоля.Определение = ВыбраннаяСтрока.Имя;
	КонецЕсли; 
	ЭлементыФормы.ПоляИндекса.ТекущаяСтрока = СтрокаПоля;
	
КонецПроцедуры

Процедура ПсевдонимыПолейПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Для Каждого ЧастьОбъединения Из ЧастиОбъединения Цикл
		ИмяКолонки = "Определение" + ЧастьОбъединения.Номер;
		ИДПоля = ДанныеСтроки["_" + ЧастьОбъединения.Номер];
		Если Не ЗначениеЗаполнено(ИДПоля) Тогда
			Продолжить;
		КонецЕсли; 
		ВыбранноеПоле = ЧастьОбъединения.ВыбранныеПоля.Найти(ИДПоля, "ИД");
		ИндексКартинки = ирНеглобальный.ПолучитьИндексКартинкиТипаЛкс(ВыбранноеПоле.ТипЗначения);
		ОформлениеСтроки.Ячейки[ИмяКолонки].ИндексКартинки = ИндексКартинки;
		ОформлениеСтроки.Ячейки[ИмяКолонки].ОтображатьКартинку = Истина;
		Если ВыбранноеПоле.Автополе Тогда
			ОформлениеСтроки.Ячейки[ИмяКолонки].ЦветФона = ЦветаСтиля.ирЦветФонаВычисляемогоЗначения;
		КонецЕсли; 
	КонецЦикла;
	
КонецПроцедуры

Процедура ДеревоУсловияСвязиПриИзмененииФлажка(Элемент, Колонка)
	
	Если Элемент.Колонки.Произвольное = Колонка Тогда
		ПереключитьРежимПроизвольногоВыраженияОтбора(Элемент, Колонка);
		ЗагрузитьВыражениеУсловияСвязи();
	КонецЕсли; 

КонецПроцедуры

////////////
// Отбор

Процедура ПереключитьРежимПроизвольногоВыраженияОтбора(ТабличноеПоле, Колонка)

	ТекущееЗначениеФлажка = ТабличноеПоле.ТекущаяСтрока.Представление <> "";
	Если ТекущееЗначениеФлажка Тогда
		ТабличноеПоле.ТекущаяСтрока.Представление = "";
	Иначе
		ТабличноеПоле.ТекущаяСтрока.Представление = ПолучитьВыражениеЭлементаОтбораЛкс(ТабличноеПоле.ТекущаяСтрока);
	КонецЕсли; 

КонецПроцедуры

Процедура ОбновитьЭлементОтбораПослеИзменения(Элемент)

	Если ТипЗнч(Элемент.ТекущаяСтрока) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		СтароеПравоеЗначение = Элемент.ТекущаяСтрока.ПравоеЗначение;
		ПолучитьВыражениеЭлементаОтбораЛкс(Элемент.ТекущаяСтрока);
		Если СтароеПравоеЗначение <> Элемент.ТекущаяСтрока.ПравоеЗначение Тогда
			ОбновитьКомпоновщикЧастиОбъединения(); // Тут дерево доступных полей сбрасывает все развернутости. Возможно лучше отключить
		КонецЕсли; 
	КонецЕсли; 

КонецПроцедуры

Процедура КПДоступныеТаблицыОтборБезЗначенияВТекущейКолонке(Кнопка)
	
	ирНеглобальный.ТабличноеПоле_ОтборБезЗначенияВТекущейКолонке_КнопкаЛкс(ЭлементыФормы.ДоступныеТаблицы);

КонецПроцедуры

Процедура ПараметрыТаблицыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "ПараметрВиртуальнойТаблицы";
	ФормаКонструктораВыражения.Выражение = ВыбраннаяСтрока.Определение;
	ФормаКонструктораВыражения.ШаблонПолноеИмяТаблицы = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока.ПолноеИмя;
	ФормаКонструктораВыражения.ШаблонНомерПараметра = ВыбраннаяСтрока.Номер;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		ВыбраннаяСтрока.Определение = РезультатФормы;
		ЗагрузитьПараметрТаблицы();
	КонецЕсли; 
	
КонецПроцедуры

Функция СобратьТекстИЗДляВыраженияУсловия() Экспорт
	
	Результат = "";
	Для Каждого ВыбраннаяТаблица Из ВыбранныеТаблицы Цикл
		Если Результат <> "" Тогда
			Результат = Результат + ",";
		КонецЕсли; 
		ОпределениеТаблицы = ПолучитьОпределениеТаблицы(ВыбраннаяТаблица);
		Результат = Результат + ОпределениеТаблицы;
	КонецЦикла;
	Если ЗначениеЗаполнено(Результат) Тогда
		Результат = "ИЗ " + Результат;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции

Процедура ДеревоУсловияВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если ВыбраннаяСтрока.Представление = "" Тогда
		Возврат;
	КонецЕсли; 
	СохранитьВыражениеУсловия();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "УсловиеОтбора";
	ФормаКонструктораВыражения.Выражение = ВыбраннаяСтрока.Представление;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		ВыбраннаяСтрока.Представление = РезультатФормы;
		ЗагрузитьВыражениеУсловия();
	КонецЕсли; 

КонецПроцедуры

Процедура ДеревоУсловияСвязиВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если ВыбраннаяСтрока.Представление = "" Тогда
		Возврат;
	КонецЕсли; 
	СохранитьВыражениеУсловияСвязи();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "УсловиеОтбора";
	ФормаКонструктораВыражения.Выражение = ВыбраннаяСтрока.Представление;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		ВыбраннаяСтрока.Представление = РезультатФормы;
		ЗагрузитьВыражениеУсловияСвязи();
	КонецЕсли; 

КонецПроцедуры

Процедура ПолеТекстаОтображаетПакетПриИзменении(Элемент)
	
	ПересобратьВременныйПолныйТекст();
	ЭлементыФормы.КПТекст.Кнопки.Редактировать.Доступность = ПолеТекстаОтображаетПакет;
	
КонецПроцедуры

Процедура КПТекстОтменитьРедактирование(Кнопка)
	
	ПереключитьРежимРедактированияТекста();
	ПересобратьВременныйПолныйТекст();
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыПеренестиВоВременнуюТаблицу(Кнопка)
	
	ЗапросПакета = ЗапросыПакета.Вставить(ЗапросыПакета.Индекс(ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока));
	ТекущаяСтрока = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока;
	ЗаполнитьЗначенияСвойств(ЗапросПакета, ТекущаяСтрока.ВложенныйПакет[0]);
	ЗапросПакета.ИмяВременнойТаблицы = ТекущаяСтрока.Имя;
	ЗапросПакета.ТипЗапроса = 1;
	ОбновитьНаименованиеЗапроса(ЗапросПакета);
	ОбновитьДоступныеВременныеТаблицы();
	ТекущаяСтрока.ПолноеИмя = ТекущаяСтрока.Имя;
	ТекущаяСтрока.ВложенныйПакет = Неопределено;
	
КонецПроцедуры

Процедура ГруппирующиеПоляИтоговИмяПриИзменении(Элемент)
	
	ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ЭлементыФормы.ГруппирующиеПоляИтогов.ТекущаяСтрока);
	
КонецПроцедуры

Процедура ОсновныеДействияФормыПроверить(Кнопка)
	
	ОбновитьВсеВыражения();
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыЗаменитьТаблицу(Кнопка)
	
	//Если мТекущаяСтрокаВыбранныеТаблицы = Неопределено Тогда
	//	Предупреждение("Необходимо активизировать строку выбранной таблицы, в которой заменить", 20);
	//	Возврат;
	//КонецЕсли; 
	ТекущаяДоступнаяТаблица = ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока;
	Если ТекущаяДоступнаяТаблица = Неопределено Тогда
		Предупреждение("Необходимо активизировать строку доступной таблицы, на которую заменить", 20);
		Возврат;
	КонецЕсли; 
	Ответ = Вопрос("Вы действительно хотите заменить определение таблицы """ + мТекущаяСтрокаВыбранныеТаблицы.Имя + """
		|с " + мТекущаяСтрокаВыбранныеТаблицы.ПолноеИмя + " на " + ТекущаяДоступнаяТаблица.ПолноеИмя + "?", РежимДиалогаВопрос.ОКОтмена);
	Если Ответ = КодВозвратаДиалога.ОК Тогда
		мТекущаяСтрокаВыбранныеТаблицы.ПолноеИмя = ТекущаяДоступнаяТаблица.ПолноеИмя;
		ЗагрузитьВыбраннуюТаблицу();
	КонецЕсли;
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПередУдалением(Элемент, Отказ)

	Ответ = Вопрос("Вы действительно хотите удалить из выбранных таблиц """ + мТекущаяСтрокаВыбранныеТаблицы.Имя + """?", РежимДиалогаВопрос.ОКОтмена);
	Если Ответ <> КодВозвратаДиалога.ОК Тогда
		Отказ = Истина;
	КонецЕсли;
	НачальноеКоличество = СвязиТаблиц.Количество(); 
	Для СчетчикСвязиТаблиц = 1 По НачальноеКоличество Цикл
		СвязьТаблиц = СвязиТаблиц[НачальноеКоличество - СчетчикСвязиТаблиц];
		Если Ложь
			Или ирНеглобальный.СтрокиРавныЛкс(СвязьТаблиц.ЛеваяТаблица, мТекущаяСтрокаВыбранныеТаблицы.Имя)
			Или ирНеглобальный.СтрокиРавныЛкс(СвязьТаблиц.ПраваяТаблица, мТекущаяСтрокаВыбранныеТаблицы.Имя)
		Тогда
			СвязиТаблиц.Удалить(СвязьТаблиц);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ВыбранныеТаблицыПриИзмененииФлажка(Элемент, Колонка)
	
	Если Колонка = ЭлементыФормы.ВыбранныеТаблицы.Колонки.ВсеПоля Тогда
		Если Элемент.ТекущаяСтрока[Колонка.ДанныеФлажка] Тогда
			ДобавитьВсеПоляТаблицыВВыбранныеПоля(Элемент.ТекущаяСтрока.Имя,,,, Истина);
		Иначе
			Для Каждого ВыбранноеПоле Из ВыбранныеПоля Цикл
				Если Ложь
					Или Не ПараметрыДиалектаSQL.МногоТаблиц 
					Или (Истина
						И ирНеглобальный.СтрокиРавныЛкс(ЛксПолучитьПервыйФрагмент(ВыбранноеПоле.Определение), Элемент.ТекущаяСтрока.Имя)
						И ВыбранноеПоле.Автополе)
				Тогда
					ВыбранноеПоле.Автополе = Ложь;
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли; 
	КонецЕсли; 
	
КонецПроцедуры

Процедура ВыбранныеПоляПередУдалением(Элемент, Отказ)
	
	Отказ = Элемент.ТекущаяСтрока.Автополе;

КонецПроцедуры

Процедура ВыбранныеПоляПередНачаломИзменения(Элемент, Отказ)
	
	Отказ = Элемент.ТекущаяСтрока.Автополе;

КонецПроцедуры

Процедура ДоступныеПоляВыбораПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ЭтоНедоступноеДоступноеПоле(ДанныеСтроки) Тогда
		ОформлениеСтроки.Ячейки.Заголовок.УстановитьТекст("<Недоступно>");
	КонецЕсли; 

КонецПроцедуры

Функция ЭтоНедоступноеДоступноеПоле(ДоступноеПоле)
	
	Результат = Ложь
		Или ирНеглобальный.СтрокиРавныЛкс("СистемныеПоля", "" + ДоступноеПоле.Поле)
		Или (Истина
			И ДоступноеПоле.Родитель <> Неопределено
			И ирНеглобальный.СтрокиРавныЛкс("СистемныеПоля", "" + ДоступноеПоле.Родитель.Поле));
	Возврат Результат;
	
КонецФункции

Процедура ВыбранныеПоляПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	
	
КонецПроцедуры

Процедура ПараметрыТаблицыПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ТипЗнч(ДанныеСтроки) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Если ДанныеСтроки.Представление <> "" Тогда
			Возврат;
		КонецЕсли; 
		Токен = ДанныеСтроки.ПравоеЗначение;
	ИначеЕсли ТипЗнч(ДанныеСтроки) = Тип("СтрокаТаблицыЗначений") Тогда
		Токен = ДанныеСтроки.Токен;
	Иначе
		Возврат;
	КонецЕсли; 
	Если Токен = Неопределено Тогда
		ОформлениеСтроки.ЦветФона = ЦветаСтиля.ирЦветФонаОшибки;
	КонецЕсли; 

КонецПроцедуры

Процедура ГруппировкиПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ПоляПорядкаПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);
	
КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	ТабличноеПолеТаблицыВыраженийПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки);

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПриАктивизацииСтроки(Элемент)
	
	СохранитьГруппируемоеПоле();
	ЗагрузитьГруппируемоеПоле();
	
КонецПроцедуры

Процедура СохранитьГруппируемоеПоле()
	
	Если мТекущаяСтрокаГруппируемогоПоля = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ГруппируемыеПоляИтогов.Индекс(мТекущаяСтрокаГруппируемогоПоля) = -1 Тогда
		// Строка была удалена
		Возврат;
	КонецЕсли;
	мТекущаяСтрокаГруппируемогоПоля.Определение = ЭлементыФормы.ВыражениеГруппируемогоПоля.ПолучитьТекст();
	ОбновитьВыражениеЗапроса(мТекущаяСтрокаГруппируемогоПоля,,,,,,,, Ложь);

КонецПроцедуры

Процедура ЗагрузитьГруппируемоеПоле()
	
	мТекущаяСтрокаГруппируемогоПоля = ЭлементыФормы.ГруппируемыеПоляИтогов.ТекущаяСтрока;
	Если мТекущаяСтрокаГруппируемогоПоля = Неопределено Тогда
		ВыражениеПоля = "";
		РазрешеноИзменение = Ложь;
	Иначе
		ВыражениеПоля = мТекущаяСтрокаГруппируемогоПоля.Определение;
		РазрешеноИзменение = Истина;
	КонецЕсли; 
	ЭлементыФормы.ВыражениеГруппируемогоПоля.УстановитьТекст(ВыражениеПоля);
	ЭлементыФормы.ВыражениеГруппируемогоПоля.Доступность = РазрешеноИзменение;
	
КонецПроцедуры

Процедура ГруппировкиПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	
	Если Не ОтменаРедактирования Тогда
		//ЭлементыФормы.ВыражениеГруппируемогоПоля.УстановитьТекст(мТекущаяСтрокаГруппируемогоПоля.Представление);
		ОбновитьВыражениеЗапроса(Элемент.ТекущиеДанные);
	КонецЕсли; 
	
КонецПроцедуры

Процедура АвтогруппировкиПриИзменении(Элемент)
	
	ОбновитьГруппировки();
	
КонецПроцедуры

Процедура ВыбранныеПоляАгрегатнаяФункцияПриИзменении(Элемент)
	
	ТокенАргументаФункции = Неопределено;
	ТекущаяАгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(мТекущаяСтрокаВыбранногоПоля.Токен, ТокенАргументаФункции); 
	ВыражениеПоля = СобратьВыражениеЗапроса(ТокенАргументаФункции);
	Если ЗначениеЗаполнено(Элемент.Значение) Тогда
		ВыражениеПоля = Элемент.Значение + ВыражениеПоля + ")";
	КонецЕсли; 
	мТекущаяСтрокаВыбранногоПоля.Определение = ВыражениеПоля;
	ВыбранныеПоляОпределениеПриИзменении();
	
КонецПроцедуры

Процедура ВыбранныеПоляОпределениеПриИзменении(Элемент = Неопределено)
	
	ПриИзмененииВыраженияВыбранногоПоля();
	
КонецПроцедуры

Процедура ОсновныеДействияФормыКонструкторЗапроса(Кнопка)
	
	Если Не мРежимРедактированияТекста Тогда
		ПереключитьРежимРедактированияТекста();
	КонецЕсли; 
	Компонента = ПолеТекстовогоДокументаСКонтекстнойПодсказкой[ЭлементыФормы.ПолеТекстаЗапроса.Имя];
	Компонента.ВызватьКонструкторЗапросов(Истина);
	
КонецПроцедуры

Процедура ГруппируемыеПоляИтоговАгрегатнаяФункцияПриИзменении(Элемент = Неопределено)
	
	ТокенАргументаФункции = Неопределено;
	ТекущаяАгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(мТекущаяСтрокаГруппируемогоПоля.Токен, ТокенАргументаФункции); 
	ВыражениеПоля = СобратьВыражениеЗапроса(ТокенАргументаФункции,,,,,,, Ложь);
	Если ЗначениеЗаполнено(мТекущаяСтрокаГруппируемогоПоля.АгрегатнаяФункция) Тогда
		ВыражениеПоля = мТекущаяСтрокаГруппируемогоПоля.АгрегатнаяФункция + ВыражениеПоля + ")";
	КонецЕсли; 
	мТекущаяСтрокаГруппируемогоПоля.Определение = ВыражениеПоля;
	ПриИзмененииВыраженияГруппируемогоПоля();

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговОпределениеПриИзменении(Элемент)
	
	ПриИзмененииВыраженияГруппируемогоПоля();

КонецПроцедуры

Процедура ПриИзмененииВыраженияГруппируемогоПоля(ГруппируемоеПоле = Неопределено, ЗапросПакета = Неопределено)

	Если ГруппируемоеПоле = Неопределено Тогда
		ГруппируемоеПоле = мТекущаяСтрокаГруппируемогоПоля;
	КонецЕсли; 
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	ЕстьАгрегаты = Ложь;
	ОбновитьВыражениеЗапроса(ГруппируемоеПоле,,,,,,, ЕстьАгрегаты, Ложь);
	//ВыбранноеПоле.ТипЗначения = ПолучитьТипЗначенияВыражения(ГруппируемоеПоле.Токен);
	ГруппируемоеПоле.АгрегатнаяФункция = ПолучитьАгрегатнуюФункцию(ГруппируемоеПоле.Токен);
	//ГруппируемоеПоле.ЕстьАгрегаты = ЕстьАгрегаты;
	ЗагрузитьГруппируемоеПоле();

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если Ложь
			Или ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("СтрокаТаблицыЗначений")
		Тогда
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
		КонецЕсли;
	КонецЕсли; 

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)

	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если Ложь
			Или ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("СтрокаТаблицыЗначений")
		Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьДоступноеПолеВГруппируемыеПоля(СтрокаПеретаскивания);
			КонецЦикла;  
		КонецЕсли; 
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьДоступноеПолеВГруппируемыеПоля(ПолеОбъединения)

	Если Ложь
		Или ЗначениеЗаполнено(ПолеОбъединения.РольИтога) 
		Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения"))
	Тогда
		Возврат;
	КонецЕсли; 
	ТабличноеПоле = ЭлементыФормы.ГруппируемыеПоляИтогов;
	СтрокаГруппируемогоПоля = ГруппируемыеПоляИтогов.Найти(ПолеОбъединения.Имя, "Имя");
	Если СтрокаГруппируемогоПоля = Неопределено Тогда
		СтрокаГруппируемогоПоля = ГруппируемыеПоляИтогов.Добавить();
		АгрегатнаяФункция = "COUNT(DISTINCT ";
		Если ПолеОбъединения.ТипЗначения.СодержитТип(Тип("Число")) Тогда
			АгрегатнаяФункция = "SUM(";
		ИначеЕсли Ложь
			Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("Булево"))
			Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("Строка"))
			Или ПолеОбъединения.ТипЗначения.СодержитТип(Тип("Дата"))
		Тогда
			АгрегатнаяФункция = "MAX(";
		КонецЕсли; 
		СтрокаГруппируемогоПоля.Определение = АгрегатнаяФункция + ПолеОбъединения.Имя + ")";
		СтрокаГруппируемогоПоля.Имя = ПолеОбъединения.Имя;
		ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(СтрокаГруппируемогоПоля);
		//ПолеОбъединения.РольИтога = 2; // так не будет работать, т.к. при перетаскивании созадается копия строки
		ОбновитьРолиИтогов();
	КонецЕсли; 
	ТабличноеПоле.ТекущаяСтрока = СтрокаГруппируемогоПоля;
	ПриИзмененииВыраженияГруппируемогоПоля(); // Надо делать после активизации строки

КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПослеУдаления(Элемент)
	
	ОбновитьРолиИтогов();
	
КонецПроцедуры

Процедура ОбновитьРолиИтогов(ЗапросПакета = Неопределено)
	
	Если ЗапросПакета = Неопределено Тогда
		ЗапросПакета = ЭлементыФормы.ЗапросыПакета.ТекущаяСтрока;
	КонецЕсли; 
	ЗапросПакета.ПоляОбъединения.ЗаполнитьЗначения(Неопределено, "РольИтога");
	Для Каждого ГруппирующееПоле Из ЗапросПакета.ГруппирующиеПоляИтогов Цикл
		ПолеОбъединения = ЗапросПакета.ПоляОбъединения.Найти(Нрег(ГруппирующееПоле.Определение), "НИмя");
		Если ПолеОбъединения <> Неопределено Тогда
			ПолеОбъединения.РольИтога = 1;
		КонецЕсли; 
	КонецЦикла;
	Для Каждого ГруппируемоеПоле Из ЗапросПакета.ГруппируемыеПоляИтогов Цикл
		ПолеОбъединения = ЗапросПакета.ПоляОбъединения.Найти(НРег(ГруппируемоеПоле.Имя), "НИмя");
		Если ПолеОбъединения <> Неопределено Тогда
			ПолеОбъединения.РольИтога = 2;
		КонецЕсли; 
	КонецЦикла;
	
КонецПроцедуры

Процедура ДоступныеПоляИтоговПриВыводеСтроки(Элемент, ОформлениеСтроки, ДанныеСтроки)
	
	Если ЗначениеЗаполнено(ДанныеСтроки.РольИтога) Тогда
		ОформлениеСтроки.ЦветФона = ЦветаСтиля.ирЦветФонаЧередованияСтрок;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПроверкаПеретаскивания(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если Ложь
			Или ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("СтрокаТаблицыЗначений")
		Тогда
			СтандартнаяОбработка = Ложь;
			ПараметрыПеретаскивания.ДопустимыеДействия = ДопустимыеДействияПеретаскивания.Копирование;
		КонецЕсли;
	КонецЕсли; 
	
КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПеретаскивание(Элемент, ПараметрыПеретаскивания, СтандартнаяОбработка, Строка, Колонка)
	
	ЗначениеПеретаскивания = ПараметрыПеретаскивания.Значение;
	Если ТипЗнч(ЗначениеПеретаскивания) = Тип("Массив") Тогда
		Если Ложь
			Или ТипЗнч(ЗначениеПеретаскивания[0]) = Тип("СтрокаТаблицыЗначений")
		Тогда
			СтандартнаяОбработка = Ложь;
			Для Каждого СтрокаПеретаскивания Из ЗначениеПеретаскивания Цикл
				ДобавитьПолеОбъединенияВГруппирующиеПоля(СтрокаПеретаскивания);
			КонецЦикла;  
		КонецЕсли; 
	КонецЕсли;

КонецПроцедуры

Процедура ДоступныеПоляГруппировокВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	ДобавитьДоступноеПолеВГруппировки(ВыбраннаяСтрока);
	
КонецПроцедуры

Процедура ДобавитьДоступноеПолеВГруппировки(ДоступноеПоле)
	
	Если Автогруппировки Тогда
		Возврат;
	КонецЕсли; 
	//Если ЭтоНедоступноеДоступноеПоле(ВыбраннаяСтрока) Тогда
	//	Возврат;
	//КонецЕсли; 
	Если ДоступноеПоле.ТипЗначения.СодержитТип(Тип("ХранилищеЗначения")) Тогда
		Возврат;
	КонецЕсли; 
	СтандартнаяОбработка = Ложь;
	ОпределениеПоля = ПолучитьПолноеИмяДоступногоПоля(ДоступноеПоле);
	СтрокаГруппировки = Группировки.Найти(ОпределениеПоля, "Определение");
	Если СтрокаГруппировки = Неопределено Тогда
		СтрокаГруппировки = Группировки.Добавить();
		СтрокаГруппировки.Определение = ОпределениеПоля;
	КонецЕсли; 
	ЭлементыФормы.Группировки.ТекущаяСтрока = СтрокаГруппировки;

КонецПроцедуры

Процедура ВыбранныеПоляОпределениеНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	//СохранитьВыбранноеПоле();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "ВыбранноеПоле";
	ФормаКонструктораВыражения.Выражение = Элемент.Значение;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЧасти; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		Элемент.Значение = РезультатФормы;
		ПриИзмененииВыраженияВыбранногоПоля();
	КонецЕсли; 

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговОпределениеНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	//СохранитьГруппируемоеПоле();
	СтандартнаяОбработка = Ложь;
	ФормаКонструктораВыражения = ПолучитьФорму("КонструкторВыраженияЗапроса", Элемент);
	ФормаКонструктораВыражения.ТипВыражения = "ПолеИтога";
	ФормаКонструктораВыражения.Выражение = Элемент.Значение;
	ФормаКонструктораВыражения.КонструкторЗапроса = ЭтаФорма;
	ФормаКонструктораВыражения.ДиалектSQL = ДиалектSQL; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.ШаблонТекстИз = СобратьТекстИЗДляВыраженияУсловия(); // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.КомпоновщикНастроек = КомпоновщикЗапроса; // Это можно уже вызывать внутри конструктора выражения
	ФормаКонструктораВыражения.Параметры = Параметры; // Это можно уже вызывать внутри конструктора выражения
	РезультатФормы = ФормаКонструктораВыражения.ОткрытьМодально();
	Если РезультатФормы <> Неопределено Тогда
		Элемент.Значение = РезультатФормы;
		ПриИзмененииВыраженияГруппируемогоПоля();
	КонецЕсли; 

КонецПроцедуры

Процедура ВыбранныеПоляПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если Не НоваяСтрока Тогда
		СохранитьВыбранноеПоле();
	КонецЕсли; 
	
КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	
	Если Не НоваяСтрока Тогда
		СохранитьГруппируемоеПоле();
	КонецЕсли; 

КонецПроцедуры

Процедура ГруппируемыеПоляИтоговПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура ГруппирующиеПоляИтоговПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура ПоляПорядкаПередНачаломДобавления(Элемент, Отказ, Копирование)
	
	Отказ = Истина;
	
КонецПроцедуры

Процедура КомментарийНачалоВыбора(Элемент, СтандартнаяОбработка)
	
	ирНеглобальный.ПолеВводаТекста_НачалоВыбораЛкс(Элемент, СтандартнаяОбработка);
	
КонецПроцедуры

Процедура ВыбранныеПоляИмяПриИзменении(Элемент)
	
	СтрокаПоляОбъединения = ПоляОбъединения.Найти(мТекущаяСтрокаВыбранногоПоля.ИД, "_" + мТекущаяСтрокаЧастиОбъединения.Номер);
	СтрокаПоляОбъединения.Имя = мТекущаяСтрокаВыбранногоПоля.Имя;
	ПриИзмененииИмениПоляОбъединения(СтрокаПоляОбъединения);
	
КонецПроцедуры

Процедура СвязиТаблицПослеУдаления(Элемент)
	
	ЗагрузитьСвязьТаблицы();
	
КонецПроцедуры

// Параметры:
//  Тип - Число -
//           0 - Элемент
//           1 - Выражение
//           2 - Группа-И
//           3 - Группа-Или
//           4 - Группа-Не
//
Процедура ДобавитьСтрокуВТабличноеПолеОтбора(ТабличноеПолеОтбора, Тип = 0)
	
	ТекущаяСтрокаОтбора = ТабличноеПолеОтбора.ТекущаяСтрока;
	Если Тип > 1 Тогда
		ТипСтроки = Тип("ГруппаЭлементовОтбораКомпоновкиДанных");
	Иначе
		ТипСтроки = Тип("ЭлементОтбораКомпоновкиДанных");
	КонецЕсли; 
	Если ТекущаяСтрокаОтбора = Неопределено Тогда
		ТекущаяСтрокаОтбора = ТабличноеПоле.Значение;
	КонецЕсли; 
	Если Ложь
		Или ТипЗнч(ТекущаяСтрокаОтбора) = Тип("ОтборКомпоновкиДанных") 
		Или ТипЗнч(ТекущаяСтрокаОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") 
	Тогда
		НоваяСтрока = ТекущаяСтрокаОтбора.Элементы.Добавить(ТипСтроки);
		Если Тип = 2 Тогда
			НоваяСтрока.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
		ИначеЕсли Тип = 3 Тогда
			НоваяСтрока.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
		ИначеЕсли Тип = 4 Тогда
			НоваяСтрока.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе;
		КонецЕсли; 
	Иначе
		Родитель = ирНеглобальный.ПолучитьРодителяСтрокиДереваЛкс(ТекущаяСтрокаОтбора, ТабличноеПолеОтбора.Значение);
		НоваяСтрока = Родитель.Элементы.Добавить(ТипСтроки);
	КонецЕсли; 
	Если Тип = 1 Тогда
		НоваяСтрока.Представление = " ";
	КонецЕсли; 
	ТабличноеПолеОтбора.ТекущаяСтрока = НоваяСтрока;
	ТабличноеПолеОтбора.ИзменитьСтроку();

КонецПроцедуры

Процедура КПДеревоУсловияСвязиДобавитьЭлемент(Кнопка)
	
	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловияСвязи, 0);

КонецПроцедуры

Процедура КПДеревоУсловияСвязиДобавитьГруппуИ(Кнопка)
	
	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловияСвязи, 2);
	
КонецПроцедуры

Процедура КПДеревоУсловияСвязиДобавитьГруппуИли(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловияСвязи, 3);
	
КонецПроцедуры

Процедура КПДеревоУсловияДобавитьЭлемент(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловия, 0);
	
КонецПроцедуры

Процедура КПДеревоУсловияСвязиДобавитьВыражение(Кнопка)
	
	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловияСвязи, 1);
	
КонецПроцедуры

Процедура КПДеревоУсловияДобавитьВыражение(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловия, 1);

КонецПроцедуры

Процедура КПДеревоУсловияДобавитьГруппуИ(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловия, 2);

КонецПроцедуры

Процедура КПДеревоУсловияДобавитьГруппуИли(Кнопка)

	ДобавитьСтрокуВТабличноеПолеОтбора(ЭлементыФормы.ДеревоУсловия, 3);

КонецПроцедуры

Процедура ПараметрыВыбор(Элемент, ВыбраннаяСтрока, Колонка, СтандартнаяОбработка)
	
	Если Колонка = ЭлементыФормы.Параметры.Колонки.Значение Тогда
		ирНеглобальный.ЯчейкаТабличногоПоляРасширенногоЗначения_ВыборЛкс(Элемент, СтандартнаяОбработка);
	КонецЕсли; 
	
КонецПроцедуры

Процедура СтруктураКоманднойПанелиНажатие(Кнопка)
	
	ирНеглобальный.ОткрытьСтруктуруКоманднойПанелиЛкс(ЭтаФорма, Кнопка);
	
КонецПроцедуры

Процедура КПВыбранныеТаблицыПреобразоватьВПодзапрос(Кнопка)
	
	ТекущаяСтрока = ЭлементыФормы.ВыбранныеТаблицы.ТекущаяСтрока;
	Если ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	ЗапросыВложенногоПакета = ЗапросыПакета.СкопироватьКолонки();
	ВложенныйЗапрос = ДобавитьЗапросПакета(ЗапросыВложенногоПакета);
	ВложеннаяЧастьОбъединения = ДобавитьЧастьОбъединения(ВложенныйЗапрос);
	СтрокаВыбраннойТаблицы = ВложеннаяЧастьОбъединения.ВыбранныеТаблицы.Добавить();
	ЗаполнитьЗначенияСвойств(СтрокаВыбраннойТаблицы, ТекущаяСтрока); // Опасно. Копируем ссылку на таблицу Параметры
	ОбновитьКомпоновщикЧастиОбъединения(ВложеннаяЧастьОбъединения);
	СтрокаВыбраннойТаблицы.ВсеПоля = Истина;
	ДобавитьВсеПоляТаблицыВВыбранныеПоля(ТекущаяСтрока.Имя, ВложенныйЗапрос, ВложеннаяЧастьОбъединения);
	ТекущаяСтрока.ВложенныйПакет = ЗапросыВложенногоПакета;
	ТекущаяСтрока.ПолноеИмя = "";
	ТекущаяСтрока.Комментарий = "";
	ирНеглобальный.ОбновитьКопиюСвойстваВНижнемРегистреЛкс(ТекущаяСтрока);
	ТекущаяСтрока.Параметры = ПараметрыТаблицы.СкопироватьКолонки();
	ЗагрузитьВыбраннуюТаблицу();
	
КонецПроцедуры

Процедура КПДоступныеТаблицыДобавить(Кнопка)

	ИмяДоступнойТаблицы = "";
	Если ВвестиСтроку(ИмяДоступнойТаблицы, "Укажите имя временной таблицы") Тогда
		СтрокаДоступнойТаблицы = НайтиДобавитьДоступнуюВременнуюТаблицу(ИмяДоступнойТаблицы);
		ЭлементыФормы.ДоступныеТаблицы.ТекущаяСтрока = СтрокаДоступнойТаблицы;
		ОбновитьЗаголовкиСтраницПанелиДоступныхТаблиц();
	КонецЕсли; 
	
КонецПроцедуры

Процедура ОбновитьЗаголовкиСтраницПанелиДоступныхТаблиц()
	
	ЭлементФормы = ЭлементыФормы.ПанельДоступныеТаблицы;
	Для Каждого Страница Из ЭлементФормы.Страницы Цикл
		Если Страница.Имя = "Все" Тогда
			Продолжить;
		КонецЕсли; 
		СтруктураОтбора = Новый Структура("Тип", Страница.Имя);
		Количество = ДоступныеТаблицы.НайтиСтроки(СтруктураОтбора).Количество();
		ЛксОбновитьТекстПослеМаркераВСтроке(Страница.Заголовок, , "" + Количество + ")", "(");
	КонецЦикла;

КонецПроцедуры

Процедура ПанельДоступныеТаблицыПриСменеСтраницы(Элемент, ТекущаяСтраница)
	
	ОбновитьОтборПоСтраницеДоступныхТаблиц();
	
КонецПроцедуры

Процедура ОбновитьОтборПоСтраницеДоступныхТаблиц()
	
	ЭлементОтбора = ЭлементыФормы.ДоступныеТаблицы.ОтборСтрок.Тип;
	ЭлементОтбора.Установить(ЭлементыФормы.ПанельДоступныеТаблицы.ТекущаяСтраница.Имя);
	ЭлементОтбора.Использование = ЭлементыФормы.ПанельДоступныеТаблицы.ТекущаяСтраница <> ЭлементыФормы.ПанельДоступныеТаблицы.Страницы.Все;
	
КонецПроцедуры

ирНеглобальный.ВстроитьКнопкиСтруктурыКоманднойПанелиЛкс(ЭтаФорма);

ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ВыбранныеПоля);
ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ПоляДоступнойТаблицы);
ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ДоступныеПоляПсевдонима);
ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ДоступныеПоляИтогов);
ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ДоступныеПоляУсловия);
ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ДоступныеПоляПорядкаОбъединения);
ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ДоступныеПоляПорядкаЧастиОбъединения);
ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ДоступныеПоляИтогов);
ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ДоступныеПоляИндекса);
ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ДоступныеПоляВыбора);
ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ДоступныеПоляГруппировок);
ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ВыборЛевогоЗначенияЭлементаУсловияСвязи);
ЛксПодключитьОбработчикиСобытийДоступныхПолейКомпоновки(ЭлементыФормы.ВыборПравогоЗначенияЭлементаУсловияСвязи);
ЭлементыФормы.ДоступныеПоляУсловия.Колонки.Заголовок.КартинкиСтрок = БиблиотекаКартинок.ирТипыДоступныхПолейКомпоновки;

//ЭлементыФормы.ВыбранныеПоля.Колонки.Определение.КартинкиСтрок = БиблиотекаКартинок.ирТипыДоступныхПолейКомпоновки;
//ЭлементыФормы.ПоляДоступнойТаблицы.Колонки.Имя.КартинкиСтрок = БиблиотекаКартинок.ирТипыДоступныхПолейКомпоновки;
ПоляПорядка.Колонки.Добавить("Направление", Новый ОписаниеТипов("НаправлениеСортировки"));
СвязиТаблиц.Колонки.Добавить("Условие");
//СвязиТаблиц.Колонки.Добавить("НЛеваяТаблица", Новый ОписаниеТипов("Строка"));
//СвязиТаблиц.Колонки.Добавить("НПраваяТаблица", Новый ОписаниеТипов("Строка"));
ВыбранныеТаблицы.Колонки.Добавить("ВложенныйПакет");
ВыбранныеТаблицы.Колонки.Добавить("Параметры");
ВыбранныеТаблицы.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ПоляОбъединения.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
//Параметры.Колонки.Добавить("Значение");
ПараметрыТаблицы.Колонки.Добавить("Токен");
ВыбранныеПоля.Колонки.Добавить("Токен");
Группировки.Колонки.Добавить("Токен");
ПоляПорядка.Колонки.Добавить("Токен");
ГруппируемыеПоляИтогов.Колонки.Добавить("Токен");
ГруппируемыеПоляИтогов.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ГруппирующиеПоляИтогов.Колонки.Добавить("Токен");
ГруппирующиеПоляИтогов.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ВыбранныеПоля.Колонки.Добавить("ИД");
ВыбранныеПоля.Колонки.Добавить("НИмя", Новый ОписаниеТипов("Строка"));
ДоступныеПоляПсевдонима.Колонки.Добавить("ИД");
ЧастиОбъединения.Колонки.Добавить("Структура");
ЧастиОбъединения.Колонки.Добавить("ВыбранныеТаблицы");
ЧастиОбъединения.Колонки.Добавить("ВыбранныеПоля");
ЧастиОбъединения.Колонки.Добавить("СвязиТаблиц");
ЧастиОбъединения.Колонки.Добавить("Группировки");
ЧастиОбъединения.Колонки.Добавить("Условие");
ЧастиОбъединения.Колонки.Добавить("ОпцияРазличные", Новый ОписаниеТипов("Булево"));
ЧастиОбъединения.Колонки.Добавить("Автогруппировки", Новый ОписаниеТипов("Булево"));
ЧастиОбъединения.Колонки.Добавить("Компоновщик");
ЧастиОбъединения.Колонки.Добавить("ИсточникНастроек");
ЗапросыПакета.Колонки.Добавить("ИД", Новый ОписаниеТипов("УникальныйИдентификатор"));
ЗапросыПакета.Колонки.Добавить("ЧастиОбъединения");
ЗапросыПакета.Колонки.Добавить("ПоляОбъединения");
ЗапросыПакета.Колонки.Добавить("ГруппирующиеПоляИтогов");
ЗапросыПакета.Колонки.Добавить("ГруппируемыеПоляИтогов");
ЗапросыПакета.Колонки.Добавить("ОбщиеИтоги");
ЗапросыПакета.Колонки.Добавить("Комментарий", Новый ОписаниеТипов("Строка")); // Используется только для УНИЧТОЖИТЬ, т.к. там нет объединения
ЗапросыПакета.Колонки.Добавить("ПоляПорядка");
ЗапросыПакета.Колонки.Добавить("ПоляИндекса");
ЗапросыПакета.Колонки.Добавить("ОпцияАвтоупорядочивание", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ОпцияОбщиеИтоги", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ОпцияПервые", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ОпцияРазрешенные", Новый ОписаниеТипов("Булево"));
ЗапросыПакета.Колонки.Добавить("ТипЗапроса", Новый ОписаниеТипов("Число"));
ЗапросыПакета.Колонки.Добавить("ПервыеКоличество", Новый ОписаниеТипов("Число"));
ЗапросыПакета.Колонки.Добавить("ИмяВременнойТаблицы", Новый ОписаниеТипов("Строка"));
ЗапросыПакета.Колонки.Добавить("Компоновщик");
ЭлементыФормы.ПоляПорядка.Колонки.Направление.Данные = "Направление";
ЭтаФорма.ПервыеКоличество = 1;
мРежимРедактированияТекста = Ложь;
ПолеТекстаОтображаетПакет = Истина;
Английский1С = ирНеглобальный.СтрокиРавныЛкс(ТекущийЯзыкСистемы(), "en");
мЧислоСтатическихКолонокТЗПоляПсевдонимовПолей = ПоляОбъединения.Колонки.Количество();
мЧислоСтатическихКолонокТППоляПсевдонимовПолей = ЭлементыФормы.ПоляОбъединения.Колонки.Количество();

СписокВыбораДиалектов = ЭлементыФормы.ДиалектSQL.СписокВыбора;
СписокВыбораДиалектов.Добавить("1С");
СписокВыбораДиалектов.Добавить("WQL");
СписокВыбораДиалектов.Добавить("Oracle");
СписокВыбораДиалектов.Добавить("MS SQL");
СписокВыбораДиалектов.Добавить("DB2");
СписокВыбораДиалектов.Добавить("Microsoft Visual FoxPro");
СписокВыбораДиалектов.Добавить("MS Jet");

мТерминалыЯзыкаЗапросов = Новый Соответствие;
ТаблицаТерминалов = ирНеглобальный.ПолучитьТаблицуИзТабличногоДокументаЛкс(мПлатформа.ПолучитьМакет("ТерминалыЯзыкаЗапросов"));
Для Каждого СтрокаТерминала Из ТаблицаТерминалов Цикл
	мТерминалыЯзыкаЗапросов.Вставить(СтрокаТерминала.Английский, СтрокаТерминала.Русский);
КонецЦикла; 
ДиалектSQL = мДиалектSQL;
ПараметрыДиалектаSQL = мПараметрыДиалектаSQL;
