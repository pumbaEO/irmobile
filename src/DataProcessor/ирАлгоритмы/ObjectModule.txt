Перем мПутьАлгоритмы; 
Перем мСтруктурыВнешнихОбработокАлгоритмов;
Перем мКорневаяГруппа;

 ////////////////////////////////////////////////////////////////////////////////
 //	ПРОЦЕДУРЫ И ФУНКЦИИ СОЗДАНИЯ, МОДИФИКАЦИИ И УДАЛЕНИЯ АЛГОРИТМОВ
 
Функция Инициализировать(ПутьАлгоритмы) Экспорт
	
	ИменаАлгоритмов  = Новый Соответствие;
	
	мПутьАлгоритмы = ПутьАлгоритмы;
	
	Файлы = НайтиФайлы(мПутьАлгоритмы, "*" , Истина);
	
	Алгоритмы.Очистить();
	ПараметрыАлгоритмов.Очистить();
	
	мКорневаяГруппа = Алгоритмы.Добавить();
	мКорневаяГруппа.Ключ = 0;
	мКорневаяГруппа.Наименование = "";
	мКорневаяГруппа.КлючРодителя = -1;
	мКорневаяГруппа.ОтносительныйПуть = "";	
	мКорневаяГруппа.ЭтоГруппа = Истина;
		
	максКлюч = 0;	
	
	Для Каждого Файл Из Файлы Цикл
		
		Попытка
			
			Если Файл.ЭтоКаталог() Тогда
				
				НайтиСоздатьГруппуСправочника(Файл.ПолноеИмя);
				Продолжить; 
				
			ИначеЕсли НЕ Файл.Расширение = ".alg" Тогда 
				
				Продолжить;
				
			КонецЕсли; 
			
			ХранимыйАлгоритм = ЗначениеИзФайла(Файл.ПолноеИмя);
			Алгоритм = ПолучитьСтруктуруАлгоритма();
			ЗаполнитьЗначенияСвойств(Алгоритм, ХранимыйАлгоритм); 
			Алгоритм.Наименование = Файл.ИмяБезРасширения;
			
			Если ИменаАлгоритмов.Получить(Алгоритм.Наименование) <> Неопределено Тогда
				
				Сообщить("Обнаружен дублирующийся алгоритм " + Алгоритм.Наименование + " в файле " + Файл.ПолноеИмя + 
							" .Ранее был считан из файла " + ИменаАлгоритмов.Получить(Алгоритм.Наименование));
				Продолжить;
				
			Иначе
				
				ИменаАлгоритмов.Вставить(Алгоритм.Наименование, Файл.ПолноеИмя);
				
			КонецЕсли; 
			
			СтрАлгоритм = Алгоритмы.Добавить();
			ЗаполнитьЗначенияСвойств(СтрАлгоритм, Алгоритм, , "ДатаИзмененияКонтекста, ИндивидуальнаяВнешняяОбработка");
			СтрАлгоритм.Ключ = ПолучитьНовыйКлюч();
			СтрАлгоритм.ДатаИзмененияКонтекста = '0001-01-01';
			СтрАлгоритм.ИндивидуальнаяВнешняяОбработка = Истина;
			СтрАлгоритм.ОтносительныйПуть = СтрЗаменить(Файл.ПолноеИмя, мПутьАлгоритмы, "");
			СтрАлгоритм.КлючРодителя = НайтиСоздатьГруппуСправочника(Файл.Путь); 
			
			Для Каждого Параметр Из Алгоритм.Параметры Цикл
				
				стрПараметр = ПараметрыАлгоритмов.Добавить();
				стрПараметр.Ключ = СтрАлгоритм.Ключ;
				ЗаполнитьЗначенияСвойств(СтрПараметр, Параметр);
				
			КонецЦикла;   			
			
		Исключение
			
			Сообщить("Не удалось считать алгоритм " + Файл.ПолноеИмя, СтатусСообщения.Важное);
			
		КонецПопытки;
		
	КонецЦикла;   
		
КонецФункции

Функция СоздатьНовыйАлгоритм(Знач Родитель = 0) Экспорт
	
	КлючРодителя = ПривестиКАлгоритму(Родитель).Ключ;
	
	Алгоритм = ПолучитьСтруктуруАлгоритма();
	Алгоритм.Ключ = ПолучитьНовыйКлюч();
	Алгоритм.Наименование = "";
	Алгоритм.ДатаИзменения = '0001-01-01';
	Алгоритм.Комментарий = "";
	Алгоритм.ДатаИзмененияКонтекста = '0001-01-01';
	Алгоритм.ИндивидуальнаяВнешняяОбработка = Истина;
	Алгоритм.ОтносительныйПуть = "";
	Алгоритм.КлючРодителя = КлючРодителя;
	Алгоритм.ЭтоГруппа = Ложь;
	Алгоритм.Параметры = ПараметрыАлгоритмов.ВыгрузитьКолонки("Имя, Значение, ДопустимыеТипы, Вход, Выход, ЗначениеХранилище");
	
	Возврат Алгоритм;
	
КонецФункции

Функция СоздатьГруппуАлгоритмов(Наименование, Родитель) Экспорт
	
	Родитель = ПривестиКАлгоритму(Родитель);
	
	Если НЕ Родитель.ЭтоГруппа Тогда
		
		ВызватьИсключение "Невозможно создать группу, подчиненную элементу"; 
		
	КонецЕсли; 
	
	Если ПустаяСтрока(Наименование) Тогда
		
		ВызватьИсключение "Наименование не может быть пустым";
		
	КонецЕсли; 
	
	КаталогНовойГруппы = мПутьАлгоритмы + Родитель.ОтносительныйПуть + ?(ПустаяСтрока(Родитель.ОтносительныйПуть) , "", "\") + Наименование;
	Файл = Новый Файл(КаталогНовойГруппы); 
	
	Если Файл.Существует() Тогда
		
		ВызватьИсключение "Каталог " + КаталогНовойГруппы + " уже существует";
		
	КонецЕсли; 
	
	Попытка
		
		СоздатьКаталог(КаталогНовойГруппы);
		НоваяГруппаСтр = Алгоритмы.Добавить();
		НоваяГруппаСтр.Ключ = ПолучитьНовыйКлюч();
		НоваяГруппаСтр.Наименование = Наименование;
		НоваяГруппаСтр.КлючРодителя = Родитель.Ключ;
		НоваяГруппаСтр.ОтносительныйПуть = Родитель.ОтносительныйПуть + "\" + Наименование;
		НоваяГруппаСтр.ЭтоГруппа = Истина;
		НоваяГруппа = ПолучитьСтруктуруАлгоритма();
		ЗаполнитьЗначенияСвойств(НоваяГруппа, НоваяГруппаСтр);
		Возврат НоваяГруппа;
		
	Исключение
		
		ВызватьИсключение "Не удалось создать каталог для группы " + КаталогНовойГруппы;
		
	КонецПопытки;      	
	
КонецФункции

Функция СкопироватьАлгоритм(Знач Алгоритм) Экспорт
	
	Алгоритм = ПривестиКАлгоритму(Алгоритм);
	
	НовыйАлгоритм = ПолучитьСтруктуруАлгоритма();
	НовыйАлгоритм.Ключ = ПолучитьНовыйКлюч();
	НовыйАлгоритм.Наименование = Алгоритм.Наименование + "1";
	НовыйАлгоритм.ТекстАлгоритма = Алгоритм.ТекстАлгоритма;
	НовыйАлгоритм.ДатаИзменения = "0001-01-01";
	НовыйАлгоритм.ДатаИзмененияКонтекста = "0001-01-01";
	НовыйАлгоритм.ИндивидуальнаяВнешняяОбработка = Истина;
	НовыйАлгоритм.Комментарий = Алгоритм.Комментарий;
	НовыйАлгоритм.ОтносительныйПуть = "";
	НовыйАлгоритм.КлючРодителя = Алгоритм.КлючРодителя;
	НовыйАлгоритм.ЭтоГруппа = Ложь;
	НовыйАлгоритм.Параметры = Алгоритм.Параметры.Скопировать();
	
	Возврат НовыйАлгоритм;
	
КонецФункции 

Функция ЗаписатьАлгоритм(Знач Алгоритм) Экспорт
	
	Алгоритм = ПривестиКАлгоритму(Алгоритм);	
	Алгоритм.ДатаИзменения = ТекущаяДата();
	СобратьКонтекст(Алгоритм);
		
	Если НЕ ПроверитьДанные(Алгоритм) Тогда
		
		Возврат Ложь;
		
	Иначе
		
		Попытка
			
			СтароеИмяФайла = ПолучитьПолноеИмяФайлаАлгоритма(Алгоритм, "Текущее");
			НовоеИмяФайла = ПолучитьПолноеИмяФайлаАлгоритма(Алгоритм, "Новое");
			
			Если ЭтоНовыйАлгоритм(Алгоритм) ИЛИ СтароеИмяФайла = НовоеИмяФайла Тогда
				
				Файл = Новый Файл(НовоеИмяФайла);
				АлгоритмДляЗаписи = ПолучитьСтруктуруАлгоритмаДляЗаписиВФайл();
				ЗаполнитьЗначенияСвойств(АлгоритмДляЗаписи, Алгоритм); 
				ЗначениеВФайл(Файл.ПолноеИмя, АлгоритмДляЗаписи);
				
			Иначе
				
				ПереместитьФайл(СтароеИмяФайла, НовоеИмяФайла);
				
			КонецЕсли;  			
			
			Алгоритм.ОтносительныйПуть = ПолучитьОтносительныйПутьПоПолномуИмениФайла(НовоеИмяФайла);
			
			Если ЭтоНовыйАлгоритм(Алгоритм) Тогда
				
				стрАлгоритм = Алгоритмы.Добавить();
						
			Иначе
				
				стрАлгоритм = Алгоритмы.Найти(Алгоритм.Ключ, "Ключ");
				
				СтрокиПараметров = ПараметрыАлгоритмов.НайтиСтроки(Новый Структура("Ключ", Алгоритм.Ключ));
				
				Для Каждого СтрокаПараметров Из СтрокиПараметров Цикл
					
					ПараметрыАлгоритмов.Удалить(СтрокаПараметров);
					
				КонецЦикла;
				
			КонецЕсли; 
			
			ЗаполнитьЗначенияСвойств(стрАлгоритм, Алгоритм);
			
			Для Каждого Параметр Из Алгоритм.Параметры Цикл
				
				стрПараметр = ПараметрыАлгоритмов.Добавить();
				стрПараметр.Ключ = Алгоритм.Ключ;
				ЗаполнитьЗначенияСвойств(стрПараметр, Параметр);
				
			КонецЦикла;			
	
			Возврат Истина;
			
		Исключение
		
			Сообщить(ОписаниеОшибки() + Символы.ПС+ "Не удалось записать алгоритм!", СтатусСообщения.Важное);  
			Возврат Ложь;
		    
		КонецПопытки;
		
	КонецЕсли;  
	
КонецФункции   

Функция ПереместитьВГруппу(Знач Алгоритм, Знач Группа) Экспорт
	
	СообщениеОбОшибке = "";
	Если НЕ ПроверитьВозможностьПеремещения(Алгоритм, Группа, СообщениеОбОшибке) Тогда
		
		ВызватьИсключение СообщениеОбОшибке; 
		
	КонецЕсли;                             	
	
	НоваяГруппа = ПривестиКАлгоритму(Группа);
	Алгоритм = ПривестиКАлгоритму(Алгоритм);
	СтрокаАлгоритма = ПолучитьСтрокуАлгоритма(Алгоритм);
	СтараяГруппа = ПолучитьАлгоритмПоКлючу(Алгоритм.КлючРодителя);
	
	Если Не Алгоритм.ЭтоГруппа Тогда
		
		Попытка
			
			ПолноеИмяСтарогоФайла = ПолучитьПолноеИмяФайлаАлгоритма(Алгоритм);
			СтарыйФайл = Новый Файл(ПолноеИмяСтарогоФайла);
			КороткоеИмяСтарогоФайла = СтарыйФайл.Имя;
			ПолноеИмяНовогоФайла = мПутьАлгоритмы + НоваяГруппа.ОтносительныйПуть + "\" + КороткоеИмяСтарогоФайла;
			ПереместитьФайл(ПолноеИмяСтарогоФайла, ПолноеИмяНовогоФайла);
			СтрокаАлгоритма.ОтносительныйПуть = ПолучитьОтносительныйПутьПоПолномуИмениФайла(ПолноеИмяНовогоФайла);
			СтрокаАлгоритма.КлючРодителя = НоваяГруппа.Ключ;
			
		Исключение
			
		    ВызватьИсключение "Не удается переместить файл алгоритма " + ПолноеИмяСтарогоФайла; 
			
		КонецПопытки;
		
	Иначе
		
		ПолноеИмяСтарогоКаталога = ПолучитьПолноеИмяФайлаАлгоритма(Алгоритм);
		КаталогПеремещения = мПутьАлгоритмы + НоваяГруппа.ОтносительныйПуть;  		
		ПолноеИмяНовогоКаталога = КаталогПеремещения + ?(Прав(КаталогПеремещения, 1) = "\", "", "\") + Алгоритм.Наименование;  		
		КомандаСистемы("move /y " + """" + ПолноеИмяСтарогоКаталога + """" + " " + """" + КаталогПеремещения + """");
		СтарыйКаталог = Новый Файл(ПолноеИмяСтарогоКаталога);
		НовыйКаталог = Новый Файл(ПолноеИмяНовогоКаталога); 
		Если СтарыйКаталог.Существует() ИЛИ НЕ НовыйКаталог.Существует() Тогда 				
			ВызватьИсключение  "Не удается переместить каталог группы " + ПолноеИмяСтарогоКаталога;			
		КонецЕсли; 
		СтрокаАлгоритма.КлючРодителя = НоваяГруппа.Ключ;
		ЗаменитьРекурсивноОтносительныеПути(СтрокаАлгоритма, СтрокаАлгоритма.ОтносительныйПуть, НоваяГруппа.ОтносительныйПуть + "\" + Алгоритм.Наименование);		
		
	КонецЕсли; 
	
КонецФункции 

Функция ПроверитьВозможностьПеремещения(Знач Алгоритм, Знач Группа, СообщениеОбОшибке = "") Экспорт
	
	НоваяГруппа = ПривестиКАлгоритму(Группа);
	Алгоритм = ПривестиКАлгоритму(Алгоритм);
	СтараяГруппа = ПолучитьАлгоритмПоКлючу(Алгоритм.КлючРодителя);
	
	Если НоваяГруппа = Неопределено Тогда
		
		СообщениеОбОшибке =  "Не найдена группа с ключом " + Группа;
		Возврат Ложь;
		
	КонецЕсли; 
	
	Если Не НоваяГруппа.ЭтоГруппа Тогда
		
		СообщениеОбОшибке = "Алгоритм с ключом " + Группа + " не является группой. Перемещение не возможно";
		Возврат Ложь;
		
	КонецЕсли; 
	
	Если Алгоритм.ЭтоГруппа И ЯвляетсяПредком(Алгоритм, НоваяГруппа) Тогда
		
		СообщениеОбОшибке =  "Группа " + Алгоритм.Наименование + " является предком для " + НоваяГруппа.Наименование + ". Перемещение не возможно";		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Функция УдалитьАлгоритм(Знач Алгоритм) Экспорт
	
	Алгоритм = ПривестиКАлгоритму(Алгоритм);
	
	Если Алгоритм = Неопределено Тогда
		
		Возврат Истина; 
		
	КонецЕсли; 
	
	Если НЕ Алгоритм.ЭтоГруппа Тогда
		
		СтрокаАлгоритма = Алгоритмы.Найти(Алгоритм.Ключ, "Ключ");
		
		Если ЗначениеЗаполнено(Алгоритм.ОтносительныйПуть) Тогда
			
			Файл = Новый Файл(ПолучитьПолноеИмяФайлаАлгоритма(Алгоритм));
			
			Если Файл.Существует() Тогда
				
				Попытка
					
					УдалитьФайлы(Файл.ПолноеИмя);
					Алгоритмы.Удалить(СтрокаАлгоритма);
					
				Исключение
					
					Сообщить(ОписаниеОшибки() + Символы.ПС + "Не удалось удалить файл алгоритма " + Файл.ПолноеИмя);
					Возврат Ложь;
					
				КонецПопытки;
				
			КонецЕсли; 
			
		Иначе
			
			СтрокиАлгоритмов = Алгоритмы.НайтиСтроки(Новый Структура("КлючРодителя", Алгоритм.Ключ));   			
			БылиОшибки = Ложь;
			
			Для Каждого СтрокаАлгоритма ИЗ СтрокиАлгоритмов Цикл
				
				Файл = Новый Файл(ПолучитьПолноеИмяФайлаАлгоритма(СтрокаАлгоритма));
				Если Файл.Существует() Тогда
					
					Попытка
						УдалитьФайлы(Файл.ПолноеИмя);
						Алгоритмы.Удалить(СтрокаАлгоритма);
					Исключение
						БылиОшибки = Истина;
						Сообщить(ОписаниеОшибки() + Символы.ПС + "Не удалось удалить файл алгоритма " + Файл.ПолноеИмя);
					КонецПопытки;    			
				КонецЕсли;		
				
				Если Не БылиОшибки Тогда
					
					СтрокаГруппы = Алгоритмы.Найти(Алгоритм.Ключ, "Ключ");
					Алгоритмы.Удалить(СтрокаГруппы);
					
				Иначе 
					
					Возврат Ложь;
					
				КонецЕсли; 
				
			КонецЦикла;	
			
		КонецЕсли; 		
		
	КонецЕсли;  	
	
	Возврат Истина;
	
КонецФункции

Функция ПостроитьДеревоАлгоритмов(ТолькоГруппы = Ложь, ДобавлятьКорневуюГруппу = Ложь) Экспорт
	
	ДеревоАлгоритмов = Новый ДеревоЗначений;
	Колонки = Алгоритмы.ВыгрузитьКолонки().Колонки;
	Для Каждого Колонка Из Колонки Цикл
		
		ЗаполнитьЗначенияСвойств(ДеревоАлгоритмов.Колонки.Добавить(), Колонка);
		
	КонецЦикла;
	
	СтрокиДерева = ДеревоАлгоритмов.Строки;
	
	ТекущийУровень = Новый Массив();
	Если ДобавлятьКорневуюГруппу Тогда
		
		КорневаяГруппа = ДеревоАлгоритмов.Строки.Добавить();
		КорневаяГруппа.Ключ = 0;
		КорневаяГруппа.КлючРодителя = -1;
		ТекущийУровень.Добавить(КорневаяГруппа);
		
	Иначе
		
		ТекущийУровень.Добавить(ДеревоАлгоритмов);
		
	КонецЕсли; 
	
	Пока ТекущийУровень.Количество() <> 0 Цикл
		
		НовыйУровень = Новый Массив;
		
		Для Каждого Узел Из ТекущийУровень Цикл
			
			ПодчиненныеАлгоритмы = Алгоритмы.НайтиСтроки(Новый Структура("КлючРодителя", ?(ТипЗнч(Узел) = Тип("ДеревоЗначений"), 0 , Узел.Ключ)));
			
			тмпТаблица = Алгоритмы.Выгрузить(ПодчиненныеАлгоритмы);
			тмпТаблица.Сортировать("ЭтоГруппа Убыв, Ключ");			
			ПодчиненныеАлгоритмы = тмпТаблица;
			
			Для Каждого ПодчиненныйАлгоритм Из ПодчиненныеАлгоритмы Цикл
				
				Если ТолькоГруппы И НЕ ПодчиненныйАлгоритм.ЭтоГруппа Тогда
					
					Продолжить;
					
				КонецЕсли; 
				
				ПодчиненныйУзел = Узел.Строки.ДОбавить();
				ЗаполнитьЗначенияСвойств(ПодчиненныйУзел, ПодчиненныйАлгоритм);			
				НовыйУровень.Добавить(ПодчиненныйУзел);			
				
			КонецЦикла;
						
		КонецЦикла;
		
		ТекущийУровень = НовыйУровень;
		
	КонецЦикла; 
		
	Возврат ДеревоАлгоритмов;
	
КонецФункции

Функция НайтиСоздатьГруппуСправочника(Путь) 
	
	ГруппыСтроки = ирГлобальный.ЛксПолучитьМассивИзСтрокиСРазделителем(СтрЗаменить(Путь, мПутьАлгоритмы, ""), "\");
	
	Если ГруппыСтроки.Количество() = 0 ИЛИ (ПустаяСтрока(ГруппыСтроки[0])) Тогда
		
		Возврат 0;
		
	КонецЕсли; 
	
	Для А = 0 По ГруппыСтроки.ВГраница() Цикл
		
		Если ПустаяСтрока(ГруппыСтроки[А]) Тогда
			
			Продолжить;
			
		КонецЕсли;     
		
		ОтносительныйПутьГруппы = "";
		
		КлючРодительскойГруппы = 0;
		
		Для Б = 0 По А Цикл
			
			ОтносительныйПутьГруппы = ?(ПустаяСтрока(ОтносительныйПутьГруппы), "", ОтносительныйПутьГруппы + "\") + ГруппыСтроки[Б];
			
			Группа = Алгоритмы.Найти(ОтносительныйПутьГруппы, "ОтносительныйПуть");
			
			Если Группа = Неопределено Тогда
				
				Группа = Алгоритмы.Добавить();
				Группа.Ключ = ПолучитьНовыйКлюч();
				Группа.Наименование = ГруппыСтроки[А];
				Группа.КлючРодителя = КлючРодительскойГруппы;
				Группа.ОтносительныйПуть = ОтносительныйПутьГруппы;	
				Группа.ЭтоГруппа = Истина;
				
			КонецЕсли; 			
			
			КлючРодительскойГруппы = Группа.Ключ;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Группа.Ключ;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
//	ПРОЦЕДУРЫ И ФУНКЦИИ ПОИСКА АЛГОРИТМОВ, ПРОВЕРКИ АЛГОРИТМОВ

Функция ПолучитьАлгоритмПоКлючу(Ключ) Экспорт
	
	СтрокаАлгоритма = Алгоритмы.Найти(Ключ, "Ключ");
	
	Если СтрокаАлгоритма <> Неопределено Тогда
		  		
		Возврат ПолучитьАлгоритмИзСтрокиТабличнойЧасти(СтрокаАлгоритма);
		
	Иначе 
		
		Возврат Неопределено;
		
	КонецЕсли;  	
	
КонецФункции

Функция ПривестиКАлгоритму(Значение)
	
	Если ТипЗнч(Значение) = Тип("Число") Тогда
		
		Возврат ПолучитьАлгоритмПоКлючу(Значение);
		
	ИначеЕсли ТипЗнч(Значение) = Тип("Структура") Тогда 
		
		Возврат Значение;
		
	Иначе  
		
		Попытка
			
			Возврат ПолучитьАлгоритмИзСтрокиТабличнойЧасти(Значение);  
			
		Исключение
			
			ВызватьИсключение "Параметр Значение имеет недопустимый тип";
			
		КонецПопытки;
		
	КонецЕсли; 
	
КонецФункции

Функция ПолучитьАлгоритмПоНаименованию(Наименование) Экспорт
	
	СтрокаАлгоритма = Алгоритмы.Найти(Наименование, "Наименование");
	
	Если СтрокаАлгоритма <> Неопределено Тогда
		  		
		Возврат ПолучитьАлгоритмИзСтрокиТабличнойЧасти(СтрокаАлгоритма);
		
	Иначе 
		
		Возврат Неопределено;
		
	КонецЕсли;   
	
КонецФункции

Функция ПолучитьАлгоритмИзСтрокиТабличнойЧасти(СтрокаТЧ)
	
	Алгоритм = ПолучитьСтруктуруАлгоритма();
	ЗаполнитьЗначенияСвойств(Алгоритм, СтрокаТЧ);
	ПараметрыАлгоритма = ПараметрыАлгоритмов.НайтиСтроки(Новый Структура("Ключ", Алгоритм.Ключ));
	Алгоритм.Параметры = ПараметрыАлгоритмов.Выгрузить(ПараметрыАлгоритма, "Имя, Значение, ДопустимыеТипы, Вход, Выход, ЗначениеХранилище");
	
	Возврат Алгоритм;
	
КонецФункции

Функция ПолучитьСтрокуАлгоритма(Алгоритм)
	
	КлючАлгоритма = Неопределено;
	
	Если ТипЗнч(Алгоритм) = Тип("Число") Тогда
		
		КлючАлгоритма = Алгоритм;
				
	ИначеЕсли ТипЗнч(Алгоритм) = Тип("Структура") Тогда 
		
		КлючАлгоритма = Алгоритм.Ключ;
		
	Иначе  
		
		ВызватьИсключение "Параметр Алгоритм имеет недопустимый тип";
		
	КонецЕсли;
	
	СтрокаАлгоритма = Алгоритмы.Найти(КлючАлгоритма, "Ключ");
	
	Если СтрокаАлгоритма <> Неопределено Тогда
		
		Возврат СтрокаАлгоритма;
		
	Иначе
		
		ВызватьИсключение "Не найден алгоритм с ключом " + КлючАлгоритма; 
		
	КонецЕсли; 
	
КонецФункции

Функция ЭтоНовыйАлгоритм(Алгоритм) Экспорт
		
	Возврат Алгоритмы.Найти(Алгоритм.Ключ, "Ключ") = Неопределено;
	
КонецФункции

Функция ЯвляетсяПредком(Знач АлгоритмПредок, Знач АлгоритмПотомок)  Экспорт
	
	АлгоритмПредок = ПривестиКАлгоритму(АлгоритмПредок);
	АлгоритмПотомок = ПривестиКАлгоритму(АлгоритмПотомок);
		
	Если АлгоритмПредок.Ключ = АлгоритмПотомок.Ключ Тогда
		
		Возврат Истина;
		
	КонецЕсли; 
	
	Если АлгоритмПотомок.Ключ = 0  Тогда
		
		Возврат Ложь;
		
	КонецЕсли; 
	
	Если АлгоритмПредок.Ключ = 0 Тогда
		
		Возврат Истина;
		
	КонецЕсли; 
	
	КлючРодителя = АлгоритмПотомок.КлючРодителя;
	
	Пока КлючРодителя <> 0 Цикл
		
		Если АлгоритмПредок.Ключ = КлючРодителя Тогда
			
			Возврат Истина;
			
		КонецЕсли; 
		
		СледующийПредок = ПолучитьАлгоритмПоКлючу(КлючРодителя);
		КлючРодителя = СледующийПредок.КлючРодителя;
			
	КонецЦикла;  
	
	Возврат Ложь;
	
КонецФункции

Функция ПараметрыКорректны(ПараметрыАлгоритма) Экспорт 

	Результат = Истина;
	Если ПараметрыАлгоритма.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли; 
	Для Каждого СтрокаПараметра Из ПараметрыАлгоритма Цикл
		Если Не ирГлобальный.ЛксЛиИмяПеременной(СтрокаПараметра.Имя) Тогда
			Результат = Ложь;
			Сообщить("Имя параметра """ + СтрокаПараметра.Имя + """ не отвечает правилам формирования имен встроенного языка",
				СтатусСообщения.Внимание);
		КонецЕсли;
	КонецЦикла;
	НеуникальныеИмена = ирНеглобальный.ПолучитьНеуникальныеЗначенияКолонкиТаблицыЛкс(ПараметрыАлгоритма, "Имя");
	Для Каждого НеуникальноеИмя Из НеуникальныеИмена Цикл
		Сообщить("Параметр """ + НеуникальноеИмя + """ встречается более одного раза", СтатусСообщения.Внимание);
		Результат = Ложь;
	КонецЦикла;
	Возврат Результат;

КонецФункции // ПараметрыКорректны()
           
Функция ПроверитьДанные(Алгоритм) Экспорт 

	ДанныеКорректны = Истина;
	
	// Проверка шапки
	ЧистоеНаименование = СокрЛП(Алгоритм.Наименование);
	ирГлобальный.ЛксПрисвоитьЕслиНеРавно(Алгоритм.Наименование, ЧистоеНаименование);
	Если Не ирГлобальный.ЛксЛиИмяПеременной(Алгоритм.Наименование) Тогда
		Сообщить("Имя алгоритма не отвечает правилам формирования имен переменных встроенного языка", СтатусСообщения.Важное);
		Возврат Ложь;
	КонецЕсли;
	
	СтрокиАлгоритмов = Алгоритмы.НайтиСтроки(Новый Структура("Наименование", Алгоритм.Наименование));
	Для Каждого стрАлгоритм Из СтрокиАлгоритмов Цикл
		
		Если стрАлгоритм.Ключ <> Алгоритм.Ключ Тогда
			
			ДанныеКорректны = Ложь;
			Сообщить(" Уже существует элемент с наименованием """ + Алгоритм.Наименование + """",
			СтатусСообщения.Важное);
			Возврат Ложь;
			
		КонецЕсли; 
		
	КонецЦикла;     	 
	
	Возврат ПараметрыКорректны(Алгоритм.Параметры.Скопировать(, "Имя"));	

КонецФункции // ПроверитьДанные()

////////////////////////////////////////////////////////////////////////////////
//	ОКТРЫТИЕ АЛГОРИТМОВ В ФОРМАХ 

Функция ПолучитьФормуНовогоАлгоритма(ВладелецФормы = Неопределено, КлючРодителя = 0) Экспорт
	
	Алгоритм = СоздатьНовыйАлгоритм(КлючРодителя);
	
	ФормаАлгоритма = ПолучитьФорму("ФормаЭлемента", ВладелецФормы, Алгоритм.Ключ);
	ФормаАлгоритма.Алгоритм = Алгоритм;
	
	Возврат ФормаАлгоритма;
	
КонецФункции

Функция ПолучитьФормуАлгоритма(Знач Алгоритм, ВладелецФормы = Неопределено, КлючУникальности = Неопределено) Экспорт
	
	Алгоритм = ПривестиКАлгоритму(Алгоритм);
	
	ФормаАлгоритма = ПолучитьФорму("ФормаЭлемента", ВладелецФормы, ?(ЗначениеЗаполнено(КлючУникальности), КлючУникальности, Алгоритм.Ключ));
	ФормаАлгоритма.Алгоритм = Алгоритм;
	
	Возврат ФормаАлгоритма;
	
КонецФункции

Функция ВыбратьАлгоритм(Знач ТекущийАлгоритм, ВладелецФормы = Неопределено) Экспорт
	
	
	ФормаВыбора = ПолучитьФорму("ФормаСписка", ВладелецФормы);
	ФормаВыбора.РежимВыбора = Истина;
	Если ЗначениеЗаполнено(ТекущийАлгоритм) Тогда
		
		ТекущийАлгоритм = ПривестиКАлгоритму(ТекущийАлгоритм);
		ФормаВыбора.ТекущийАлгоритм = ТекущийАлгоритм;	
		
	КонецЕсли; 
	Результат = ФормаВыбора.ОткрытьМодально();
	
	Возврат Результат;
	
КонецФункции 

#Если Клиент И Не ТонкийКлиент И Не ВебКлиент Тогда

Функция ОткрытьКонсольКодаДляАлгоритма(Знач Алгоритм) Экспорт
		
	Алгоритм = ПривестиКАлгоритму(Алгоритм);

	СтруктураПараметров = Новый Структура;
	Для Каждого СтрокаПараметра Из Алгоритм.Параметры Цикл
		СтруктураПараметров.Вставить(СтрокаПараметра.Имя, СтрокаПараметра.Значение);
	КонецЦикла;
	ФормаКонсолиКода = ирОтладка.ОперироватьСтруктурой(Алгоритм.ТекстАлгоритма, , СтруктураПараметров);
	ФормаКонсолиКода.ТекущийАлгоритм = Алгоритм;
	Возврат Неопределено;

КонецФункции

#КонецЕсли
////////////////////////////////////////////////////////////////////////////////
//	ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КОДОМ АЛГОРИТМА

Функция ПолучитьСтартовуюСтрокуАлгоритмаВТексте(Алгоритм) Экспорт 

	Возврат Алгоритм.Параметры.Количество();	
	
КонецФункции // ПолучитьСтартовуюСтрокуАлгоритмаВМодуле()

Функция ПолучитьСтартовуюСтрокуМетодаВМодуле(Алгоритм) Экспорт 

	Результат = 1 + СтрЧислоСтрок(ПолучитьШапкуОпределенияМетода(Алгоритм) + ПолучитьШапкуТелаМетода(Алгоритм));
	Возврат Результат;

КонецФункции // ПолучитьСтартовуюСтрокуАлгоритмаВМодуле()

Функция ПолучитьОбъявлениеСлужебныхПеременных(Алгоритм)

	МассивСлужебныхПеременных = Новый Массив;
	МассивСлужебныхПеременных.Добавить("ЭтотОбъект");
	МассивСлужебныхПеременных.Добавить("Результат");
	Разделитель = ", ";
	Результат = "";
	Для Каждого СлужебнаяПеременная Из МассивСлужебныхПеременных Цикл
		Результат = Результат + Разделитель + СлужебнаяПеременная;
	КонецЦикла;
	Результат = Сред(Результат, СтрДлина(Разделитель) + 1);
	Результат = "Перем " + Результат + ";";
	Возврат Результат;

КонецФункции // ПолучитьОбъявлениеСлужебныхПеременных()

Функция ПолучитьТекстМодуляОбработки(Алгоритм) Экспорт 

	Результат = "";  
	
	Результат = Результат + "// " + Алгоритм.Наименование + Символы.ПС;
	Результат = Результат + ПолучитьОпределениеМетода(Алгоритм);
		
	Возврат Результат;

КонецФункции // ПолучитьТекстМодуляОбработки()

Функция ПолучитьОпределениеМетода(Алгоритм, УниверсальныеИменаПараметров = Ложь) Экспорт 

	Результат = ПолучитьШапкуОпределенияМетода(Алгоритм);
	Результат = Результат + ПолучитьТелоМетода(Алгоритм) + Символы.ПС;
	Результат = Результат + Символы.Таб + "Возврат Результат;" + Символы.ПС;
	Результат = Результат + "КонецФункции" + Символы.ПС;
	Возврат Результат;

КонецФункции // ПолучитьОпределениеМетода()

Функция ПолучитьШапкуОпределенияМетода(Алгоритм)

	Результат = "Функция мМетод(_АлгоритмОбъект, _Режим";
	Для Счетчик = 0 По 9 Цикл
		ИмяПараметра = "_П" + Счетчик;
		Результат = Результат + ", " + ИмяПараметра;
	КонецЦикла;
	Результат = Результат + ") Экспорт" + Символы.ПС;
	Результат = Результат + Символы.Таб + ПолучитьОбъявлениеСлужебныхПеременных(Алгоритм);
	Возврат Результат;

КонецФункции // ПолучитьШапкуОпределенияМетода()

Функция ПолучитьШапкуТелаМетода(Алгоритм)

	Результат = "";
	МассивТаблицПараметров = Новый Массив;
	Результат = Результат + "
	|	_Параметры = _АлгоритмОбъект.Параметры;";
	Результат = Результат + "
	|	Если _Режим = 0 Тогда";
	Для Индекс = 0 ПО Алгоритм.Параметры.Количество() - 1 Цикл
		СтрокаПеременной  = Алгоритм.Параметры[Индекс];
		Если Индекс < 10 Тогда
			ИмяПараметра = "_П" + Индекс;
		Иначе
			ИмяПараметра = "Null";
		КонецЕсли; 
		ИмяПеременной = СтрокаПеременной.Имя;
		Результат = Результат + "
		|		" + ИмяПеременной + " = ?(" + ИмяПараметра + " = Null, _Параметры[" + (Индекс) + "].Значение, "
			+ ИмяПараметра + ");";
	КонецЦикла;
	Результат = Результат + "
	|	Иначе";
	Для Индекс = 0 ПО Алгоритм.Параметры.Количество() - 1 Цикл
		СтрокаПеременной  = Алгоритм.Параметры[Индекс];
		ИмяПеременной = СтрокаПеременной.Имя;
		Результат = Результат + "
		|		" + ИмяПеременной + " = ?(_П0.Свойство(""" + ИмяПеременной + """), _П0." + ИмяПеременной + 
			", _Параметры[" + (Индекс) + "]);";
	КонецЦикла;
	Результат = Результат + "
	|	КонецЕсли;";
		
	Результат = Результат + Символы.ПС + ирКэш.Получить().МаркерНачалаАлгоритма;
	Возврат Результат;

КонецФункции // ПолучитьШапкуТелаМетода()

Функция ПолучитьТелоМетода(Алгоритм, Кэшировать = Ложь) Экспорт 

	Результат = ПолучитьШапкуТелаМетода(Алгоритм);
	Для Сч1 = 1 По СтрЧислоСтрок(Алгоритм.ТекстАлгоритма) Цикл
		Результат = Результат + Символы.Таб + СтрПолучитьСтроку(Алгоритм.ТекстАлгоритма, Сч1) + Символы.ПС;
	КонецЦикла;
	Результат = Результат + ирКэш.Получить().МаркерКонцаАлгоритма;
	Результат = Результат + Символы.Таб + "; ~Конец:";
	
	Результат = Результат + "
	|	Если _Режим = 0 Тогда";
	Для Каждого СтрокаПараметра Из Алгоритм.Параметры Цикл
		Индекс = Алгоритм.Параметры.Индекс(СтрокаПараметра);
		Результат = Результат + "
		|		_П" + Индекс + " = " + СтрокаПараметра.Имя + ";";
	КонецЦикла;
	Результат = Результат + "
	|	Иначе";
	Для Каждого СтрокаПараметра Из Алгоритм.Параметры Цикл
		Индекс = Алгоритм.Параметры.Индекс(СтрокаПараметра);
		ИмяПеременной = СтрокаПараметра.Имя;
		Результат = Результат + "
		|		_П0.Вставить(""" + ИмяПеременной + """, " + ИмяПеременной + ");";
	КонецЦикла;
	Результат = Результат + "
	|	КонецЕсли;";
	
	Возврат Результат;

КонецФункции // ПолучитьТелоМетода()

Функция ПолучитьТекстМакетаПараметров(Алгоритм) Экспорт 

	Возврат "";

КонецФункции // ПолучитьТекстМакетаПараметров()

Функция ВыполнитьЛокально(ТекстДляВыполнения, ЛиСинтаксическийКонтроль = Ложь) Экспорт

	Возврат ирКэш.Получить().ВыполнитьЛокально(ТекстДляВыполнения);

КонецФункции // ВыполнитьЛокально()

////////////////////////////////////////////////////////////////////////////////
//	ВСПОМОГАТЕЛЬНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

Функция ПолучитьСтруктуруВнешнейОбработки(Алгоритм) Экспорт
	
	Возврат мСтруктурыВнешнихОбработокАлгоритмов.Получить(Алгоритм);
	
КонецФункции

Процедура УстановитьСтруктуруВнешнейОбработки(Алгоритм, Структура) Экспорт
	
	мСтруктурыВнешнихОбработокАлгоритмов.Вставить(Алгоритм, Структура);
	
КонецПроцедуры

Процедура СобратьКонтекст(Алгоритм) Экспорт 

	Алгоритм.ДатаИзмененияКонтекста = Алгоритм.ДатаИзменения;

КонецПроцедуры // СобратьКонтекст()

Функция ПолучитьСтруктуруАлгоритма()
	
	Возврат Новый Структура("Ключ, Наименование, ТекстАлгоритма, ДатаИзменения, Комментарий, Параметры, ДатаИзмененияКонтекста, ИндивидуальнаяВнешняяОбработка, ОтносительныйПуть, КлючРодителя, ЭтоГруппа");
	
КонецФункции

Функция ПолучитьСтруктуруАлгоритмаДляЗаписиВФайл()
	
	Возврат Новый Структура("ТекстАлгоритма, ДатаИзменения, Комментарий, Параметры");
	
КонецФункции

Функция ПолучитьНовыйКлюч()
	
	максКлюч = максКлюч + 1;
	Возврат максКлюч;
	
КонецФункции
   
Функция ПолучитьПолноеИмяФайлаАлгоритма(Алгоритм, ВариантПолучения = "Текущее")
	
	Если ВариантПолучения = "Новое" Тогда
		
		ОтносительныйПуть = "";
	
		Если НЕ Алгоритм.КлючРодителя = 0 Тогда
			
			ГруппаАлгоритма = ПолучитьАлгоритмПоКлючу(Алгоритм.КлючРодителя); 
			
			Если ГруппаАлгоритма <> Неопределено Тогда
				
				ОтносительныйПуть = ГруппаАлгоритма.ОтносительныйПуть;
				
			КонецЕсли;
			
		КонецЕсли;
		
		Возврат мПутьАлгоритмы + ОтносительныйПуть + "\" + Алгоритм.Наименование + ?(НЕ Алгоритм.ЭтоГруппа, ".alg", "");
		
	КонецЕсли; 
	
	Если ВариантПолучения = "Текущее" Тогда
		
		Возврат мПутьАлгоритмы + Алгоритм.ОтносительныйПуть;
		
	КонецЕсли; 
	
	ВызватьИсключение "Неверный параметр ВариантПолучения """  + ВариантПолучения + """"; 
	
КонецФункции

Функция ПолучитьИмяФайлаАлгоритма(Алгоритм)
	
	Если ЭтоНовыйАлгоритм(Алгоритм) Тогда
		
		Возврат Алгоритм.Наименование + ".alg";
		
	КонецЕсли; 
	
	ГруппаАлгоритма = ПолучитьАлгоритмПоКлючу(Алгоритм.КлючРодителя);
	Возврат СтрЗаменить(Алгоритм.ОтносительныйПуть, ГруппаАлгоритма.ОтносительныйПуть, "");
	     	
КонецФункции // ПолучитьИмяФайлаАлгоритма()
 
Функция ПолучитьОтносительныйПутьПоПолномуИмениФайла(ПолноеИмяФайла)

	Возврат СтрЗаменить(ПолноеИмяФайла, мПутьАлгоритмы, "");

КонецФункции // ПолучитьОтносительныйПутьПоПолномуИмениФайла()
 
Процедура ЗаменитьРекурсивноОтносительныеПути(СтрокаАлгоритма, СтарыйОтносительныйПуть, НовыйОтносительныйПуть)
	
	СтрокаАлгоритма.ОтносительныйПуть = НовыйОтносительныйПуть + СтрЗаменить(СтрокаАлгоритма.ОтносительныйПуть, СтарыйОтносительныйПуть, "");
	
	Потомки = Алгоритмы.НайтиСтроки(Новый Структура("КлючРодителя", СтрокаАлгоритма.Ключ));
	
	Для Каждого Потомок Из Потомки Цикл
		
		ЗаменитьРекурсивноОтносительныеПути(Потомок, СтарыйОтносительныйПуть, НовыйОтносительныйПуть);
		
	КонецЦикла; 
	
КонецПроцедуры // ЗаменитьРекурсивноОтносительныеПути()

// + АВВ [23.03.2013] 
Процедура мирИнициализировать() Экспорт
	
	Если мирИнициализирована Тогда		
		Возврат;		
	КонецЕсли; 
	
	мПутьАлгоритмы = "";
	мСтруктурыВнешнихОбработокАлгоритмов = Новый Соответствие;		
	
	мирИнициализирована = Истина;
	
КонецПроцедуры